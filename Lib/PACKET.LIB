/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** Beginheader */
#ifndef __PACKET_LIB
#define __PACKET_LIB
#define BASEFREQ 614400.0

#define PKT_NOPARITY 0
#define PKT_OPARITY 1
#define PKT_EPARITY 2
#define PKT_TWOSTOP 3

#define PKT_GAPMODE 0
#define PKT_9BITMODE 1
#define PKT_CHARMODE 2

//for 9 bit mode
#define PKT_RABBITSTARTBYTE 0
#define PKT_LOWSTARTBYTE 1
#define PKT_HIGHSTARTBYTE 2

#define PKT_BUFFEROVERFLOW 0x01
#define PKT_RXOVERRUN 0x02
#define PKT_PARITYERROR 0x04
#define PKT_NOBUFFER 0x08

/*** endheader */


/* START LIBRARY DESCRIPTION *********************************************
PACKET.LIB

OVERVIEW
	The interface is designed to provide the users with a set of functions that
	send and receive packets of data in user defined data structures.

NAMING CONVENTION
	The naming convention is pktXfn:
	pkt - packet driver
	X   - the port being used: A,B,C,D,E or F
	fn  - the function being implemented
	Example: pktDsend, the packet driven port D function send().

DESCRIPTION:
	This library contains RS485 packet driver interface functions compatible
	with the	Rabbit microprocessor. It also contains prototypes and reference
	to three board specific RS485 control functions for which the user must
	provide definitions:
	 void pktXinit(); // Perform any RS485 initialization require by the board.
	 void pktXtx();   // Put the channel into Tx mode
	 void pktXrx();   // Put the channel into Rx mode.

END DESCRIPTION **********************************************************/


//************************************************************************
//****************************** PORT A **********************************
//************************************************************************


/*** Beginheader pktAopen, pktAclose, pktAinitBuffers, apkt_nextdone */
int pktAopen(long baud, int mode, char options, int (*test_packet)());
root void pktAclose();
int pktAinitBuffers(int buf_count, int buf_size);
void apkt_nextdone();

int apkt_sendbyte();
void apkt_enableport();
void apkt_disableport();

extern unsigned long apkt_rxbuffers;
extern int apkt_rxcount;
extern int apkt_rxsize;
extern int apkt_rxpos;
extern int apkt_rxnext;		//next buffer to be read out
extern int apkt_rxcurrent;	//buffer being written to
extern unsigned long apkt_rxcurrent_ptr; //temp pointer to start of current buffer

extern int apkt_lastpos;
extern char *apkt_txframe;
extern int apkt_txcount;
extern int apkt_txsize;
extern char apkt_type;
extern char apkt_parity;
extern char apkt_rxgapcount;
extern char apkt_rxgapsize;
extern char apkt_txdelay;
extern char apkt_startchar;
extern char apkt_txdone;
extern char apkt_9bittype;
extern char apkt_divisor;
extern char apkt_fastdivisor;
extern char apkt_longstop;
extern char apkt_portenabled;
//pointer to function that tests for complete packets
extern int (*apkt_testpacket)(); //takes (void *, int) as args
extern char apkt_txactive;
extern char apkt_waitforgap;

//errors
extern char apkt_parityerror;
extern char apkt_rxoverrun;
extern char apkt_overflow;
extern char apkt_nobuffer;

/*** endheader */

unsigned long apkt_rxbuffers;
int apkt_rxcount;
int apkt_rxsize;
int apkt_rxpos;
int apkt_rxnext;		//next buffer to be read out
int apkt_rxcurrent;	//buffer being written to
unsigned long apkt_rxcurrent_ptr; //temp pointer to start of current buffer

int apkt_lastpos;
char *apkt_txframe;
int apkt_txcount;
int apkt_txsize;
char apkt_type;
char apkt_parity;
char apkt_rxgapcount;
char apkt_rxgapsize;
char apkt_txdelay;
char apkt_startchar;
char apkt_txdone;
char apkt_9bittype;
char apkt_divisor;
char apkt_fastdivisor;
char apkt_longstop;
char apkt_portenabled;
//pointer to function that tests for complete packets
int (*apkt_testpacket)(); //takes (void *, int) as args
char apkt_txactive;
char apkt_waitforgap;

//errors
char apkt_parityerror;
char apkt_rxoverrun;
char apkt_overflow;
char apkt_nobuffer;

extern void pktAinit();
extern void pktArx();
extern void pktAtx();

#define ADRIVE_TXMASK 0x40


//internal functions
void apkt_init( void (*isr)() );
void apkt_gapisr();
void apkt_9bitisr();
void apkt_charisr();

/* START FUNCTION DESCRIPTION ********************************************
pktAopen                   <PACKET.LIB>

SYNTAX:		   int pktAopen(long baud,
									 int mode,
									 char options,
									 int (*test_packet)() );

DESCRIPTION:   Opens the A serial port.

PARAMETER1:    Bits per second of data transfer: min 2400

PARAMETER2:		mode - type of packet scheme used, options are:
						PKT_GAPMODE
						PKT_9BITMODE
						PKT_CHARMODE

PARAMETER3:		options - further specification for the packet scheme
						The value of this depends on the mode used.
						gap mode - minimum gap size(in byte times)
						9bit mode - type of 9bit protocol
							PKT_RABBITSTARTBYTE
							PKT_LOWSTARTBYTE
							PKT_HIGHSTARTBYTE
						char mode - character marking start of packet

PARAMETER4:		ptr to function that tests for completeness of a packet. The
					function should return 1 if the packet is complete, or 0 if
					more data should be read in. For gap mode the test function is
					not used and should be set to NULL.

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

END DESCRIPTION **********************************************************/

nodebug int pktAopen(long baud, int mode, char options, int (*test_packet)())
{
   auto long divisor, ta1div;
	auto float baud_ratio;
	auto unsigned long t;
	auto int temp, i;

   apkt_type = mode;
   apkt_parity = 0;
	apkt_txactive = 0;
	apkt_txdone = 0;
	apkt_waitforgap = 0;
	apkt_longstop = 0;
	apkt_rxgapcount = 0;
	apkt_lastpos = 0;

	apkt_parityerror = 0;
	apkt_rxoverrun = 0;
	apkt_overflow = 0;
	apkt_nobuffer = 0;

	apkt_rxcurrent = 0;
	apkt_rxcurrent_ptr = apkt_rxbuffers; //first buffer
	apkt_rxpos = 0;
	apkt_rxnext = 0;
	//initialize the buffers
	temp = 0;
	for(i = 0;i < apkt_rxcount;i++)
	{
		root2xmem(apkt_rxbuffers + i*(apkt_rxsize + 2), &temp, 2);
	}


	apkt_testpacket = test_packet;

   if (baud < 1) baud = 1;
   // (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"

	ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	BitWrPortI(TACR, &TACRShadow, 1, 4);
	}
	else
	{
		BitWrPortI(TACR, &TACRShadow, 0, 4);
	}
	WrPortI(TAT4R, &TAT4RShadow, (char)divisor);

	//set up mode and options
	if (mode == PKT_GAPMODE)
	{
		apkt_rxgapsize = options;
   	apkt_init(apkt_gapisr);
   }
   else if (mode == PKT_9BITMODE)
   {
   	apkt_9bittype = options;
   	apkt_init(apkt_9bitisr);
	}
	else
	{
		apkt_startchar = options;
		apkt_init(apkt_charisr);
	}
   apkt_divisor = (char)divisor;
   apkt_fastdivisor = (char)divisor / 8;
   if (apkt_fastdivisor < 1) apkt_fastdivisor = 1;

   // let baud timer time out before using port
   t = MS_TIMER;
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   pktAinit();
   apkt_disableport();
   return (((long)((BASEFREQ*freq_divider) /
   	(32 * (divisor + 1)) + 0.5)) == baud);    // rounded baud actually used
}

/* START FUNCTION DESCRIPTION ********************************************
pktAinitBuffers                   <PACKET.LIB>

SYNTAX:		   int pktAinitBuffers(int buf_count, int buf_size);

DESCRIPTION:   Allocates extended memory for the channel A receive buffers.
					This function should not be called more than once in a program.
					The total memory allocated is count*(size + 2) bytes

PARAMETER1:    buf_count - the number of buffers to allocate. Each buffer can
					store one received packet. Increasing this number allows for
					more pending packets and a larger latency time before packets
					must be processed by the user's program.

PARAMETER2:		buf_size - the number of bytes each buffer can accomodate. This
					should be set to the size of the largest possible packet
					that can be expected.

RETURN VALUE:	1: The xmem allocation was successful
               0: The allocation failed. This packet channel cannot be used.

END DESCRIPTION **********************************************************/

nodebug int pktAinitBuffers(int buf_count, int buf_size)
{
	apkt_rxcount = buf_count;
	if(buf_size % 2)
	{
		buf_size++;   //make sure buffer sizes are even
	}
	apkt_rxsize = buf_size;
	apkt_rxbuffers = xalloc(buf_count*(buf_size+2)+2);
	if(apkt_rxbuffers % 2)
	{
		apkt_rxbuffers++;		//make sure buffers start on even boundaries
	}

	if(!apkt_rxbuffers)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}


/* START FUNCTION DESCRIPTION ********************************************
pktAclose                   <PACKET.LIB>

SYNTAX:		   void pktAclose();

DESCRIPTION:   Disables the A serial port.

PARAMETER1:    None

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

#if _USER
#asm root
pktAclosed::
	ret
#endasm
#endif


#asm root
pktAclose::
#if _USER
c	 SetVectIntern(SERA_OFS/0x10, pktAclosed);
#else
	 ld	 a,0xc9         ; ret in first byte
	 ipset 1
	 ld	 (INTVEC_BASE + SERA_OFS),a
#endif

	 ld	 a, 0x00
; 	ioi ld	 (SACR),a
	IOWRITE_A(SACR)
	 ipres
	 ret

;
; apkt_init
;

apkt_init::
#if _USER
	push	hl
   ld		hl,SERA_OFS/0x10
   push	hl
   call  SetVectIntern
   add	sp,2
#else
	 ld    iy, INTVEC_BASE + SERA_OFS
	 ipset 1
	 ld	 (iy), 0C3h			; the JP command
	 ld	 (iy+1), hl			; ISR for a particular mode
#endif

	 call	 apkt_isr_disableport

	 ld	 a,0x01			; enable interrupts for port
;ioi ld	 (SACR),a
	IOWRITE_A(SACR)
	 ipres
	 ret

apkt_isr_enableport::
    ld	 a,(PCFRShadow)
    or	 ADRIVE_TXMASK              ; enable serial port D transmitter
    ld	 (PCFRShadow),a
;ioi ld	 (PCFR),a
	IOWRITE_A(PCFR)
	 call  pktAtx			;user defined asm routine
	 ld	 a, 0x01
	 ld	 (apkt_portenabled), a
	 ret

apkt_enableport::
	 ipset 1
	 call	 apkt_isr_enableport
	 ipres
	 ret

apkt_disableport::
	 ipset 1
	 call apkt_isr_disableport
	 ipres
	 ret

apkt_isr_disableport::
	 call	 apkt_disabledrive
	 call  pktArx		;user defined asm routine
	 ret

apkt_disabledrive::		;seperate call for longstops
	 ld	 a, (PCDRShadow)
	 or	 ADRIVE_TXMASK
	 ld	 (PCDRShadow), a
;ioi ld	 (PCDR), a
	IOWRITE_A(PCDR)
    ld	 a,(PCFRShadow)
    and	 ~ADRIVE_TXMASK              ; disable serial port D transmitter
    ld	 (PCFRShadow),a
;ioi ld	 (PCFR),a
	IOWRITE_A(PCFR)
	 xor	 a
	 ld	 (apkt_portenabled), a
	 ret

#endasm

#asm root

apkt_sendbyte::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (apkt_txcount)
	 ld	 hl, (apkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (apkt_txcount)
	 ld	 hl, (apkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (apkt_txcount), de	;increment txcount
	 ld	 a, (apkt_parity)
	 or	 a
	 jr	 z, .send8bit
	 dec	 a
	 jr	 z, .sendodd
	 dec	 a
	 jr	 z, .sendeven
	 jr	 .send9high		;2 stop bits, 9th bit always high

.sendeven:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity		;returns true if odd
	 bool	 hl
	 jr	 nz, .send9low		;byte is already even parity
	 jr	 .send9high
.sendodd:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .send9low	;byte is already odd parity
	 jr	 .send9high
.send8bit:
	 ld	 a, c
;ioi ld	 (SADR), a
	IOWRITE_A(SADR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SAAR), a
	IOWRITE_A(SAAR)
	 jr	 .sendexit
#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
.send9high:
	 ld	 a, c
;ioi ld	 (SALR), a
	IOWRITE_A(SALR)
	 jr	 .sendexit
#else
.send9high:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, .send9longstop
	 ld	 a, c
;ioi ld	 (SALR), a
	IOWRITE_A(SALR)
	 jr	 .sendexit
.send9longstop:
	 ld	 a, 0x01
	 ld	 (apkt_longstop), a
	 jr	 .send8bit
#endif
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

apkt_send9bit::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (apkt_txcount)
	 ld	 hl, (apkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (apkt_txcount)
	 ld	 hl, (apkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (apkt_txcount), de	;increment txcount

	 ld	 a, (apkt_9bittype)
	 or	 a
	 jr	 z, .rabbitstart
	 dec	 a
	 jr	 z, .lowstart
.highstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9high
	 jr	 .send9low
.lowstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low	;if de <= 1
	 jr	 .send9high
.rabbitstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low
.send8bit:
	 ld	 a, c
;ioi ld	 (SADR), a
	IOWRITE_A(SADR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SAAR), a
	IOWRITE_A(SAAR)
	 jr	 .sendexit
#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
.send9high:
	 ld	 a, c
;ioi ld	 (SALR), a
	IOWRITE_A(SALR)
	 jr	 .sendexit
#else
.send9high:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, .send9longstop
	 ld	 a, c
;ioi ld	 (SALR), a
	IOWRITE_A(SALR)
	 jr	 .sendexit
.send9longstop:
	 ld	 a, 0x01
	 ld	 (apkt_longstop), a
	 jr	 .send8bit
#endif
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

; assumes byte is stored in B, can trash other registers
apkt_recvbyte::

	 push	 ix
	 ld	 ix, (apkt_rxcurrent_ptr)
	 ld	 a, (apkt_rxcurrent_ptr + 2)
	 ldp	 hl, (ix)		;get length field
	 bool	 hl
	 jr	 nz, .no_buffer		;buffer is full
	 ld	 de, 2
	 add	 ix, de
	 adc	 a, 0					;carry if needed
	 ld	 de, (apkt_rxpos)
	 add	 ix, de
	 adc	 a, 0					;carry add into high bit
	 ldp	 hl, (ix)
	 ld	 L, b					;from ISR, b holds received byte
	 ldp	 (ix), hl
	 inc	 de					;de still holds rxpos
	 ld	 hl, (apkt_rxsize)
	 or	 a						;clear carry
	 sbc	 hl, de
	 jr	 z, .buffer_overflow
	 ld	 (apkt_rxpos), de
	 jr	 .recvdone

.no_buffer:
	 ld	 a, 0x01
	 ld	 (apkt_nobuffer), a
	 jr	 .recvdone

.buffer_overflow:
	 ld	 a, 0x01
	 ld	 (apkt_overflow), a
	 ld	 hl, 0
	 ld	 (apkt_rxpos), hl		;set pos to beginning of buffer
.recvdone:
	 pop	 ix
	 ret

#endasm

#asm root

apkt_finish::
	 push	 bc
	 push	 ix
	 ld	 hl, (apkt_rxpos)
	 bool	 hl
	 jr	 z, .done		;no packet
	 ld	 ix, (apkt_rxcurrent_ptr)
	 ld	 a, (apkt_rxcurrent_ptr + 2)
	 ld	 hl, (apkt_rxpos)		;load length into buffer
	 ldp	 (ix), hl
	 ld	 de, (apkt_rxcurrent)
	 inc	 de
	 ld	 hl, (apkt_rxcount)
	 or	 a		;clear carry
	 sbc	 hl, de
	 jr	 nz, .newbuffer
	 ld	 d, 0
	 ld	 e, 0					;zero out current buffer number
.newbuffer:
	 ld	 (apkt_rxcurrent), de
	 ld	 hl, (apkt_rxsize)
	 inc	 hl
	 inc	 hl					;add 2 to size for total buffer size
	 ld	 c, L
	 ld	 b, h
	 mul							;current * (size+2)
	 ld	 e, L					;high byte of result now in e
	 ld	 hl, (apkt_rxbuffers)		;base of buffer array
	 ld	 a, (apkt_rxbuffers + 2)
	 add	 hl, bc
	 adc	 a, e
	 ld	 (apkt_rxcurrent_ptr), hl	;set new current ptr
	 ld	 (apkt_rxcurrent_ptr + 2), a
	 bool	 hl
	 ld	 L, 0
	 ld	 (apkt_rxpos), hl			;zero out position
.done:
	 pop	 ix
	 pop	 bc
	 ret

#endasm

#asm root

apkt_nextdone::
	 ipset 1
	 ld	 hl, (apkt_rxnext)
	 ld	 de, (apkt_rxcurrent)
	 or	 a
	 sbc	 hl, de
	 jr	 nz, .done
	 call	 apkt_finish			;complete current packet
.done:
	 ipres
	 ret

#endasm

#asm root

;assumes byte is in B, SASR snapshot is in C
apkt_paritytest::
	 ld	 a, (apkt_parity)
	 dec	 a
	 or	 a
	 jr	 z, .oddparity
.evenparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	hl
	 jr	 z, .check9high
	 jr	 .check9low

.oddparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .check9low
.check9high:
	 bit	 6, c
	 jr	 z, .paritydone
	 jr	 .setparityerror

.check9low:
	 bit	 6, c
	 jr	 nz, .paritydone
.setparityerror:
	 ld	 a, 0x01
	 ld	 (apkt_parityerror), a
.paritydone:
	 ret

#endasm

#asm root

apkt_gapisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SASR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SASR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SASR), a			;clear interrupt
	IOWRITE_A(SASR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (apkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (apkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 apkt_sendbyte		;try and send another byte,
	 									; with possible parity bit
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
										;handle gaps, transitions, etc.
	 ld	 a, (apkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (apkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT4R),a
	IOWRITE_A(TAT4R)

	 ld	 a, (apkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 ;decide if we need to send a gap or data???
	 ld	 a, (apkt_txactive)	;are we transmitting?
	 or	 a
	 jr	 z, .isr_rxdummy		;dummy is for rx gap timing
	 ld	 a, (apkt_txdelay)
	 or	 a
	 jr	 nz, .isr_txdummy
	 call	 apkt_isr_enableport		;make sure we can send data
	 call	 apkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (apkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 apkt_isr_disableport
;ioi ld	 (SADR), a				;load final dummy
	IOWRITE_A(SADR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:							;moved up to keep jump in range
;ioi ld	 a, (SADR)			;read byte, clear interrupt
	IOREAD_A(SADR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (apkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT4R),a
	IOWRITE_A(TAT4R)
	 call	 apkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (apkt_longstop), a			;clear out long stop flag
	 call  apkt_isr_disableport
;ioi ld	 (SADR), a						;do a fast dummy
	IOWRITE_A(SADR)
	 jr	 .isr_txdone

.isr_txdummy:						;dummy for tx delay
	 dec	 a
	 ld	 (apkt_txdelay), a
	 call	 apkt_isr_disableport
;ioi ld	 (SADR), a				;load dummy
	IOWRITE_A(SADR)
	 jr	 .isr_txdone

.isr_rxdummy:
	 ld	 a, (apkt_rxgapcount)
	 or	 a
	 jr	 z, .isr_rxendpacket		;a full gap was detected
	 dec	 a
	 ld	 (apkt_rxgapcount), a
;ioi ld	 (SADR), a					;load dummy
	IOWRITE_A(SADR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (apkt_txdone), a
	 ld	 (apkt_txactive), a
	 jr	 .isr_txdone

.isr_rxendpacket:
	 call	 apkt_finish
	 jr	 .isr_txdone


.isr_rxchecktx:
	 ld	 a, (apkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcheckparity
	 ld	 a, 0x01
	 ld	 (apkt_rxoverrun), a
.isr_rxcheckparity:
	 ld	 a, (apkt_parity)
	 or	 a
	 jr	 z, .isr_rxcontinue		;next step
	 call  apkt_paritytest

.isr_rxcontinue:					;no defined start byte, just load it
	 ld	 a, (apkt_waitforgap)
	 or	 a
	 jr	 nz, .isr_rxresetgap		;waiting for a gap
	 call	 apkt_recvbyte
.isr_rxresetgap:
	 ld	 a, (apkt_rxgapsize)
	 ld	 (apkt_rxgapcount), a	;reset the gap counter
;ioi ld	 (SADR), a					;send dummy byte for gap timing
	IOWRITE_A(SADR)
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

apkt_9bitisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SASR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SASR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SASR), a			;clear interrupt
	IOWRITE_A(SASR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (apkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (apkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 apkt_send9bit			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (apkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (apkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT4R),a
	IOWRITE_A(TAT4R)

	 ld	 a, (apkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 apkt_isr_enableport		;make sure we can send data
	 call	 apkt_send9bit			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (apkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 apkt_isr_disableport
;ioi ld	 (SADR), a				;load final dummy
	IOWRITE_A(SADR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SADR)			;read byte, clear interrupt
	IOREAD_A(SADR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (apkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT4R),a
	IOWRITE_A(TAT4R)
	 call	 apkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (apkt_longstop), a			;clear out long stop flag
	 call  apkt_isr_disableport
;ioi ld	 (SADR), a						;do a fast dummy
	IOWRITE_A(SADR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (apkt_txdone), a
	 ld	 (apkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (apkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (apkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (apkt_9bittype)
	 or	 a							;zero test A
	 jr	 z, .isr_rxchecklowstart
	 dec	 a
	 jr	 z, .isr_rxchecklowstart
.isr_rxcheckhighstart:
	 bit	 6, c
	 jr	 z, .isr_rxstart
	 jr	 .isr_rxnotstart
.isr_rxchecklowstart:
	 bit	 6, c
	 jr	 nz, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (apkt_rxpos)
	 bool	 hl
	 jr	 nz, .isr_rxload		;we are in the middle of a packet
	 jr	 .isr_rxdone
.isr_rxload:
	 call	 apkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call	 apkt_finish
	 call	 apkt_recvbyte

.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

apkt_charisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SASR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SASR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SASR), a			;clear interrupt
	IOWRITE_A(SASR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (apkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (apkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 apkt_sendbyte			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (apkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (apkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT4R),a
	IOWRITE_A(TAT4R)

	 ld	 a, (apkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 apkt_isr_enableport		;make sure we can send data
	 call	 apkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (apkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 apkt_isr_disableport
;ioi ld	 (SADR), a				;load final dummy
	IOWRITE_A(SADR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SADR)			;read byte, clear interrupt
	IOREAD_A(SADR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (apkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT4R),a
	IOWRITE_A(TAT4R)
	 call	 apkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (apkt_longstop), a			;clear out long stop flag
	 call  apkt_isr_disableport
;ioi ld	 (SADR), a						;do a fast dummy
	IOWRITE_A(SADR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (apkt_txdone), a
	 ld	 (apkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (apkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (apkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (apkt_startchar)
	 cp	 b
	 jr	 z, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (apkt_rxpos)
	 bool	 hl
	 jr	 z, .isr_rxdone		;keep waiting for a start byte
.isr_rxload:
	 call	 apkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call apkt_finish
	 call	apkt_recvbyte
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

/*** BeginHeader pktAsetParity */
void pktAsetParity(char mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktAsetParity                   <PACKET.LIB>

SYNTAX:		   void pktAsetParity(char mode);

DESCRIPTION:   Configures parity generation and checking
					Can also configure for 2 stop bits.

PARAMETER1:		Code for mode of parity bit
					PKT_NOPARITY - no parity bit (8N1 format, default)
					PKT_OPARITY 1 - odd parity (8O1 format)
					PKT_EPARITY 2 - even parity (8E1 format)
					PKT_TWOSTOP 3 - an extra stop bit (8N2 format)

END DESCRIPTION **********************************************************/

nodebug void pktAsetParity(char mode)
{
	apkt_parity = mode;
}

/*** BeginHeader pktAsending */
int pktAsending();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktAsending                   <PACKET.LIB>

SYNTAX:		   int pktAsending();

DESCRIPTION:   Tests if a packet is currently being sent. If this returns
					true, the transmitter is bus and cannot accept another packet.

RETURN VALUE:	1: A packet is being transmitted on port A
               0: port A is idle, ready for a new packet

END DESCRIPTION **********************************************************/

nodebug int pktAsending()
{
	return (int)apkt_txactive;
}

/*** BeginHeader pktAsend */
int pktAsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktAsend                   <PACKET.LIB>

SYNTAX:		   int pktAsend(void *send_buffer,
									 int buffer_length,
									 char delay);

DESCRIPTION:   Initiates the sending of a packet of data. This function will
					always return immediately. If there is already a packet being
					transmitted, this call will return 0 and the packet will not be
					transmitted, otherwise it will return 1.
					The pktAsending() function is used to check
					if the packet is done transmitting. The system will be using the
					buffer until then.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

RETURN VALUE:	1 if the packet is goint to be transmitted
					0 if there is already a packet transmitting, and the new packet
						was refused.

END DESCRIPTION **********************************************************/

nodebug int pktAsend(void *send_buffer, int buffer_length, char delay)
{
	//loop until tx is ready
	if (pktAsending())
	{
		return 0;
	}
	else
	{
		apkt_txframe = send_buffer;
		apkt_txsize = buffer_length;
		apkt_txcount = 0;
		apkt_txdelay = delay;
		apkt_txactive = 1;				//set active flag
		if(delay)
		{
			apkt_disableport();
			WrPortI(SADR, NULL, 23);		//send a dummy character to start
		}
		else
		{
			apkt_enableport();
			if(apkt_type == PKT_9BITMODE)
			{
				apkt_send9bit();
			}
			else
			{
				apkt_sendbyte();
			}
		}
		return 1;
	}
}

/*** BeginHeader cof_pktAsend */
scofunc void cof_pktAsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktAsend                   <PACKET.LIB>

SYNTAX:		   void cof_pktAsend(void *send_buffer,
									  		int buffer_length,
									  		char delay);

DESCRIPTION:   Cofunction version of pktAsend(). This function will yield
					to other tasks while the packet is being sent. It differs from
					pktAsend() in that it will not return until the packet is
					done transmitting.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_pktAsend(void *send_buffer,
											 int buffer_length,
											 char delay)
{
	//wait until tx is ready
	while (pktAsending()) yield;

	apkt_txframe = send_buffer;
	apkt_txsize = buffer_length;
	apkt_txcount = 0;
	apkt_txdelay = delay;
	apkt_txactive = 1;				//set active flag
	if(delay)
	{
		apkt_disableport();
		WrPortI(SADR, NULL, 23);		//send a dummy character to start
	}
	else
	{
		apkt_enableport();
		if(apkt_type == PKT_9BITMODE)
		{
			apkt_send9bit();
		}
		else
		{
			apkt_sendbyte();
		}
	}
	while (pktAsending()) yield;	//wait for this packet to finish
}

/*** BeginHeader pktAreceive */
int pktAreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktAreceive                   <PACKET.LIB>

SYNTAX:		   int pktAreceive(void *buffer, int buffer_size);

DESCRIPTION:   Gets a received packet if there is one in the packet buffer.
					Otherwise, it will immediately return 0.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE: >0: The number of bytes in the received packet.
				  0: indicates that no new packets have been received.
				  -1: indicates that the packet is too large for the given buffer
				  -2: if a needed test_packet function is not defined

END DESCRIPTION **********************************************************/

nodebug int pktAreceive(void *buffer, int buffer_size)
{
	auto int rxpos;
	auto int packet_length;
	auto int buffer_offset;
	auto int temp;

	rxpos = apkt_rxpos;
	buffer_offset = apkt_rxnext*(apkt_rxsize+2);
	xmem2root(&packet_length, apkt_rxbuffers + buffer_offset, 2);
	if(packet_length)
	{
		//packet is definitely done
		if(packet_length <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, apkt_rxbuffers + buffer_offset + 2, packet_length);
			temp = 0;
			root2xmem(apkt_rxbuffers + buffer_offset, &temp, 2); //clear out
			apkt_rxnext = (apkt_rxnext + 1) % apkt_rxcount;
			apkt_lastpos = 0;
			return packet_length;
		}
		else
		{
			return -1;
		}
	}
	else if(apkt_type != PKT_GAPMODE && rxpos != apkt_lastpos)
	{
		if (apkt_testpacket == NULL)
		{
			return -2;
		}
		//check for complete packet
		if(rxpos <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, apkt_rxbuffers + buffer_offset + 2, rxpos);
			if ( (*apkt_testpacket)(buffer, rxpos) )
			{
				apkt_nextdone(); //complete packet
				temp = 0;
				root2xmem(apkt_rxbuffers + buffer_offset, &temp, 2); //clear out
				apkt_rxnext = (apkt_rxnext + 1) % apkt_rxcount;
				apkt_lastpos = 0;
				return rxpos;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return 0;
	}
}

/*** BeginHeader cof_pktAreceive */
scofunc int cof_pktAreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktAreceive                   <PACKET.LIB>

SYNTAX:		   int cof_pktAreceive(void *buffer, int buffer_size);

DESCRIPTION:   This cofunction is used to listen for received packets.
					It will return with a packet immediately if there is one in
					in the buffer. Otherwise, it will wait for one while yielding
					to other tasks.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE:	The length of the received packet or an error code
					identical to those in pktAreceive()

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_pktAreceive(void *buffer, int buffer_size)
{
	auto int length;
	while((length = pktAreceive(buffer, buffer_size)) == 0)
	{
		yield;
	}
	return length;
}


/*** BeginHeader pktAgetErrors */
char pktAgetErrors();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktAgetErrors                   <PACKET.LIB>

SYNTAX:		   char pktAgetErrors();

DESCRIPTION:   Gets a bit field with flags set for any errors that occured.
					These flags are then cleared, so that a particular error
					will only cause the flag to be set once.

RETURN VALUE:	A bit field with flags for various errors. The errors
					along with their bit masks are as follows:
						PKT_BUFFEROVERFLOW 0x01
						PKT_RXOVERRUN 0x02
						PKT_PARITYERROR 0x04
						PKT_NOBUFFER 0x08

END DESCRIPTION **********************************************************/

nodebug char pktAgetErrors()
{
	auto char error_flags;

	error_flags = 0;
	if (apkt_overflow) {
		error_flags |= PKT_BUFFEROVERFLOW;
		apkt_overflow = 0;		//clear the error after reporting it
	}
	if (apkt_rxoverrun) {
		error_flags |= PKT_RXOVERRUN;
		apkt_rxoverrun = 0;
	}
	if (apkt_parityerror) {
		error_flags |= PKT_PARITYERROR;
		apkt_parityerror = 0;
	}
	if (apkt_nobuffer) {
		error_flags |= PKT_NOBUFFER;
		apkt_nobuffer = 0;
	}


	return error_flags;
}


//************************************************************************
//****************************** PORT B **********************************
//************************************************************************


/*** Beginheader pktBopen, pktBclose, pktBinitBuffers, bpkt_nextdone */
int pktBopen(long baud, int mode, char options, int (*test_packet)());
root void pktBclose();
int pktBinitBuffers(int buf_count, int buf_size);
void bpkt_nextdone();

int bpkt_sendbyte();
void bpkt_enableport();
void bpkt_disableport();

extern unsigned long bpkt_rxbuffers;
extern int bpkt_rxcount;
extern int bpkt_rxsize;
extern int bpkt_rxpos;
extern int bpkt_rxnext;		//next buffer to be read out
extern int bpkt_rxcurrent;	//buffer being written to
extern unsigned long bpkt_rxcurrent_ptr; //temp pointer to start of current buffer

extern int bpkt_lastpos;
extern char *bpkt_txframe;
extern int bpkt_txcount;
extern int bpkt_txsize;
extern char bpkt_type;
extern char bpkt_parity;
extern char bpkt_rxgapcount;
extern char bpkt_rxgapsize;
extern char bpkt_txdelay;
extern char bpkt_startchar;
extern char bpkt_txdone;
extern char bpkt_9bittype;
extern char bpkt_divisor;
extern char bpkt_fastdivisor;
extern char bpkt_longstop;
extern char bpkt_portenabled;
//pointer to function that tests for complete packets
extern int (*bpkt_testpacket)(); //takes (void *, int) as args
extern char bpkt_txactive;
extern char bpkt_waitforgap;

//errors
extern char bpkt_parityerror;
extern char bpkt_rxoverrun;
extern char bpkt_overflow;
extern char bpkt_nobuffer;

/*** endheader */

unsigned long bpkt_rxbuffers;
int bpkt_rxcount;
int bpkt_rxsize;
int bpkt_rxpos;
int bpkt_rxnext;		//next buffer to be read out
int bpkt_rxcurrent;	//buffer being written to
unsigned long bpkt_rxcurrent_ptr; //temp pointer to start of current buffer

int bpkt_lastpos;
char *bpkt_txframe;
int bpkt_txcount;
int bpkt_txsize;
char bpkt_type;
char bpkt_parity;
char bpkt_rxgapcount;
char bpkt_rxgapsize;
char bpkt_txdelay;
char bpkt_startchar;
char bpkt_txdone;
char bpkt_9bittype;
char bpkt_divisor;
char bpkt_fastdivisor;
char bpkt_longstop;
char bpkt_portenabled;
//pointer to function that tests for complete packets
int (*bpkt_testpacket)(); //takes (void *, int) as args
char bpkt_txactive;
char bpkt_waitforgap;

//errors
char bpkt_parityerror;
char bpkt_rxoverrun;
char bpkt_overflow;
char bpkt_nobuffer;

extern void pktBinit();
extern void pktBrx();
extern void pktBtx();

#define BDRIVE_TXMASK 0x10


//internal functions
void bpkt_init( void (*isr)() );
void bpkt_gapisr();
void bpkt_9bitisr();
void bpkt_charisr();

/* START FUNCTION DESCRIPTION ********************************************
pktBopen                   <PACKET.LIB>

SYNTAX:		   int pktBopen(long baud,
									 int mode,
									 char options,
									 int (*test_packet)() );

DESCRIPTION:   Opens the B serial port.

PARAMETER1:    Bits per second of data transfer: min 2400

PARAMETER2:		mode - type of packet scheme used, options are:
						PKT_GAPMODE
						PKT_9BITMODE
						PKT_CHARMODE

PARAMETER3:		options - further specification for the packet scheme
						The value of this depends on the mode used.
						gap mode - minimum gap size(in byte times)
						9bit mode - type of 9bit protocol
							PKT_RABBITSTARTBYTE
							PKT_LOWSTARTBYTE
							PKT_HIGHSTARTBYTE
						char mode - character marking start of packet

PARAMETER4:		ptr to function that tests for completeness of a packet. The
					function should return 1 if the packet is complete, or 0 if
					more data should be read in. For gap mode the test function is
					not used and should be set to NULL.

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

END DESCRIPTION **********************************************************/

nodebug int pktBopen(long baud, int mode, char options, int (*test_packet)())
{
   auto long divisor, ta1div;
	auto float baud_ratio;
	auto unsigned long t;
	auto int temp, i;

   bpkt_type = mode;
   bpkt_parity = 0;
	bpkt_txactive = 0;
	bpkt_txdone = 0;
	bpkt_waitforgap = 0;
	bpkt_longstop = 0;
	bpkt_rxgapcount = 0;
	bpkt_lastpos = 0;

	bpkt_parityerror = 0;
	bpkt_rxoverrun = 0;
	bpkt_overflow = 0;
	bpkt_nobuffer = 0;

	bpkt_rxcurrent = 0;
	bpkt_rxcurrent_ptr = bpkt_rxbuffers; //first buffer
	bpkt_rxpos = 0;
	bpkt_rxnext = 0;
	//initialize the buffers
	temp = 0;
	for(i = 0;i < bpkt_rxcount;i++)
	{
		root2xmem(bpkt_rxbuffers + i*(bpkt_rxsize + 2), &temp, 2);
	}


	bpkt_testpacket = test_packet;

   if (baud < 1) baud = 1;
   // (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"

	ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	BitWrPortI(TACR, &TACRShadow, 1, 5);
	}
	else
	{
		BitWrPortI(TACR, &TACRShadow, 0, 5);
	}
	WrPortI(TAT5R, &TAT5RShadow, (char)divisor);

	//set up mode and options
	if (mode == PKT_GAPMODE)
	{
		bpkt_rxgapsize = options;
   	bpkt_init(bpkt_gapisr);
   }
   else if (mode == PKT_9BITMODE)
   {
   	bpkt_9bittype = options;
   	bpkt_init(bpkt_9bitisr);
	}
	else
	{
		bpkt_startchar = options;
		bpkt_init(bpkt_charisr);
	}
   bpkt_divisor = (char)divisor;
   bpkt_fastdivisor = (char)divisor / 8;
   if (bpkt_fastdivisor < 1) bpkt_fastdivisor = 1;

   // let baud timer time out before using port
   t = MS_TIMER;
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   pktBinit();
   bpkt_disableport();
   return (((long)((BASEFREQ*freq_divider) /
   	(32 * (divisor + 1)) + 0.5)) == baud);    // rounded baud actually used
}

/* START FUNCTION DESCRIPTION ********************************************
pktBinitBuffers                   <PACKET.LIB>

SYNTAX:		   int pktBinitBuffers(int buf_count, int buf_size);

DESCRIPTION:   Allocates extended memory for the channel B receive buffers.
					This function should not be called more than once in a program.
					The total memory allocated is count*(size + 2) bytes

PARAMETER1:    buf_count - the number of buffers to allocate. Each buffer can
					store one received packet. Increasing this number allows for
					more pending packets and a larger latency time before packets
					must be processed by the user's program.

PARAMETER2:		buf_size - the number of bytes each buffer can accomodate. This
					should be set to the size of the largest possible packet
					that can be expected.

RETURN VALUE:	1: The xmem allocation was successful
               0: The allocation failed. This packet channel cannot be used.

END DESCRIPTION **********************************************************/

nodebug int pktBinitBuffers(int buf_count, int buf_size)
{
	bpkt_rxcount = buf_count;
	if(buf_size % 2)
	{
		buf_size++;  //make sure buffer sizes are even
	}
	bpkt_rxsize = buf_size;

	bpkt_rxbuffers = xalloc(buf_count*(buf_size+2)+2);
	if(bpkt_rxbuffers % 2)
	{
		bpkt_rxbuffers++; //make sure buffers are on even addresses
	}
	if(!bpkt_rxbuffers)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}


/* START FUNCTION DESCRIPTION ********************************************
pktBclose                   <PACKET.LIB>

SYNTAX:		   void pktBclose();

DESCRIPTION:   Disables the B serial port.

PARAMETER1:    None

RETURN VALUE:	None

END DESCRIPTION **********************************************************/


#if _USER
#asm root
pktBclosed::
	ret
#endasm
#endif

#asm root
pktBclose::
#if _USER
c	 SetVectIntern(SERB_OFS/0x10, pktBclosed);
#else
	 ld	 a,0xc9         ; ret in first byte
	 ipset 1
	 ld	 (INTVEC_BASE + SERB_OFS),a
#endif

	 ld	 a, 0x00
;ioi ld	 (SBCR),a
	IOWRITE_A(SBCR)
	 ipres
	 ret

;
; bpkt_init
;

bpkt_init::
#if _USER
	push	hl
   ld		hl,SERB_OFS/0x10
   push	hl
   call  SetVectIntern
   add	sp,2
#else
	 ld	 iy, INTVEC_BASE + SERB_OFS
	 ipset 1
	 ld	 (iy), 0C3h			; the JP command
	 ld	 (iy+1), hl			; ISR for a particular mode
#endif

	 call	 bpkt_isr_disableport

#ifdef PKTB_USEPORTD
	 ld	 a, (PDDDRShadow)
	 or	 BDRIVE_TXMASK			;make port D pin an output
	 ld	 (PDDDRShadow), a
;ioi ld	 (PDDDR), a
	IOWRITE_A(PDDDR)
	 ld	 a, 0x11			;enable interrupt and alternate input pin
#else
	 ld	 a,0x01			; enable interrupts for port
#endif
;ioi ld	 (SBCR),a
	IOWRITE_A(SBCR)
	 ipres
	 ret

bpkt_isr_enableport::
#ifdef PKTB_USEPORTD
    ld	 a,(PDFRShadow)
    or	 BDRIVE_TXMASK              ; enable serial port B transmitter
    ld	 (PDFRShadow),a
;ioi ld	 (PDFR),a
	IOWRITE_A(PDFR)
#else
    ld	 a,(PCFRShadow)
    or	 BDRIVE_TXMASK              ; enable serial port B transmitter
    ld	 (PCFRShadow),a
;ioi ld	 (PCFR),a
	IOWRITE_A(PCFR)
#endif
	 call  pktBtx			;user defined asm routine
	 ld	 a, 0x01
	 ld	 (bpkt_portenabled), a
	 ret

bpkt_enableport::
	 ipset 1
	 call	 bpkt_isr_enableport
	 ipres
	 ret

bpkt_isr_disableport::
	 call	 bpkt_disabledrive
	 call  pktBrx		;user defined asm routine
	 ret

bpkt_disableport::
	 ipset 1
	 call bpkt_isr_disableport
	 ipres
	 ret

bpkt_disabledrive::		;seperate call for longstops
#ifdef PKTB_USEPORTD
	 ld	 a, (PDDRShadow)
	 or	 BDRIVE_TXMASK
	 ld	 (PDDRShadow), a
;ioi ld	 (PDDR), a
	IOWRITE_A(PDDR)
    ld	 a,(PDFRShadow)
    and	 ~BDRIVE_TXMASK              ; disable serial port D transmitter
    ld	 (PDFRShadow),a
;ioi ld	 (PDFR),a
	IOWRITE_A(PDFR)
#else
	 ld	 a, (PCDRShadow)
	 or	 BDRIVE_TXMASK
	 ld	 (PCDRShadow), a
;ioi ld	 (PCDR), a
	IOWRITE_A(PCDR)
    ld	 a,(PCFRShadow)
    and	 ~BDRIVE_TXMASK              ; disable serial port D transmitter
    ld	 (PCFRShadow),a
;ioi ld	 (PCFR),a
	IOWRITE_A(PCFR)
#endif
	 xor	 a
	 ld	 (bpkt_portenabled), a
	 ret

#endasm

#asm root

bpkt_sendbyte::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (bpkt_txcount)
	 ld	 hl, (bpkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (bpkt_txcount)
	 ld	 hl, (bpkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (bpkt_txcount), de	;increment txcount
	 ld	 a, (bpkt_parity)
	 or	 a
	 jr	 z, .send8bit
	 dec	 a
	 jr	 z, .sendodd
	 dec	 a
	 jr	 z, .sendeven
	 jr	 .send9high		;2 stop bits, 9th bit always high

.sendeven:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity		;returns true if odd
	 bool	 hl
	 jr	 nz, .send9low		;byte is already even parity
	 jr	 .send9high
.sendodd:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .send9low	;byte is already odd parity
	 jr	 .send9high
.send8bit:
	 ld	 a, c
;ioi ld	 (SBDR), a
	IOWRITE_A(SBDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SBAR), a
	IOWRITE_A(SBAR)
	 jr	 .sendexit
#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
.send9high:
	 ld	 a, c
;ioi ld	 (SBLR), a
	IOWRITE_A(SBLR)
	 jr	 .sendexit
#else
.send9high:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, .send9longstop
	 ld	 a, c
;ioi ld	 (SBLR), a
	IOWRITE_A(SBLR)
	 jr	 .sendexit
.send9longstop:
	 ld	 a, 0x01
	 ld	 (bpkt_longstop), a
	 jr	 .send8bit
#endif
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

bpkt_send9bit::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (bpkt_txcount)
	 ld	 hl, (bpkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (bpkt_txcount)
	 ld	 hl, (bpkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (bpkt_txcount), de	;increment txcount

	 ld	 a, (bpkt_9bittype)
	 or	 a
	 jr	 z, .rabbitstart
	 dec	 a
	 jr	 z, .lowstart
.highstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9high
	 jr	 .send9low
.lowstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low	;if de <= 1
	 jr	 .send9high
.rabbitstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low
.send8bit:
	 ld	 a, c
;ioi ld	 (SBDR), a
	IOWRITE_A(SBDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SBAR), a
	IOWRITE_A(SBAR)
	 jr	 .sendexit
#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
.send9high:
	 ld	 a, c
;ioi ld	 (SBLR), a
	IOWRITE_A(SBLR)
	 jr	 .sendexit
#else
.send9high:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, .send9longstop
	 ld	 a, c
;ioi ld	 (SBLR), a
	IOWRITE_A(SBLR)
	 jr	 .sendexit
.send9longstop:
	 ld	 a, 0x01
	 ld	 (bpkt_longstop), a
	 jr	 .send8bit
#endif
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

; assumes byte is stored in B, can trash other registers
bpkt_recvbyte::

	 push	 ix
	 ld	 ix, (bpkt_rxcurrent_ptr)
	 ld	 a, (bpkt_rxcurrent_ptr + 2)
	 ldp	 hl, (ix)		;get length field
	 bool	 hl
	 jr	 nz, .no_buffer		;buffer is full
	 ld	 de, 2
	 add	 ix, de
	 adc	 a, 0					;carry if needed
	 ld	 de, (bpkt_rxpos)
	 add	 ix, de
	 adc	 a, 0					;carry add into high bit
	 ldp	 hl, (ix)
	 ld	 L, b					;from ISR, b holds received byte
	 ldp	 (ix), hl
	 inc	 de					;de still holds rxpos
	 ld	 hl, (bpkt_rxsize)
	 or	 a						;clear carry
	 sbc	 hl, de
	 jr	 z, .buffer_overflow
	 ld	 (bpkt_rxpos), de
	 jr	 .recvdone

.no_buffer:
	 ld	 a, 0x01
	 ld	 (bpkt_nobuffer), a
	 jr	 .recvdone

.buffer_overflow:
	 ld	 a, 0x01
	 ld	 (bpkt_overflow), a
	 ld	 hl, 0
	 ld	 (bpkt_rxpos), hl		;set pos to beginning of buffer
.recvdone:
	 pop	 ix
	 ret

#endasm

#asm root

bpkt_finish::
	 push	 bc
	 push	 ix
	 ld	 hl, (bpkt_rxpos)
	 bool	 hl
	 jr	 z, .done		;no packet
	 ld	 ix, (bpkt_rxcurrent_ptr)
	 ld	 a, (bpkt_rxcurrent_ptr + 2)
	 ld	 hl, (bpkt_rxpos)		;load length into buffer
	 ldp	 (ix), hl
	 ld	 de, (bpkt_rxcurrent)
	 inc	 de
	 ld	 hl, (bpkt_rxcount)
	 or	 a		;clear carry
	 sbc	 hl, de
	 jr	 nz, .newbuffer
	 ld	 d, 0
	 ld	 e, 0					;zero out current buffer number
.newbuffer:
	 ld	 (bpkt_rxcurrent), de
	 ld	 hl, (bpkt_rxsize)
	 inc	 hl
	 inc	 hl					;add 2 to size for total buffer size
	 ld	 c, L
	 ld	 b, h
	 mul							;current * (size+2)
	 ld	 e, L					;high byte of result now in e
	 ld	 hl, (bpkt_rxbuffers)		;base of buffer array
	 ld	 a, (bpkt_rxbuffers + 2)
	 add	 hl, bc
	 adc	 a, e
	 ld	 (bpkt_rxcurrent_ptr), hl	;set new current ptr
	 ld	 (bpkt_rxcurrent_ptr + 2), a
	 bool	 hl
	 ld	 L, 0
	 ld	 (bpkt_rxpos), hl			;zero out position
.done:
	 pop	 ix
	 pop	 bc
	 ret

#endasm

#asm root

bpkt_nextdone::
	 ipset 1
	 ld	 hl, (bpkt_rxnext)
	 ld	 de, (bpkt_rxcurrent)
	 or	 a
	 sbc	 hl, de
	 jr	 nz, .done
	 call	 bpkt_finish			;complete current packet
.done:
	 ipres
	 ret

#endasm

#asm root

;assumes byte is in B, SDSR snapshot is in C
bpkt_paritytest::
	 ld	 a, (bpkt_parity)
	 dec	 a
	 or	 a
	 jr	 z, .oddparity
.evenparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	hl
	 jr	 z, .check9high
	 jr	 .check9low

.oddparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .check9low
.check9high:
	 bit	 6, c
	 jr	 z, .paritydone
	 jr	 .setparityerror

.check9low:
	 bit	 6, c
	 jr	 nz, .paritydone
.setparityerror:
	 ld	 a, 0x01
	 ld	 (bpkt_parityerror), a
.paritydone:
	 ret

#endasm

#asm root

bpkt_gapisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SBSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SBSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SBSR), a			;clear interrupt
	IOWRITE_A(SBSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (bpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (bpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 bpkt_sendbyte		;try and send another byte,
	 									; with possible parity bit
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
										;handle gaps, transitions, etc.
	 ld	 a, (bpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (bpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT5R),a
	IOWRITE_A(TAT5R)

	 ld	 a, (bpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 ;decide if we need to send a gap or data???
	 ld	 a, (bpkt_txactive)	;are we transmitting?
	 or	 a
	 jr	 z, .isr_rxdummy		;dummy is for rx gap timing
	 ld	 a, (bpkt_txdelay)
	 or	 a
	 jr	 nz, .isr_txdummy
	 call	 bpkt_isr_enableport		;make sure we can send data
	 call	 bpkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (bpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 bpkt_isr_disableport
;ioi ld	 (SBDR), a				;load final dummy
	IOWRITE_A(SBDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:							;moved up to keep jump in range
;ioi ld	 a, (SBDR)			;read byte, clear interrupt
	IOREAD_A(SBDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (bpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT5R),a
	IOWRITE_A(TAT5R)
	 call	 bpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (bpkt_longstop), a			;clear out long stop flag
	 call  bpkt_isr_disableport
;ioi ld	 (SBDR), a						;do a fast dummy
	IOWRITE_A(SBDR)
	 jr	 .isr_txdone

.isr_txdummy:						;dummy for tx delay
	 dec	 a
	 ld	 (bpkt_txdelay), a
	 call	 bpkt_isr_disableport
;ioi ld	 (SBDR), a				;load dummy
	IOWRITE_A(SBDR)
	 jr	 .isr_txdone

.isr_rxdummy:
	 ld	 a, (bpkt_rxgapcount)
	 or	 a
	 jr	 z, .isr_rxendpacket		;a full gap was detected
	 dec	 a
	 ld	 (bpkt_rxgapcount), a
;ioi ld	 (SBDR), a					;load dummy
	IOWRITE_A(SBDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (bpkt_txdone), a
	 ld	 (bpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxendpacket:
	 call	 bpkt_finish
	 jr	 .isr_txdone


.isr_rxchecktx:
	 ld	 a, (bpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcheckparity
	 ld	 a, 0x01
	 ld	 (bpkt_rxoverrun), a
.isr_rxcheckparity:
	 ld	 a, (bpkt_parity)
	 or	 a
	 jr	 z, .isr_rxcontinue		;next step
	 call  bpkt_paritytest

.isr_rxcontinue:					;no defined start byte, just load it
	 ld	 a, (bpkt_waitforgap)
	 or	 a
	 jr	 nz, .isr_rxresetgap		;waiting for a gap
	 call	 bpkt_recvbyte
.isr_rxresetgap:
	 ld	 a, (bpkt_rxgapsize)
	 ld	 (bpkt_rxgapcount), a	;reset the gap counter
;ioi ld	 (SBDR), a					;send dummy byte for gap timing
	IOWRITE_A(SBDR)
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

bpkt_9bitisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SBSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SBSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SBSR), a			;clear interrupt
	IOWRITE_A(SBSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (bpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (bpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 bpkt_send9bit			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (bpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (bpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT5R),a
	IOWRITE_A(TAT5R)

	 ld	 a, (bpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 bpkt_isr_enableport		;make sure we can send data
	 call	 bpkt_send9bit			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (bpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 bpkt_isr_disableport
;ioi ld	 (SBDR), a				;load final dummy
	IOWRITE_A(SBDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SBDR)			;read byte, clear interrupt
	IOREAD_A(SBDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (bpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT5R),a
	IOWRITE_A(TAT5R)
	 call	 bpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (bpkt_longstop), a			;clear out long stop flag
	 call  bpkt_isr_disableport
;ioi ld	 (SBDR), a						;do a fast dummy
	IOWRITE_A(SBDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (bpkt_txdone), a
	 ld	 (bpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (bpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (bpkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (bpkt_9bittype)
	 or	 a							;zero test A
	 jr	 z, .isr_rxchecklowstart
	 dec	 a
	 jr	 z, .isr_rxchecklowstart
.isr_rxcheckhighstart:
	 bit	 6, c
	 jr	 z, .isr_rxstart
	 jr	 .isr_rxnotstart
.isr_rxchecklowstart:
	 bit	 6, c
	 jr	 nz, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (bpkt_rxpos)
	 bool	 hl
	 jr	 nz, .isr_rxload		;we are in the middle of a packet
	 jr	 .isr_rxdone
.isr_rxload:
	 call	 bpkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call	 bpkt_finish
	 call	 bpkt_recvbyte

.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

bpkt_charisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SBSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SBSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SBSR), a			;clear interrupt
	IOWRITE_A(SBSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (bpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (bpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 bpkt_sendbyte			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (bpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (bpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT5R),a
	IOWRITE_A(TAT5R)

	 ld	 a, (bpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 bpkt_isr_enableport		;make sure we can send data
	 call	 bpkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (bpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 bpkt_isr_disableport
;ioi ld	 (SBDR), a				;load final dummy
	IOWRITE_A(SBDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SBDR)			;read byte, clear interrupt
	IOREAD_A(SBDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (bpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT5R),a
	IOWRITE_A(TAT5R)
	 call	 bpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (bpkt_longstop), a			;clear out long stop flag
	 call  bpkt_isr_disableport
;ioi ld	 (SBDR), a						;do a fast dummy
	IOWRITE_A(SBDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (bpkt_txdone), a
	 ld	 (bpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (bpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (bpkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (bpkt_startchar)
	 cp	 b
	 jr	 z, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (bpkt_rxpos)
	 bool	 hl
	 jr	 z, .isr_rxdone		;keep waiting for a start byte
.isr_rxload:
	 call	 bpkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call bpkt_finish
	 call	bpkt_recvbyte
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

/*** BeginHeader pktBsetParity */
void pktBsetParity(char mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktBsetParity                   <PACKET.LIB>

SYNTAX:		   void pktBsetParity(char mode);

DESCRIPTION:   Configures parity generation and checking
					Can also configure for 2 stop bits.

PARAMETER1:		Code for mode of parity bit
					PKT_NOPARITY - no parity bit (8N1 format, default)
					PKT_OPARITY 1 - odd parity (8O1 format)
					PKT_EPARITY 2 - even parity (8E1 format)
					PKT_TWOSTOP 3 - an extra stop bit (8N2 format)

END DESCRIPTION **********************************************************/

nodebug void pktBsetParity(char mode)
{
	bpkt_parity = mode;
}

/*** BeginHeader pktBsending */
int pktBsending();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktBsending                   <PACKET.LIB>

SYNTAX:		   int pktBsending();

DESCRIPTION:   Tests if a packet is currently being sent. If this returns
					true, the transmitter is bus and cannot accept another packet.

RETURN VALUE:	1: A packet is being transmitted on port B
               0: port B is idle, ready for a new packet

END DESCRIPTION **********************************************************/

nodebug int pktBsending()
{
	return (int)bpkt_txactive;
}

/*** BeginHeader pktBsend */
int pktBsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktBsend                   <PACKET.LIB>

SYNTAX:		   int pktBsend(void *send_buffer,
									 int buffer_length,
									 char delay);

DESCRIPTION:   Initiates the sending of a packet of data. This function will
					always return immediately. If there is already a packet being
					transmitted, this call will return 0 and the packet will not be
					transmitted, otherwise it will return 1.
					The pktBsending() function is used to check
					if the packet is done transmitting. The system will be using the
					buffer until then.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

RETURN VALUE:	1 if the packet is goint to be transmitted
					0 if there is already a packet transmitting, and the new packet
						was refused.

END DESCRIPTION **********************************************************/

nodebug int pktBsend(void *send_buffer, int buffer_length, char delay)
{
	//loop until tx is ready
	if (pktBsending())
	{
		return 0;
	}
	else
	{
		bpkt_txframe = send_buffer;
		bpkt_txsize = buffer_length;
		bpkt_txcount = 0;
		bpkt_txdelay = delay;
		bpkt_txactive = 1;				//set active flag
		if(delay)
		{
			bpkt_disableport();
			WrPortI(SBDR, NULL, 23);		//send a dummy character to start
		}
		else
		{
			bpkt_enableport();
			if(bpkt_type == PKT_9BITMODE)
			{
				bpkt_send9bit();
			}
			else
			{
				bpkt_sendbyte();
			}
		}
		return 1;
	}
}

/*** BeginHeader cof_pktBsend */
scofunc void cof_pktBsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktBsend                   <PACKET.LIB>

SYNTAX:		   void cof_pktBsend(void *send_buffer,
									  		int buffer_length,
									  		char delay);

DESCRIPTION:   Cofunction version of pktBsend(). This function will yield
					to other tasks while the packet is being sent. It differs from
					pktBsend() in that it will not return until the packet is
					done transmitting.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_pktBsend(void *send_buffer,
											 int buffer_length,
											 char delay)
{
	//wait until tx is ready
	while (pktBsending()) yield;

	bpkt_txframe = send_buffer;
	bpkt_txsize = buffer_length;
	bpkt_txcount = 0;
	bpkt_txdelay = delay;
	bpkt_txactive = 1;				//set active flag
	if(delay)
	{
		bpkt_disableport();
		WrPortI(SBDR, NULL, 23);		//send a dummy character to start
	}
	else
	{
		bpkt_enableport();
		if(bpkt_type == PKT_9BITMODE)
		{
			bpkt_send9bit();
		}
		else
		{
			bpkt_sendbyte();
		}
	}
	while (pktBsending()) yield;	//wait for this packet to finish
}

/*** BeginHeader pktBreceive */
int pktBreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktBreceive                   <PACKET.LIB>

SYNTAX:		   int pktBreceive(void *buffer, int buffer_size);

DESCRIPTION:   Gets a received packet if there is one in the packet buffer.
					Otherwise, it will immediately return 0.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE: >0: The number of bytes in the received packet.
				  0: indicates that no new packets have been received.
				  -1: indicates that the packet is too large for the given buffer
				  -2: if a needed test_packet function is not defined

END DESCRIPTION **********************************************************/

nodebug int pktBreceive(void *buffer, int buffer_size)
{
	auto int rxpos;
	auto int packet_length;
	auto int buffer_offset;
	auto int temp;

	rxpos = bpkt_rxpos;
	buffer_offset = bpkt_rxnext*(bpkt_rxsize+2);
	xmem2root(&packet_length, bpkt_rxbuffers + buffer_offset, 2);
	if(packet_length)
	{
		//packet is definitely done
		if(packet_length <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, bpkt_rxbuffers + buffer_offset + 2, packet_length);
			temp = 0;
			root2xmem(bpkt_rxbuffers + buffer_offset, &temp, 2); //clear out
			bpkt_rxnext = (bpkt_rxnext + 1) % bpkt_rxcount;
			bpkt_lastpos = 0;
			return packet_length;
		}
		else
		{
			return -1;
		}
	}
	else if(bpkt_type != PKT_GAPMODE && rxpos != bpkt_lastpos)
	{
		if (bpkt_testpacket == NULL)
		{
			return -2;
		}
		//check for complete packet
		if(rxpos <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, bpkt_rxbuffers + buffer_offset + 2, rxpos);
			if ( (*bpkt_testpacket)(buffer, rxpos) )
			{
				bpkt_nextdone(); //complete packet
				temp = 0;
				root2xmem(bpkt_rxbuffers + buffer_offset, &temp, 2); //clear out
				bpkt_rxnext = (bpkt_rxnext + 1) % bpkt_rxcount;
				bpkt_lastpos = 0;
				return rxpos;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return 0;
	}
}

/*** BeginHeader cof_pktBreceive */
scofunc int cof_pktBreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktBreceive                   <PACKET.LIB>

SYNTAX:		   int cof_pktBreceive(void *buffer, int buffer_size);

DESCRIPTION:   This cofunction is used to listen for received packets.
					It will return with a packet immediately if there is one in
					in the buffer. Otherwise, it will wait for one while yielding
					to other tasks.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE:	The length of the received packet or an error code
					identical to those in pktBreceive()

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_pktBreceive(void *buffer, int buffer_size)
{
	auto int length;
	while((length = pktBreceive(buffer, buffer_size)) == 0)
	{
		yield;
	}
	return length;
}


/*** BeginHeader pktBgetErrors */
char pktBgetErrors();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktBgetErrors                   <PACKET.LIB>

SYNTAX:		   char pktBgetErrors();

DESCRIPTION:   Gets a bit field with flags set for any errors that occured.
					These flags are then cleared, so that a particular error
					will only cause the flag to be set once.

RETURN VALUE:	A bit field with flags for various errors. The errors
					along with their bit masks are as follows:
						PKT_BUFFEROVERFLOW 0x01
						PKT_RXOVERRUN 0x02
						PKT_PARITYERROR 0x04
						PKT_NOBUFFER 0x08

END DESCRIPTION **********************************************************/

nodebug char pktBgetErrors()
{
	auto char error_flags;

	error_flags = 0;
	if (bpkt_overflow) {
		error_flags |= PKT_BUFFEROVERFLOW;
		bpkt_overflow = 0;		//clear the error after reporting it
	}
	if (bpkt_rxoverrun) {
		error_flags |= PKT_RXOVERRUN;
		bpkt_rxoverrun = 0;
	}
	if (bpkt_parityerror) {
		error_flags |= PKT_PARITYERROR;
		bpkt_parityerror = 0;
	}
	if (bpkt_nobuffer) {
		error_flags |= PKT_NOBUFFER;
		bpkt_nobuffer = 0;
	}


	return error_flags;
}


//************************************************************************
//****************************** PORT C **********************************
//************************************************************************


/*** Beginheader pktCopen, pktCclose, pktCinitBuffers, cpkt_nextdone */
int pktCopen(long baud, int mode, char options, int (*test_packet)());
root void pktCclose();
int pktCinitBuffers(int buf_count, int buf_size);
void cpkt_nextdone();

int cpkt_sendbyte();
void cpkt_enableport();
void cpkt_disableport();

extern unsigned long cpkt_rxbuffers;
extern int cpkt_rxcount;
extern int cpkt_rxsize;
extern int cpkt_rxpos;
extern int cpkt_rxnext;		//next buffer to be read out
extern int cpkt_rxcurrent;	//buffer being written to
extern unsigned long cpkt_rxcurrent_ptr; //temp pointer to start of current buffer

extern int cpkt_lastpos;
extern char *cpkt_txframe;
extern int cpkt_txcount;
extern int cpkt_txsize;
extern char cpkt_type;
extern char cpkt_parity;
extern char cpkt_rxgapcount;
extern char cpkt_rxgapsize;
extern char cpkt_txdelay;
extern char cpkt_startchar;
extern char cpkt_txdone;
extern char cpkt_9bittype;
extern char cpkt_divisor;
extern char cpkt_fastdivisor;
extern char cpkt_longstop;
extern char cpkt_portenabled;
//pointer to function that tests for complete packets
extern int (*cpkt_testpacket)(); //takes (void *, int) as args
extern char cpkt_txactive;
extern char cpkt_waitforgap;

//errors
extern char cpkt_parityerror;
extern char cpkt_rxoverrun;
extern char cpkt_overflow;
extern char cpkt_nobuffer;

/*** endheader */

unsigned long cpkt_rxbuffers;
int cpkt_rxcount;
int cpkt_rxsize;
int cpkt_rxpos;
int cpkt_rxnext;		//next buffer to be read out
int cpkt_rxcurrent;	//buffer being written to
unsigned long cpkt_rxcurrent_ptr; //temp pointer to start of current buffer

int cpkt_lastpos;
char *cpkt_txframe;
int cpkt_txcount;
int cpkt_txsize;
char cpkt_type;
char cpkt_parity;
char cpkt_rxgapcount;
char cpkt_rxgapsize;
char cpkt_txdelay;
char cpkt_startchar;
char cpkt_txdone;
char cpkt_9bittype;
char cpkt_divisor;
char cpkt_fastdivisor;
char cpkt_longstop;
char cpkt_portenabled;
//pointer to function that tests for complete packets
int (*cpkt_testpacket)(); //takes (void *, int) as args
char cpkt_txactive;
char cpkt_waitforgap;

//errors
char cpkt_parityerror;
char cpkt_rxoverrun;
char cpkt_overflow;
char cpkt_nobuffer;

extern void pktCinit();
extern void pktCrx();
extern void pktCtx();

#define CDRIVE_TXMASK 0x04


//internal functions
void cpkt_init( void (*isr)() );
void cpkt_gapisr();
void cpkt_9bitisr();
void cpkt_charisr();

/* START FUNCTION DESCRIPTION ********************************************
pktCopen                   <PACKET.LIB>

SYNTAX:		   int pktCopen(long baud,
									 int mode,
									 char options,
									 int (*test_packet)() );

DESCRIPTION:   Opens the C serial port.

PARAMETER1:    Bits per second of data transfer: min 2400

PARAMETER2:		mode - type of packet scheme used, options are:
						PKT_GAPMODE
						PKT_9BITMODE
						PKT_CHARMODE

PARAMETER3:		options - further specification for the packet scheme
						The value of this depends on the mode used.
						gap mode - minimum gap size(in byte times)
						9bit mode - type of 9bit protocol
							PKT_RABBITSTARTBYTE
							PKT_LOWSTARTBYTE
							PKT_HIGHSTARTBYTE
						char mode - character marking start of packet

PARAMETER4:		ptr to function that tests for completeness of a packet. The
					function should return 1 if the packet is complete, or 0 if
					more data should be read in. For gap mode the test function is
					not used and should be set to NULL.

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

END DESCRIPTION **********************************************************/

nodebug int pktCopen(long baud, int mode, char options, int (*test_packet)())
{
   auto long divisor, ta1div;
	auto float baud_ratio;
	auto unsigned long t;
	auto int temp, i;

   cpkt_type = mode;
   cpkt_parity = 0;
	cpkt_txactive = 0;
	cpkt_txdone = 0;
	cpkt_waitforgap = 0;
	cpkt_longstop = 0;
	cpkt_rxgapcount = 0;
	cpkt_lastpos = 0;

	cpkt_parityerror = 0;
	cpkt_rxoverrun = 0;
	cpkt_overflow = 0;
	cpkt_nobuffer = 0;

	cpkt_rxcurrent = 0;
	cpkt_rxcurrent_ptr = cpkt_rxbuffers; //first buffer
	cpkt_rxpos = 0;
	cpkt_rxnext = 0;
	//initialize the buffers
	temp = 0;
	for(i = 0;i < cpkt_rxcount;i++)
	{
		root2xmem(cpkt_rxbuffers + i*(cpkt_rxsize + 2), &temp, 2);
	}


	cpkt_testpacket = test_packet;

   if (baud < 1) baud = 1;
   // (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"

	ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	BitWrPortI(TACR, &TACRShadow, 1, 6);
	}
	else
	{
		BitWrPortI(TACR, &TACRShadow, 0, 6);
	}
	WrPortI(TAT6R, &TAT6RShadow, (char)divisor);

	//set up mode and options
	if (mode == PKT_GAPMODE)
	{
		cpkt_rxgapsize = options;
   	cpkt_init(cpkt_gapisr);
   }
   else if (mode == PKT_9BITMODE)
   {
   	cpkt_9bittype = options;
   	cpkt_init(cpkt_9bitisr);
	}
	else
	{
		cpkt_startchar = options;
		cpkt_init(cpkt_charisr);
	}
   cpkt_divisor = (char)divisor;
   cpkt_fastdivisor = (char)divisor / 8;
   if (cpkt_fastdivisor < 1) cpkt_fastdivisor = 1;

   // let baud timer time out before using port
   t = MS_TIMER;
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   pktCinit();
   cpkt_disableport();
   return (((long)((BASEFREQ*freq_divider) /
   	(32 * (divisor + 1)) + 0.5)) == baud);    // rounded baud actually used
}

/* START FUNCTION DESCRIPTION ********************************************
pktCinitBuffers                   <PACKET.LIB>

SYNTAX:		   int pktCinitBuffers(int buf_count, int buf_size);

DESCRIPTION:   Allocates extended memory for the channel C receive buffers.
					This function should not be called more than once in a program.
					The total memory allocated is count*(size + 2) bytes

PARAMETER1:    buf_count - the number of buffers to allocate. Each buffer can
					store one received packet. Increasing this number allows for
					more pending packets and a larger latency time before packets
					must be processed by the user's program.

PARAMETER2:		buf_size - the number of bytes each buffer can accomodate. This
					should be set to the size of the largest possible packet
					that can be expected.

RETURN VALUE:	1: The xmem allocation was successful
               0: The allocation failed. This packet channel cannot be used.

END DESCRIPTION **********************************************************/

nodebug int pktCinitBuffers(int buf_count, int buf_size)
{
	cpkt_rxcount = buf_count;
	if(buf_size % 2)
	{
		buf_size++;   //make sure buffer sizes are even
	}
	cpkt_rxsize = buf_size;
	cpkt_rxbuffers = xalloc(buf_count*(buf_size+2)+2);
	if(cpkt_rxbuffers % 2)
	{
		cpkt_rxbuffers++;		//make sure buffers start on even boundaries
	}

	if(!cpkt_rxbuffers)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}


/* START FUNCTION DESCRIPTION ********************************************
pktCclose                   <PACKET.LIB>

SYNTAX:		   void pktCclose();

DESCRIPTION:   Disables the C serial port.

PARAMETER1:    None

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

#if _USER
#asm root
pktCclosed::
	ret
#endasm
#endif

#asm root
pktCclose::
#if _USER
c	 SetVectIntern(SERC_OFS/0x10, pktCclosed);
#else
	 ld	 a,0xc9         ; ret in first byte
	 ipset 1
	 ld	 (INTVEC_BASE + SERC_OFS),a
#endif

	 ld	 a, 0x00
;ioi ld	 (SCCR),a
	IOWRITE_A(SCCR)
	 ipres
	 ret

;
; cpkt_init
;

cpkt_init::
#if _USER
	push	hl
   ld		hl,SERC_OFS/0x10
   push	hl
   call  SetVectIntern
   add	sp,2
#else
	 ld	 iy, INTVEC_BASE + SERC_OFS
	 ipset 1
	 ld	 (iy), 0C3h			; the JP command
	 ld	 (iy+1), hl			; ISR for a particular mode
#endif

	 call	 cpkt_isr_disableport

	 ld	 a,0x01			; enable interrupts for port
;ioi ld	 (SCCR),a
	IOWRITE_A(SCCR)
	 ipres
	 ret

cpkt_isr_enableport::
    ld	 a,(PCFRShadow)
    or	 CDRIVE_TXMASK              ; enable serial port C transmitter
    ld	 (PCFRShadow),a
;ioi ld	 (PCFR),a
	IOWRITE_A(PCFR)
	 call  pktCtx			;user defined asm routine
	 ld	 a, 0x01
	 ld	 (cpkt_portenabled), a
	 ret

cpkt_enableport::
	 ipset 1
	 call	 cpkt_isr_enableport
	 ipres
	 ret

cpkt_isr_disableport::
	 call	 cpkt_disabledrive
	 call  pktCrx		;user defined asm routine
	 ret

cpkt_disableport::
	 ipset 1
	 call cpkt_isr_disableport
	 ipres
	 ret

cpkt_disabledrive::		;seperate call for longstops
	 ld	 a, (PCDRShadow)
	 or	 CDRIVE_TXMASK
	 ld	 (PCDRShadow), a
;ioi ld	 (PCDR), a
	IOWRITE_A(PCDR)
    ld	 a,(PCFRShadow)
    and	 ~CDRIVE_TXMASK              ; disable serial port D transmitter
    ld	 (PCFRShadow),a
;ioi ld	 (PCFR),a
	IOWRITE_A(PCFR)
	 xor	 a
	 ld	 (cpkt_portenabled), a
	 ret

#endasm

#asm root

cpkt_sendbyte::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (cpkt_txcount)
	 ld	 hl, (cpkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (cpkt_txcount)
	 ld	 hl, (cpkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (cpkt_txcount), de	;increment txcount
	 ld	 a, (cpkt_parity)
	 or	 a
	 jr	 z, .send8bit
	 dec	 a
	 jr	 z, .sendodd
	 dec	 a
	 jr	 z, .sendeven
	 jr	 .send9high		;2 stop bits, 9th bit always high

.sendeven:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity		;returns true if odd
	 bool	 hl
	 jr	 nz, .send9low		;byte is already even parity
	 jr	 .send9high
.sendodd:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .send9low	;byte is already odd parity
	 jr	 .send9high
.send8bit:
	 ld	 a, c
;ioi ld	 (SCDR), a
	IOWRITE_A(SCDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SCAR), a
	IOWRITE_A(SCAR)
	 jr	 .sendexit
#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
.send9high:
	 ld	 a, c
;ioi ld	 (SCLR), a
	IOWRITE_A(SCLR)
	 jr	 .sendexit
#else
.send9high:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, .send9longstop
	 ld	 a, c
;ioi ld	 (SCLR), a
	IOWRITE_A(SCLR)
	 jr	 .sendexit
.send9longstop:
	 ld	 a, 0x01
	 ld	 (cpkt_longstop), a
	 jr	 .send8bit
#endif
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

cpkt_send9bit::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (cpkt_txcount)
	 ld	 hl, (cpkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (cpkt_txcount)
	 ld	 hl, (cpkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (cpkt_txcount), de	;increment txcount

	 ld	 a, (cpkt_9bittype)
	 or	 a
	 jr	 z, .rabbitstart
	 dec	 a
	 jr	 z, .lowstart
.highstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9high
	 jr	 .send9low
.lowstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low	;if de <= 1
	 jr	 .send9high
.rabbitstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low
.send8bit:
	 ld	 a, c
;ioi ld	 (SCDR), a
	IOWRITE_A(SCDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SCAR), a
	IOWRITE_A(SCAR)
	 jr	 .sendexit
#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
.send9high:
	 ld	 a, c
;ioi ld	 (SCLR), a
	IOWRITE_A(SCLR)
	 jr	 .sendexit
#else
.send9high:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, .send9longstop
	 ld	 a, c
;ioi ld	 (SCLR), a
	IOWRITE_A(SCLR)
	 jr	 .sendexit
.send9longstop:
	 ld	 a, 0x01
	 ld	 (cpkt_longstop), a
	 jr	 .send8bit
#endif
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

; assumes byte is stored in B, can trash other registers
cpkt_recvbyte::

	 push	 ix
	 ld	 ix, (cpkt_rxcurrent_ptr)
	 ld	 a, (cpkt_rxcurrent_ptr + 2)
	 ldp	 hl, (ix)		;get length field
	 bool	 hl
	 jr	 nz, .no_buffer		;buffer is full
	 ld	 de, 2
	 add	 ix, de
	 adc	 a, 0					;carry if needed
	 ld	 de, (cpkt_rxpos)
	 add	 ix, de
	 adc	 a, 0					;carry add into high bit
	 ldp	 hl, (ix)
	 ld	 L, b					;from ISR, b holds received byte
	 ldp	 (ix), hl
	 inc	 de					;de still holds rxpos
	 ld	 hl, (cpkt_rxsize)
	 or	 a						;clear carry
	 sbc	 hl, de
	 jr	 z, .buffer_overflow
	 ld	 (cpkt_rxpos), de
	 jr	 .recvdone

.no_buffer:
	 ld	 a, 0x01
	 ld	 (cpkt_nobuffer), a
	 jr	 .recvdone

.buffer_overflow:
	 ld	 a, 0x01
	 ld	 (cpkt_overflow), a
	 ld	 hl, 0
	 ld	 (cpkt_rxpos), hl		;set pos to beginning of buffer
.recvdone:
	 pop	 ix
	 ret

#endasm

#asm root

cpkt_finish::
	 push	 bc
	 push	 ix
	 ld	 hl, (cpkt_rxpos)
	 bool	 hl
	 jr	 z, .done		;no packet
	 ld	 ix, (cpkt_rxcurrent_ptr)
	 ld	 a, (cpkt_rxcurrent_ptr + 2)
	 ld	 hl, (cpkt_rxpos)		;load length into buffer
	 ldp	 (ix), hl
	 ld	 de, (cpkt_rxcurrent)
	 inc	 de
	 ld	 hl, (cpkt_rxcount)
	 or	 a		;clear carry
	 sbc	 hl, de
	 jr	 nz, .newbuffer
	 ld	 d, 0
	 ld	 e, 0					;zero out current buffer number
.newbuffer:
	 ld	 (cpkt_rxcurrent), de
	 ld	 hl, (cpkt_rxsize)
	 inc	 hl
	 inc	 hl					;add 2 to size for total buffer size
	 ld	 c, L
	 ld	 b, h
	 mul							;current * (size+2)
	 ld	 e, L					;high byte of result now in e
	 ld	 hl, (cpkt_rxbuffers)		;base of buffer array
	 ld	 a, (cpkt_rxbuffers + 2)
	 add	 hl, bc
	 adc	 a, e
	 ld	 (cpkt_rxcurrent_ptr), hl	;set new current ptr
	 ld	 (cpkt_rxcurrent_ptr + 2), a
	 bool	 hl
	 ld	 L, 0
	 ld	 (cpkt_rxpos), hl			;zero out position
.done:
	 pop	 ix
	 pop	 bc
	 ret

#endasm

#asm root

cpkt_nextdone::
	 ipset 1
	 ld	 hl, (cpkt_rxnext)
	 ld	 de, (cpkt_rxcurrent)
	 or	 a
	 sbc	 hl, de
	 jr	 nz, .done
	 call	 cpkt_finish			;complete current packet
.done:
	 ipres
	 ret

#endasm

#asm root

;assumes byte is in B, SCSR snapshot is in C
cpkt_paritytest::
	 ld	 a, (cpkt_parity)
	 dec	 a
	 or	 a
	 jr	 z, .oddparity
.evenparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	hl
	 jr	 z, .check9high
	 jr	 .check9low

.oddparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .check9low
.check9high:
	 bit	 6, c
	 jr	 z, .paritydone
	 jr	 .setparityerror

.check9low:
	 bit	 6, c
	 jr	 nz, .paritydone
.setparityerror:
	 ld	 a, 0x01
	 ld	 (cpkt_parityerror), a
.paritydone:
	 ret

#endasm

#asm root

cpkt_gapisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SCSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SCSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SCSR), a			;clear interrupt
	IOWRITE_A(SCSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (cpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (cpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 cpkt_sendbyte		;try and send another byte,
	 									; with possible parity bit
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
										;handle gaps, transitions, etc.
	 ld	 a, (cpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (cpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT6R),a
	IOWRITE_A(TAT6R)

	 ld	 a, (cpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 ;decide if we need to send a gap or data???
	 ld	 a, (cpkt_txactive)	;are we transmitting?
	 or	 a
	 jr	 z, .isr_rxdummy		;dummy is for rx gap timing
	 ld	 a, (cpkt_txdelay)
	 or	 a
	 jr	 nz, .isr_txdummy
	 call	 cpkt_isr_enableport		;make sure we can send data
	 call	 cpkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (cpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 cpkt_isr_disableport
;ioi ld	 (SCDR), a				;load final dummy
	IOWRITE_A(SCDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:							;moved up to keep jump in range
;ioi ld	 a, (SCDR)			;read byte, clear interrupt
	IOREAD_A(SCDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (cpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT6R),a
	IOWRITE_A(TAT6R)
	 call	 cpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (cpkt_longstop), a			;clear out long stop flag
	 call  cpkt_isr_disableport
;ioi ld	 (SCDR), a						;do a fast dummy
	IOWRITE_A(SCDR)
	 jr	 .isr_txdone

.isr_txdummy:						;dummy for tx delay
	 dec	 a
	 ld	 (cpkt_txdelay), a
	 call	 cpkt_isr_disableport
;ioi ld	 (SCDR), a				;load dummy
	IOWRITE_A(SCDR)
	 jr	 .isr_txdone

.isr_rxdummy:
	 ld	 a, (cpkt_rxgapcount)
	 or	 a
	 jr	 z, .isr_rxendpacket		;a full gap was detected
	 dec	 a
	 ld	 (cpkt_rxgapcount), a
;ioi ld	 (SCDR), a					;load dummy
	IOWRITE_A(SCDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (cpkt_txdone), a
	 ld	 (cpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxendpacket:
	 call	 cpkt_finish
	 jr	 .isr_txdone


.isr_rxchecktx:
	 ld	 a, (cpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcheckparity
	 ld	 a, 0x01
	 ld	 (cpkt_rxoverrun), a
.isr_rxcheckparity:
	 ld	 a, (cpkt_parity)
	 or	 a
	 jr	 z, .isr_rxcontinue		;next step
	 call  cpkt_paritytest

.isr_rxcontinue:					;no defined start byte, just load it
	 ld	 a, (cpkt_waitforgap)
	 or	 a
	 jr	 nz, .isr_rxresetgap		;waiting for a gap
	 call	 cpkt_recvbyte
.isr_rxresetgap:
	 ld	 a, (cpkt_rxgapsize)
	 ld	 (cpkt_rxgapcount), a	;reset the gap counter
;ioi ld	 (SCDR), a					;send dummy byte for gap timing
	IOWRITE_A(SCDR)
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

cpkt_9bitisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SCSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SCSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SCSR), a			;clear interrupt
	IOWRITE_A(SCSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (cpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (cpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 cpkt_send9bit			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (cpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (cpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT6R),a
	IOWRITE_A(TAT6R)

	 ld	 a, (cpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 cpkt_isr_enableport		;make sure we can send data
	 call	 cpkt_send9bit			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (cpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 cpkt_isr_disableport
;ioi ld	 (SCDR), a				;load final dummy
	IOWRITE_A(SCDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SCDR)			;read byte, clear interrupt
	IOREAD_A(SCDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (cpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT6R),a
	IOWRITE_A(TAT6R)
	 call	 cpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (cpkt_longstop), a			;clear out long stop flag
	 call  cpkt_isr_disableport
;ioi ld	 (SCDR), a						;do a fast dummy
	IOWRITE_A(SCDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (cpkt_txdone), a
	 ld	 (cpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (cpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (cpkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (cpkt_9bittype)
	 or	 a							;zero test A
	 jr	 z, .isr_rxchecklowstart
	 dec	 a
	 jr	 z, .isr_rxchecklowstart
.isr_rxcheckhighstart:
	 bit	 6, c
	 jr	 z, .isr_rxstart
	 jr	 .isr_rxnotstart
.isr_rxchecklowstart:
	 bit	 6, c
	 jr	 nz, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (cpkt_rxpos)
	 bool	 hl
	 jr	 nz, .isr_rxload		;we are in the middle of a packet
	 jr	 .isr_rxdone
.isr_rxload:
	 call	 cpkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call	 cpkt_finish
	 call	 cpkt_recvbyte

.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

cpkt_charisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SCSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SCSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SCSR), a			;clear interrupt
	IOWRITE_A(SCSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (cpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (cpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 cpkt_sendbyte			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (cpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (cpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT6R),a
	IOWRITE_A(TAT6R)

	 ld	 a, (cpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 cpkt_isr_enableport		;make sure we can send data
	 call	 cpkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (cpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 cpkt_isr_disableport
;ioi ld	 (SCDR), a				;load final dummy
	IOWRITE_A(SCDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SCDR)			;read byte, clear interrupt
	IOREAD_A(SCDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (cpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT6R),a
	IOWRITE_A(TAT6R)
	 call	 cpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (cpkt_longstop), a			;clear out long stop flag
	 call  cpkt_isr_disableport
;ioi ld	 (SCDR), a						;do a fast dummy
	IOWRITE_A(SCDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (cpkt_txdone), a
	 ld	 (cpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (cpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (cpkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (cpkt_startchar)
	 cp	 b
	 jr	 z, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (cpkt_rxpos)
	 bool	 hl
	 jr	 z, .isr_rxdone		;keep waiting for a start byte
.isr_rxload:
	 call	 cpkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call cpkt_finish
	 call	cpkt_recvbyte
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

/*** BeginHeader pktCsetParity */
void pktCsetParity(char mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktCsetParity                   <PACKET.LIB>

SYNTAX:		   void pktCsetParity(char mode);

DESCRIPTION:   Configures parity generation and checking
					Can also configure for 2 stop bits.

PARAMETER1:		Code for mode of parity bit
					PKT_NOPARITY - no parity bit (8N1 format, default)
					PKT_OPARITY 1 - odd parity (8O1 format)
					PKT_EPARITY 2 - even parity (8E1 format)
					PKT_TWOSTOP 3 - an extra stop bit (8N2 format)

END DESCRIPTION **********************************************************/

nodebug void pktCsetParity(char mode)
{
	cpkt_parity = mode;
}

/*** BeginHeader pktCsending */
int pktCsending();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktCsending                   <PACKET.LIB>

SYNTAX:		   int pktCsending();

DESCRIPTION:   Tests if a packet is currently being sent. If this returns
					true, the transmitter is bus and cannot accept another packet.

RETURN VALUE:	1: A packet is being transmitted on port C
               0: port C is idle, ready for a new packet

END DESCRIPTION **********************************************************/

nodebug int pktCsending()
{
	return (int)cpkt_txactive;
}

/*** BeginHeader pktCsend */
int pktCsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktCsend                   <PACKET.LIB>

SYNTAX:		   int pktCsend(void *send_buffer,
									 int buffer_length,
									 char delay);

DESCRIPTION:   Initiates the sending of a packet of data. This function will
					always return immediately. If there is already a packet being
					transmitted, this call will return 0 and the packet will not be
					transmitted, otherwise it will return 1.
					The pktCsending() function is used to check
					if the packet is done transmitting. The system will be using the
					buffer until then.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

RETURN VALUE:	1 if the packet is goint to be transmitted
					0 if there is already a packet transmitting, and the new packet
						was refused.

END DESCRIPTION **********************************************************/

nodebug int pktCsend(void *send_buffer, int buffer_length, char delay)
{
	//loop until tx is ready
	if (pktCsending())
	{
		return 0;
	}
	else
	{
		cpkt_txframe = send_buffer;
		cpkt_txsize = buffer_length;
		cpkt_txcount = 0;
		cpkt_txdelay = delay;
		cpkt_txactive = 1;				//set active flag
		if(delay)
		{
			cpkt_disableport();
			WrPortI(SCDR, NULL, 23);		//send a dummy character to start
		}
		else
		{
			cpkt_enableport();
			if(cpkt_type == PKT_9BITMODE)
			{
				cpkt_send9bit();
			}
			else
			{
				cpkt_sendbyte();
			}
		}
		return 1;
	}
}

/*** BeginHeader cof_pktCsend */
scofunc void cof_pktCsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktCsend                   <PACKET.LIB>

SYNTAX:		   void cof_pktCsend(void *send_buffer,
									  		int buffer_length,
									  		char delay);

DESCRIPTION:   Cofunction version of pktCsend(). This function will yield
					to other tasks while the packet is being sent. It differs from
					pktCsend() in that it will not return until the packet is
					done transmitting.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_pktCsend(void *send_buffer,
											 int buffer_length,
											 char delay)
{
	//wait until tx is ready
	while (pktCsending()) yield;

	cpkt_txframe = send_buffer;
	cpkt_txsize = buffer_length;
	cpkt_txcount = 0;
	cpkt_txdelay = delay;
	cpkt_txactive = 1;				//set active flag
	if(delay)
	{
		cpkt_disableport();
		WrPortI(SCDR, NULL, 23);		//send a dummy character to start
	}
	else
	{
		cpkt_enableport();
		if(cpkt_type == PKT_9BITMODE)
		{
			cpkt_send9bit();
		}
		else
		{
			cpkt_sendbyte();
		}
	}
	while (pktCsending()) yield;	//wait for this packet to finish
}

/*** BeginHeader pktCreceive */
int pktCreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktCreceive                   <PACKET.LIB>

SYNTAX:		   int pktCreceive(void *buffer, int buffer_size);

DESCRIPTION:   Gets a received packet if there is one in the packet buffer.
					Otherwise, it will immediately return 0.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE: >0: The number of bytes in the received packet.
				  0: indicates that no new packets have been received.
				  -1: indicates that the packet is too large for the given buffer
				  -2: if a needed test_packet function is not defined

END DESCRIPTION **********************************************************/

nodebug int pktCreceive(void *buffer, int buffer_size)
{
	auto int rxpos;
	auto int packet_length;
	auto int buffer_offset;
	auto int temp;

	rxpos = cpkt_rxpos;
	buffer_offset = cpkt_rxnext*(cpkt_rxsize+2);
	xmem2root(&packet_length, cpkt_rxbuffers + buffer_offset, 2);
	if(packet_length)
	{
		//packet is definitely done
		if(packet_length <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, cpkt_rxbuffers + buffer_offset + 2, packet_length);
			temp = 0;
			root2xmem(cpkt_rxbuffers + buffer_offset, &temp, 2); //clear out
			cpkt_rxnext = (cpkt_rxnext + 1) % cpkt_rxcount;
			cpkt_lastpos = 0;
			return packet_length;
		}
		else
		{
			return -1;
		}
	}
	else if(cpkt_type != PKT_GAPMODE && rxpos != cpkt_lastpos)
	{
		if (cpkt_testpacket == NULL)
		{
			return -2;
		}
		//check for complete packet
		if(rxpos <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, cpkt_rxbuffers + buffer_offset + 2, rxpos);
			if ( (*cpkt_testpacket)(buffer, rxpos) )
			{
				cpkt_nextdone(); //complete packet
				temp = 0;
				root2xmem(cpkt_rxbuffers + buffer_offset, &temp, 2); //clear out
				cpkt_rxnext = (cpkt_rxnext + 1) % cpkt_rxcount;
				cpkt_lastpos = 0;
				return rxpos;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return 0;
	}
}

/*** BeginHeader cof_pktCreceive */
scofunc int cof_pktCreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktCreceive                   <PACKET.LIB>

SYNTAX:		   int cof_pktCreceive(void *buffer, int buffer_size);

DESCRIPTION:   This cofunction is used to listen for received packets.
					It will return with a packet immediately if there is one in
					in the buffer. Otherwise, it will wait for one while yielding
					to other tasks.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE:	The length of the received packet or an error code
					identical to those in pktCreceive()

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_pktCreceive(void *buffer, int buffer_size)
{
	auto int length;
	while((length = pktCreceive(buffer, buffer_size)) == 0)
	{
		yield;
	}
	return length;
}


/*** BeginHeader pktCgetErrors */
char pktCgetErrors();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktCgetErrors                   <PACKET.LIB>

SYNTAX:		   char pktCgetErrors();

DESCRIPTION:   Gets a bit field with flags set for any errors that occured.
					These flags are then cleared, so that a particular error
					will only cause the flag to be set once.

RETURN VALUE:	A bit field with flags for various errors. The errors
					along with their bit masks are as follows:
						PKT_BUFFEROVERFLOW 0x01
						PKT_RXOVERRUN 0x02
						PKT_PARITYERROR 0x04
						PKT_NOBUFFER 0x08

END DESCRIPTION **********************************************************/

nodebug char pktCgetErrors()
{
	auto char error_flags;

	error_flags = 0;
	if (cpkt_overflow) {
		error_flags |= PKT_BUFFEROVERFLOW;
		cpkt_overflow = 0;		//clear the error after reporting it
	}
	if (cpkt_rxoverrun) {
		error_flags |= PKT_RXOVERRUN;
		cpkt_rxoverrun = 0;
	}
	if (cpkt_parityerror) {
		error_flags |= PKT_PARITYERROR;
		cpkt_parityerror = 0;
	}
	if (cpkt_nobuffer) {
		error_flags |= PKT_NOBUFFER;
		cpkt_nobuffer = 0;
	}

	return error_flags;
}


//************************************************************************
//****************************** PORT D **********************************
//************************************************************************


/*** Beginheader pktDopen, pktDclose, pktDinitBuffers, dpkt_nextdone */
int pktDopen(long baud, int mode, char options, int (*test_packet)());
root void pktDclose();
int pktDinitBuffers(int buf_count, int buf_size);
void dpkt_nextdone();

int dpkt_sendbyte();
void dpkt_enableport();
void dpkt_disableport();

extern unsigned long dpkt_rxbuffers;
extern int dpkt_rxcount;
extern int dpkt_rxsize;
extern int dpkt_rxpos;
extern int dpkt_rxnext;		//next buffer to be read out
extern int dpkt_rxcurrent;	//buffer being written to
extern unsigned long dpkt_rxcurrent_ptr; //temp pointer to start of current buffer

extern int dpkt_lastpos;
extern char *dpkt_txframe;
extern int dpkt_txcount;
extern int dpkt_txsize;
extern char dpkt_type;
extern char dpkt_parity;
extern char dpkt_rxgapcount;
extern char dpkt_rxgapsize;
extern char dpkt_txdelay;
extern char dpkt_startchar;
extern char dpkt_txdone;
extern char dpkt_9bittype;
extern char dpkt_divisor;
extern char dpkt_fastdivisor;
extern char dpkt_longstop;
extern char dpkt_portenabled;
//pointer to function that tests for complete packets
extern int (*dpkt_testpacket)(); //takes (void *, int) as args
extern char dpkt_txactive;
extern char dpkt_waitforgap;

//errors
extern char dpkt_parityerror;
extern char dpkt_rxoverrun;
extern char dpkt_overflow;
extern char dpkt_nobuffer;

/*** endheader */

unsigned long dpkt_rxbuffers;
int dpkt_rxcount;
int dpkt_rxsize;
int dpkt_rxpos;
int dpkt_rxnext;		//next buffer to be read out
int dpkt_rxcurrent;	//buffer being written to
unsigned long dpkt_rxcurrent_ptr; //temp pointer to start of current buffer

int dpkt_lastpos;
char *dpkt_txframe;
int dpkt_txcount;
int dpkt_txsize;
char dpkt_type;
char dpkt_parity;
char dpkt_rxgapcount;
char dpkt_rxgapsize;
char dpkt_txdelay;
char dpkt_startchar;
char dpkt_txdone;
char dpkt_9bittype;
char dpkt_divisor;
char dpkt_fastdivisor;
char dpkt_longstop;
char dpkt_portenabled;
//pointer to function that tests for complete packets
int (*dpkt_testpacket)(); //takes (void *, int) as args
char dpkt_txactive;
char dpkt_waitforgap;

//errors
char dpkt_parityerror;
char dpkt_rxoverrun;
char dpkt_overflow;
char dpkt_nobuffer;

extern void pktDinit();
extern void pktDrx();
extern void pktDtx();

#define DDRIVE_TXMASK 1


//internal functions
void dpkt_init( void (*isr)() );
void dpkt_gapisr();
void dpkt_9bitisr();
void dpkt_charisr();

/* START FUNCTION DESCRIPTION ********************************************
pktDopen                   <PACKET.LIB>

SYNTAX:		   int pktDopen(long baud,
									 int mode,
									 char options,
									 int (*test_packet)() );

DESCRIPTION:   Opens the D serial port.

PARAMETER1:    Bits per second of data transfer: min 2400

PARAMETER2:		mode - type of packet scheme used, options are:
						PKT_GAPMODE
						PKT_9BITMODE
						PKT_CHARMODE

PARAMETER3:		options - further specification for the packet scheme
						The value of this depends on the mode used.
						gap mode - minimum gap size(in byte times)
						9bit mode - type of 9bit protocol
							PKT_RABBITSTARTBYTE
							PKT_LOWSTARTBYTE
							PKT_HIGHSTARTBYTE
						char mode - character marking start of packet

PARAMETER4:		ptr to function that tests for completeness of a packet. The
					function should return 1 if the packet is complete, or 0 if
					more data should be read in. For gap mode the test function is
					not used and should be set to NULL.

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

END DESCRIPTION **********************************************************/

nodebug int pktDopen(long baud, int mode, char options, int (*test_packet)())
{
   auto long divisor, ta1div;
	auto float baud_ratio;
	auto unsigned long t;
	auto int temp, i;

   dpkt_type = mode;
   dpkt_parity = 0;
	dpkt_txactive = 0;
	dpkt_txdone = 0;
	dpkt_waitforgap = 0;
	dpkt_longstop = 0;
	dpkt_rxgapcount = 0;
	dpkt_lastpos = 0;

	dpkt_parityerror = 0;
	dpkt_rxoverrun = 0;
	dpkt_overflow = 0;
	dpkt_nobuffer = 0;

	dpkt_rxcurrent = 0;
	dpkt_rxcurrent_ptr = dpkt_rxbuffers; //first buffer
	dpkt_rxpos = 0;
	dpkt_rxnext = 0;
	//initialize the buffers
	temp = 0;
	for(i = 0;i < dpkt_rxcount;i++)
	{
		root2xmem(dpkt_rxbuffers + i*(dpkt_rxsize + 2), &temp, 2);
	}


	dpkt_testpacket = test_packet;

   if (baud < 1) baud = 1;
   // (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"

	ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	BitWrPortI(TACR, &TACRShadow, 1, 7);
	}
	else
	{
		BitWrPortI(TACR, &TACRShadow, 0, 7);
	}
	WrPortI(TAT7R, &TAT7RShadow, (char)divisor);

	//set up mode and options
	if (mode == PKT_GAPMODE)
	{
		dpkt_rxgapsize = options;
   	dpkt_init(dpkt_gapisr);
   }
   else if (mode == PKT_9BITMODE)
   {
   	dpkt_9bittype = options;
   	dpkt_init(dpkt_9bitisr);
	}
	else
	{
		dpkt_startchar = options;
		dpkt_init(dpkt_charisr);
	}
   dpkt_divisor = (char)divisor;
   dpkt_fastdivisor = (char)divisor / 8;
   if (dpkt_fastdivisor < 1) dpkt_fastdivisor = 1;

   // let baud timer time out before using port
   t = MS_TIMER;
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   pktDinit();
   dpkt_disableport();
   return (((long)((BASEFREQ*freq_divider) /
   	(32 * (divisor + 1)) + 0.5)) == baud);    // rounded baud actually used
}

/* START FUNCTION DESCRIPTION ********************************************
pktDinitBuffers                   <PACKET.LIB>

SYNTAX:		   int pktDinitBuffers(int buf_count, int buf_size);

DESCRIPTION:   Allocates extended memory for the channel D receive buffers.
					This function should not be called more than once in a program.
					The total memory allocated is count*(size + 2) bytes

PARAMETER1:    buf_count - the number of buffers to allocate. Each buffer can
					store one received packet. Increasing this number allows for
					more pending packets and a larger latency time before packets
					must be processed by the user's program.

PARAMETER2:		buf_size - the number of bytes each buffer can accomodate. This
					should be set to the size of the largest possible packet
					that can be expected.

RETURN VALUE:	1: The xmem allocation was successful
               0: The allocation failed. This packet channel cannot be used.

END DESCRIPTION **********************************************************/

nodebug int pktDinitBuffers(int buf_count, int buf_size)
{
	dpkt_rxcount = buf_count;
	if(buf_size % 2)
	{
		buf_size++;   //make sure buffer sizes are even
	}
	dpkt_rxsize = buf_size;
	dpkt_rxbuffers = xalloc(buf_count*(buf_size+2)+2);
	if(dpkt_rxbuffers % 2)
	{
		dpkt_rxbuffers++;		//make sure buffers start on even boundaries
	}
	if(!dpkt_rxbuffers)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}


/* START FUNCTION DESCRIPTION ********************************************
pktDclose                   <PACKET.LIB>

SYNTAX:		   void pktDclose();

DESCRIPTION:   Disables the D serial port.

PARAMETER1:    None

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

#if _USER
#asm root
pktDclosed::
	ret
#endasm
#endif

#asm root
pktDclose::
#if _USER
c	 SetVectIntern(SERD_OFS/0x10, pktDclosed);
#else
	 ld	 a,0xc9         ; ret in first byte
	 ipset 1
	 ld	 (INTVEC_BASE + SERD_OFS),a
#endif

	 ld	 a, 0x00
;ioi ld	 (SDCR),a
	IOWRITE_A(SDCR)
	 ipres
	 ret

;
; dpkt_init
;

dpkt_init::
#if _USER
	push	hl
   ld		hl,SERD_OFS/0x10
   push	hl
   call  SetVectIntern
   add	sp,2
#else
	 ld	 iy, INTVEC_BASE + SERD_OFS
	 ipset 1
	 ld	 (iy), 0C3h			; the JP command
	 ld	 (iy+1), hl			; ISR for a particular mode
#endif

	 call	 dpkt_isr_disableport

	 ld	 a,0x01			; enable interrupts for port
;ioi ld	 (SDCR),a
	IOWRITE_A(SDCR)
	 ipres
	 ret

dpkt_isr_enableport::
    ld	 a,(PCFRShadow)
    or	 DDRIVE_TXMASK              ; enable serial port D transmitter
    ld	 (PCFRShadow),a
;ioi ld	 (PCFR),a
	IOWRITE_A(PCFR)
	 call  pktDtx			;user defined asm routine
	 ld	 a, 0x01
	 ld	 (dpkt_portenabled), a
	 ret

dpkt_enableport::
	 ipset 1
	 call	 dpkt_isr_enableport
	 ipres
	 ret

dpkt_isr_disableport::
	 call	 dpkt_disabledrive
	 call  pktDrx		;user defined asm routine
	 ret

dpkt_disableport::
	 ipset 1
	 call	 dpkt_isr_disableport
	 ipres
	 ret

dpkt_disabledrive::		;seperate call for longstops
	 ld	 a, (PCDRShadow)
	 or	 DDRIVE_TXMASK
	 ld	 (PCDRShadow), a
;ioi ld	 (PCDR), a
	IOWRITE_A(PCDR)
    ld	 a,(PCFRShadow)
    and	 ~DDRIVE_TXMASK              ; disable serial port D transmitter
    ld	 (PCFRShadow),a
;ioi ld	 (PCFR),a
	IOWRITE_A(PCFR)
	 xor	 a
	 ld	 (dpkt_portenabled), a
	 ret

#endasm

#asm root

dpkt_sendbyte::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (dpkt_txcount)
	 ld	 hl, (dpkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (dpkt_txcount)
	 ld	 hl, (dpkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (dpkt_txcount), de	;increment txcount
	 ld	 a, (dpkt_parity)
	 or	 a
	 jr	 z, .send8bit
	 dec	 a
	 jr	 z, .sendodd
	 dec	 a
	 jr	 z, .sendeven
	 jr	 .send9high		;2 stop bits, 9th bit always high

.sendeven:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity		;returns true if odd
	 bool	 hl
	 jr	 nz, .send9low		;byte is already even parity
	 jr	 .send9high
.sendodd:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .send9low	;byte is already odd parity
	 jr	 .send9high
.send8bit:
	 ld	 a, c
;ioi ld	 (SDDR), a
	IOWRITE_A(SDDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SDAR), a
	IOWRITE_A(SDAR)
	 jr	 .sendexit
#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
.send9high:
	 ld	 a, c
;ioi ld	 (SDLR), a
	IOWRITE_A(SDLR)
	 jr	 .sendexit
#else
.send9high:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, .send9longstop
	 ld	 a, c
;ioi ld	 (SDLR), a
	IOWRITE_A(SDLR)
	 jr	 .sendexit
.send9longstop:
	 ld	 a, 0x01
	 ld	 (dpkt_longstop), a
	 jr	 .send8bit
#endif
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

dpkt_send9bit::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (dpkt_txcount)
	 ld	 hl, (dpkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (dpkt_txcount)
	 ld	 hl, (dpkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (dpkt_txcount), de	;increment txcount

	 ld	 a, (dpkt_9bittype)
	 or	 a
	 jr	 z, .rabbitstart
	 dec	 a
	 jr	 z, .lowstart
.highstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9high
	 jr	 .send9low
.lowstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low	;if de <= 1
	 jr	 .send9high
.rabbitstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low
.send8bit:
	 ld	 a, c
;ioi ld	 (SDDR), a
	IOWRITE_A(SDDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SDAR), a
	IOWRITE_A(SDAR)
	 jr	 .sendexit
#if (CPU_ID_MASK(_CPU_ID_) >= R3000)
.send9high:
	 ld	 a, c
;ioi ld	 (SDLR), a
	IOWRITE_A(SDLR)
	 jr	 .sendexit
#else
.send9high:
;ioi ld	 a, (GREV)			;check for 2000A or later
	IOREAD_A(GREV)
	 and	 0x0f					;check for anything past Ver. 0
	 jr	 z, .send9longstop
	 ld	 a, c
;ioi ld	 (SDLR), a
	IOWRITE_A(SDLR)
	 jr	 .sendexit
.send9longstop:
	 ld	 a, 0x01
	 ld	 (dpkt_longstop), a
	 jr	 .send8bit
#endif
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

; assumes byte is stored in B, can trash other registers
dpkt_recvbyte::

	 push	 ix
	 ld	 ix, (dpkt_rxcurrent_ptr)
	 ld	 a, (dpkt_rxcurrent_ptr + 2)
	 ldp	 hl, (ix)		;get length field
	 bool	 hl
	 jr	 nz, .no_buffer		;buffer is full
	 ld	 de, 2
	 add	 ix, de
	 adc	 a, 0					;carry if needed
	 ld	 de, (dpkt_rxpos)
	 add	 ix, de
	 adc	 a, 0					;carry add into high bit
	 ldp	 hl, (ix)
	 ld	 L, b					;from ISR, b holds received byte
	 ldp	 (ix), hl
	 inc	 de					;de still holds rxpos
	 ld	 hl, (dpkt_rxsize)
	 or	 a						;clear carry
	 sbc	 hl, de
	 jr	 z, .buffer_overflow
	 ld	 (dpkt_rxpos), de
	 jr	 .recvdone

.no_buffer:
	 ld	 a, 0x01
	 ld	 (dpkt_nobuffer), a
	 jr	 .recvdone

.buffer_overflow:
	 ld	 a, 0x01
	 ld	 (dpkt_overflow), a
	 ld	 hl, 0
	 ld	 (dpkt_rxpos), hl		;set pos to beginning of buffer
.recvdone:
	 pop	 ix
	 ret

#endasm

#asm root

dpkt_finish::
	 push	 bc
	 push	 ix
	 ld	 hl, (dpkt_rxpos)
	 bool	 hl
	 jr	 z, .done		;no packet
	 ld	 ix, (dpkt_rxcurrent_ptr)
	 ld	 a, (dpkt_rxcurrent_ptr + 2)
	 ld	 hl, (dpkt_rxpos)		;load length into buffer
	 ldp	 (ix), hl
	 ld	 de, (dpkt_rxcurrent)
	 inc	 de
	 ld	 hl, (dpkt_rxcount)
	 or	 a		;clear carry
	 sbc	 hl, de
	 jr	 nz, .newbuffer
	 ld	 d, 0
	 ld	 e, 0					;zero out current buffer number
.newbuffer:
	 ld	 (dpkt_rxcurrent), de
	 ld	 hl, (dpkt_rxsize)
	 inc	 hl
	 inc	 hl					;add 2 to size for total buffer size
	 ld	 c, L
	 ld	 b, h
	 mul							;current * (size+2)
	 ld	 e, L					;high byte of result now in e
	 ld	 hl, (dpkt_rxbuffers)		;base of buffer array
	 ld	 a, (dpkt_rxbuffers + 2)
	 add	 hl, bc
	 adc	 a, e
	 ld	 (dpkt_rxcurrent_ptr), hl	;set new current ptr
	 ld	 (dpkt_rxcurrent_ptr + 2), a
	 bool	 hl
	 ld	 L, 0
	 ld	 (dpkt_rxpos), hl			;zero out position
.done:
	 pop	 ix
	 pop	 bc
	 ret

#endasm

#asm root

dpkt_nextdone::
	 ipset 1
	 ld	 hl, (dpkt_rxnext)
	 ld	 de, (dpkt_rxcurrent)
	 or	 a
	 sbc	 hl, de
	 jr	 nz, .done
	 call	 dpkt_finish			;complete current packet
.done:
	 ipres
	 ret

#endasm

#asm root

;assumes byte is in B, SDSR snapshot is in C
dpkt_paritytest::
	 ld	 a, (dpkt_parity)
	 dec	 a
	 or	 a
	 jr	 z, .oddparity
.evenparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	hl
	 jr	 z, .check9high
	 jr	 .check9low

.oddparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .check9low
.check9high:
	 bit	 6, c
	 jr	 z, .paritydone
	 jr	 .setparityerror

.check9low:
	 bit	 6, c
	 jr	 nz, .paritydone
.setparityerror:
	 ld	 a, 0x01
	 ld	 (dpkt_parityerror), a
.paritydone:
	 ret

#endasm

#asm root

dpkt_gapisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SDSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SDSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SDSR), a			;clear interrupt
	IOWRITE_A(SDSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (dpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (dpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 dpkt_sendbyte		;try and send another byte,
	 									; with possible parity bit
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
										;handle gaps, transitions, etc.
	 ld	 a, (dpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (dpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT7R),a
	IOWRITE_A(TAT7R)

	 ld	 a, (dpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 ;decide if we need to send a gap or data???
	 ld	 a, (dpkt_txactive)	;are we transmitting?
	 or	 a
	 jr	 z, .isr_rxdummy		;dummy is for rx gap timing
	 ld	 a, (dpkt_txdelay)
	 or	 a
	 jr	 nz, .isr_txdummy
	 call	 dpkt_isr_enableport		;make sure we can send data
	 call	 dpkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (dpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 dpkt_isr_disableport
;ioi ld	 (SDDR), a				;load final dummy
	IOWRITE_A(SDDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:							;moved up to keep jump in range
;ioi ld	 a, (SDDR)			;read byte, clear interrupt
	IOREAD_A(SDDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (dpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT7R),a
	IOWRITE_A(TAT7R)
	 call	 dpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (dpkt_longstop), a			;clear out long stop flag
	 call  dpkt_isr_disableport
;ioi ld	 (SDDR), a						;do a fast dummy
	IOWRITE_A(SDDR)
	 jr	 .isr_txdone

.isr_txdummy:						;dummy for tx delay
	 dec	 a
	 ld	 (dpkt_txdelay), a
	 call	 dpkt_isr_disableport
;ioi ld	 (SDDR), a				;load dummy
	IOWRITE_A(SDDR)
	 jr	 .isr_txdone

.isr_rxdummy:
	 ld	 a, (dpkt_rxgapcount)
	 or	 a
	 jr	 z, .isr_rxendpacket		;a full gap was detected
	 dec	 a
	 ld	 (dpkt_rxgapcount), a
;ioi ld	 (SDDR), a					;load dummy
	IOWRITE_A(SDDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (dpkt_txdone), a
	 ld	 (dpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxendpacket:
	 call	 dpkt_finish
	 jr	 .isr_txdone


.isr_rxchecktx:
	 ld	 a, (dpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcheckparity
	 ld	 a, 0x01
	 ld	 (dpkt_rxoverrun), a
.isr_rxcheckparity:
	 ld	 a, (dpkt_parity)
	 or	 a
	 jr	 z, .isr_rxcontinue		;next step
	 call  dpkt_paritytest

.isr_rxcontinue:					;no defined start byte, just load it
	 ld	 a, (dpkt_waitforgap)
	 or	 a
	 jr	 nz, .isr_rxresetgap		;waiting for a gap
	 call	 dpkt_recvbyte
.isr_rxresetgap:
	 ld	 a, (dpkt_rxgapsize)
	 ld	 (dpkt_rxgapcount), a	;reset the gap counter
;ioi ld	 (SDDR), a					;send dummy byte for gap timing
	IOWRITE_A(SDDR)
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

dpkt_9bitisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SDSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SDSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SDSR), a			;clear interrupt
	IOWRITE_A(SDSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (dpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (dpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 dpkt_send9bit			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (dpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (dpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT7R),a
	IOWRITE_A(TAT7R)

	 ld	 a, (dpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 dpkt_isr_enableport		;make sure we can send data
	 call	 dpkt_send9bit			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (dpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 dpkt_isr_disableport
;ioi ld	 (SDDR), a				;load final dummy
	IOWRITE_A(SDDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SDDR)			;read byte, clear interrupt
	IOREAD_A(SDDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (dpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT7R),a
	IOWRITE_A(TAT7R)
	 call	 dpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (dpkt_longstop), a			;clear out long stop flag
	 call  dpkt_isr_disableport
;ioi ld	 (SDDR), a						;do a fast dummy
	IOWRITE_A(SDDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (dpkt_txdone), a
	 ld	 (dpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (dpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (dpkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (dpkt_9bittype)
	 or	 a							;zero test A
	 jr	 z, .isr_rxchecklowstart
	 dec	 a
	 jr	 z, .isr_rxchecklowstart
.isr_rxcheckhighstart:
	 bit	 6, c
	 jr	 z, .isr_rxstart
	 jr	 .isr_rxnotstart
.isr_rxchecklowstart:
	 bit	 6, c
	 jr	 nz, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (dpkt_rxpos)
	 bool	 hl
	 jr	 nz, .isr_rxload		;we are in the middle of a packet
	 jr	 .isr_rxdone
.isr_rxload:
	 call	 dpkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call	 dpkt_finish
	 call	 dpkt_recvbyte

.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

dpkt_charisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SDSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SDSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SDSR), a			;clear interrupt
	IOWRITE_A(SDSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (dpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (dpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 dpkt_sendbyte			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (dpkt_longstop)
	 or	 a
	 jr	 nz, .isr_dolongstop

	 ld	 a, (dpkt_divisor)		;make sure UART is returned to normal speed
;ioi ld 	 (TAT7R),a
	IOWRITE_A(TAT7R)

	 ld	 a, (dpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 dpkt_isr_enableport		;make sure we can send data
	 call	 dpkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (dpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 dpkt_isr_disableport
;ioi ld	 (SDDR), a				;load final dummy
	IOWRITE_A(SDDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SDDR)			;read byte, clear interrupt
	IOREAD_A(SDDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_dolongstop:
	 ld	 a, (dpkt_fastdivisor)		;speed up uart to send a single bit
;ioi ld 	 (TAT7R),a
	IOWRITE_A(TAT7R)
	 call	 dpkt_disabledrive			;tranceiver should stay on
	 xor	 a
	 ld	 (dpkt_longstop), a			;clear out long stop flag
	 call  dpkt_isr_disableport
;ioi ld	 (SDDR), a						;do a fast dummy
	IOWRITE_A(SDDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (dpkt_txdone), a
	 ld	 (dpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (dpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (dpkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (dpkt_startchar)
	 cp	 b
	 jr	 z, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (dpkt_rxpos)
	 bool	 hl
	 jr	 z, .isr_rxdone		;keep waiting for a start byte
.isr_rxload:
	 call	 dpkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call dpkt_finish
	 call	 dpkt_recvbyte
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

/*** BeginHeader pktDsetParity */
void pktDsetParity(char mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktDsetParity                   <PACKET.LIB>

SYNTAX:		   void pktDsetParity(char mode);

DESCRIPTION:   Configures parity generation and checking
					Can also configure for 2 stop bits.

PARAMETER1:		Code for mode of parity bit
					PKT_NOPARITY - no parity bit (8N1 format, default)
					PKT_OPARITY 1 - odd parity (8O1 format)
					PKT_EPARITY 2 - even parity (8E1 format)
					PKT_TWOSTOP 3 - an extra stop bit (8N2 format)

END DESCRIPTION **********************************************************/

nodebug void pktDsetParity(char mode)
{
	dpkt_parity = mode;
}

/*** BeginHeader pktDsending */
int pktDsending();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktDsending                   <PACKET.LIB>

SYNTAX:		   int pktDsending();

DESCRIPTION:   Tests if a packet is currently being sent. If this returns
					true, the transmitter is bus and cannot accept another packet.

RETURN VALUE:	1: A packet is being transmitted on port D
               0: port D is idle, ready for a new packet

END DESCRIPTION **********************************************************/

nodebug int pktDsending()
{
	return (int)dpkt_txactive;
}

/*** BeginHeader pktDsend */
int pktDsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktDsend                   <PACKET.LIB>

SYNTAX:		   int pktDsend(void *send_buffer,
									 int buffer_length,
									 char delay);

DESCRIPTION:   Initiates the sending of a packet of data. This function will
					always return immediately. If there is already a packet being
					transmitted, this call will return 0 and the packet will not be
					transmitted, otherwise it will return 1.
					The pktDsending() function is used to check
					if the packet is done transmitting. The system will be using the
					buffer until then.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

RETURN VALUE:	1 if the packet is goint to be transmitted
					0 if there is already a packet transmitting, and the new packet
						was refused.

END DESCRIPTION **********************************************************/

nodebug int pktDsend(void *send_buffer, int buffer_length, char delay)
{
	//loop until tx is ready
	if (pktDsending())
	{
		return 0;
	}
	else
	{
		dpkt_txframe = send_buffer;
		dpkt_txsize = buffer_length;
		dpkt_txcount = 0;
		dpkt_txdelay = delay;
		dpkt_txactive = 1;				//set active flag
		if(delay)
		{
			dpkt_disableport();
			WrPortI(SDDR, NULL, 23);		//send a dummy character to start
		}
		else
		{
			dpkt_enableport();
			if(dpkt_type == PKT_9BITMODE)
			{
				dpkt_send9bit();
			}
			else
			{
				dpkt_sendbyte();
			}
		}
		return 1;
	}
}

/*** BeginHeader cof_pktDsend */
scofunc void cof_pktDsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktDsend                   <PACKET.LIB>

SYNTAX:		   void cof_pktDsend(void *send_buffer,
									  		int buffer_length,
									  		char delay);

DESCRIPTION:   Cofunction version of pktDsend(). This function will yield
					to other tasks while the packet is being sent. It differs from
					pktDsend() in that it will not return until the packet is
					done transmitting.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_pktDsend(void *send_buffer,
											 int buffer_length,
											 char delay)
{
	//wait until tx is ready
	while (pktDsending()) yield;

	dpkt_txframe = send_buffer;
	dpkt_txsize = buffer_length;
	dpkt_txcount = 0;
	dpkt_txdelay = delay;
	dpkt_txactive = 1;				//set active flag
	if(delay)
	{
		dpkt_disableport();
		WrPortI(SDDR, NULL, 23);		//send a dummy character to start
	}
	else
	{
		dpkt_enableport();
		if(dpkt_type == PKT_9BITMODE)
		{
			dpkt_send9bit();
		}
		else
		{
			dpkt_sendbyte();
		}
	}
	while (pktDsending()) yield;	//wait for this packet to finish
}

/*** BeginHeader pktDreceive */
int pktDreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktDreceive                   <PACKET.LIB>

SYNTAX:		   int pktDreceive(void *buffer, int buffer_size);

DESCRIPTION:   Gets a received packet if there is one in the packet buffer.
					Otherwise, it will immediately return 0.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE: >0: The number of bytes in the received packet.
				  0: indicates that no new packets have been received.
				  -1: indicates that the packet is too large for the given buffer
				  -2: if a needed test_packet function is not defined

END DESCRIPTION **********************************************************/

nodebug int pktDreceive(void *buffer, int buffer_size)
{
	auto int rxpos;
	auto int packet_length;
	auto int buffer_offset;
	auto int temp;

	rxpos = dpkt_rxpos;
	buffer_offset = dpkt_rxnext*(dpkt_rxsize+2);
	xmem2root(&packet_length, dpkt_rxbuffers + buffer_offset, 2);
	if(packet_length)
	{
		//packet is definitely done
		if(packet_length <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, dpkt_rxbuffers + buffer_offset + 2, packet_length);
			temp = 0;
			root2xmem(dpkt_rxbuffers + buffer_offset, &temp, 2); //clear out
			dpkt_rxnext = (dpkt_rxnext + 1) % dpkt_rxcount;
			dpkt_lastpos = 0;
			return packet_length;
		}
		else
		{
			return -1;
		}
	}
	else if(dpkt_type != PKT_GAPMODE && rxpos != dpkt_lastpos)
	{
		if (dpkt_testpacket == NULL)
		{
			return -2;
		}
		//check for complete packet
		if(rxpos <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, dpkt_rxbuffers + buffer_offset + 2, rxpos);
			if ( (*dpkt_testpacket)(buffer, rxpos) )
			{
				dpkt_nextdone(); //complete packet
				temp = 0;
				root2xmem(dpkt_rxbuffers + buffer_offset, &temp, 2); //clear out
				dpkt_rxnext = (dpkt_rxnext + 1) % dpkt_rxcount;
				dpkt_lastpos = 0;
				return rxpos;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return 0;
	}
}

/*** BeginHeader cof_pktDreceive */
scofunc int cof_pktDreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktDreceive                   <PACKET.LIB>

SYNTAX:		   int cof_pktDreceive(void *buffer, int buffer_size);

DESCRIPTION:   This cofunction is used to listen for received packets.
					It will return with a packet immediately if there is one in
					in the buffer. Otherwise, it will wait for one while yielding
					to other tasks.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE:	The length of the received packet or an error code
					identical to those in pktDreceive()

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_pktDreceive(void *buffer, int buffer_size)
{
	auto int length;
	while((length = pktDreceive(buffer, buffer_size)) == 0)
	{
		yield;
	}
	return length;
}


/*** BeginHeader pktDgetErrors */
char pktDgetErrors();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktDgetErrors                   <PACKET.LIB>

SYNTAX:		   char pktDgetErrors();

DESCRIPTION:   Gets a bit field with flags set for any errors that occured.
					These flags are then cleared, so that a particular error
					will only cause the flag to be set once.

RETURN VALUE:	A bit field with flags for various errors. The errors
					along with their bit masks are as follows:
						PKT_BUFFEROVERFLOW 0x01
						PKT_RXOVERRUN 0x02
						PKT_PARITYERROR 0x04
						PKT_NOBUFFER 0x08

END DESCRIPTION **********************************************************/

nodebug char pktDgetErrors()
{
	auto char error_flags;

	error_flags = 0;
	if (dpkt_overflow) {
		error_flags |= PKT_BUFFEROVERFLOW;
		dpkt_overflow = 0;		//clear the error after reporting it
	}
	if (dpkt_rxoverrun) {
		error_flags |= PKT_RXOVERRUN;
		dpkt_rxoverrun = 0;
	}
	if (dpkt_parityerror) {
		error_flags |= PKT_PARITYERROR;
		dpkt_parityerror = 0;
	}
	if (dpkt_nobuffer) {
		error_flags |= PKT_NOBUFFER;
		dpkt_nobuffer = 0;
	}


	return error_flags;
}


//************************************************************************
//****************************** PORT E **********************************
//************************************************************************


/*** Beginheader pktEopen, pktEclose, pktEinitBuffers, epkt_nextdone */
int pktEopen(long baud, int mode, char options, int (*test_packet)());
root void pktEclose();
int pktEinitBuffers(int buf_count, int buf_size);
void epkt_nextdone();

int epkt_sendbyte();
void epkt_enableport();
void epkt_disableport();

extern unsigned long epkt_rxbuffers;
extern int epkt_rxcount;
extern int epkt_rxsize;
extern int epkt_rxpos;
extern int epkt_rxnext;		//next buffer to be read out
extern int epkt_rxcurrent;	//buffer being written to
extern unsigned long epkt_rxcurrent_ptr; //temp pointer to start of current buffer

extern int epkt_lastpos;
extern char *epkt_txframe;
extern int epkt_txcount;
extern int epkt_txsize;
extern char epkt_type;
extern char epkt_parity;
extern char epkt_rxgapcount;
extern char epkt_rxgapsize;
extern char epkt_txdelay;
extern char epkt_startchar;
extern char epkt_txdone;
extern char epkt_9bittype;
extern char epkt_divisor;
extern char epkt_fastdivisor;
extern char epkt_longstop;
extern char epkt_portenabled;
//pointer to function that tests for complete packets
extern int (*epkt_testpacket)(); //takes (void *, int) as args
extern char epkt_txactive;
extern char epkt_waitforgap;

//errors
extern char epkt_parityerror;
extern char epkt_rxoverrun;
extern char epkt_overflow;
extern char epkt_nobuffer;

/*** endheader */

unsigned long epkt_rxbuffers;
int epkt_rxcount;
int epkt_rxsize;
int epkt_rxpos;
int epkt_rxnext;		//next buffer to be read out
int epkt_rxcurrent;	//buffer being written to
unsigned long epkt_rxcurrent_ptr; //temp pointer to start of current buffer

int epkt_lastpos;
char *epkt_txframe;
int epkt_txcount;
int epkt_txsize;
char epkt_type;
char epkt_parity;
char epkt_rxgapcount;
char epkt_rxgapsize;
char epkt_txdelay;
char epkt_startchar;
char epkt_txdone;
char epkt_9bittype;
char epkt_divisor;
char epkt_fastdivisor;
char epkt_longstop;
char epkt_portenabled;
//pointer to function that tests for complete packets
int (*epkt_testpacket)(); //takes (void *, int) as args
char epkt_txactive;
char epkt_waitforgap;

//errors
char epkt_parityerror;
char epkt_rxoverrun;
char epkt_overflow;
char epkt_nobuffer;

extern void pktEinit();
extern void pktErx();
extern void pktEtx();

#define EDRIVE_TXMASK 0x40


//internal functions
void epkt_init( void (*isr)() );
void epkt_gapisr();
void epkt_9bitisr();
void epkt_charisr();

/* START FUNCTION DESCRIPTION ********************************************
pktEopen                   <PACKET.LIB>

SYNTAX:		   int pktEopen(long baud,
									 int mode,
									 char options,
									 int (*test_packet)() );

DESCRIPTION:   Opens the E serial port.

PARAMETER1:    Bits per second of data transfer: min 2400

PARAMETER2:		mode - type of packet scheme used, options are:
						PKT_GAPMODE
						PKT_9BITMODE
						PKT_CHARMODE

PARAMETER3:		options - further specification for the packet scheme
						The value of this depends on the mode used.
						gap mode - minimum gap size(in byte times)
						9bit mode - type of 9bit protocol
							PKT_RABBITSTARTBYTE
							PKT_LOWSTARTBYTE
							PKT_HIGHSTARTBYTE
						char mode - character marking start of packet

PARAMETER4:		ptr to function that tests for completeness of a packet. The
					function should return 1 if the packet is complete, or 0 if
					more data should be read in. For gap mode the test function is
					not used and should be set to NULL.

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

END DESCRIPTION **********************************************************/

nodebug int pktEopen(long baud, int mode, char options, int (*test_packet)())
{
   auto long divisor, ta1div;
	auto float baud_ratio;
	auto unsigned long t;
	auto int temp, i;

   epkt_type = mode;
   epkt_parity = 0;
	epkt_txactive = 0;
	epkt_txdone = 0;
	epkt_waitforgap = 0;
	epkt_longstop = 0;
	epkt_rxgapcount = 0;
	epkt_lastpos = 0;

	epkt_parityerror = 0;
	epkt_rxoverrun = 0;
	epkt_overflow = 0;
	epkt_nobuffer = 0;

	epkt_rxcurrent = 0;
	epkt_rxcurrent_ptr = epkt_rxbuffers; //first buffer
	epkt_rxpos = 0;
	epkt_rxnext = 0;
	//initialize the buffers
	temp = 0;
	for(i = 0;i < epkt_rxcount;i++)
	{
		root2xmem(epkt_rxbuffers + i*(epkt_rxsize + 2), &temp, 2);
	}


	epkt_testpacket = test_packet;

   if (baud < 1) baud = 1;
   // (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"

	ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	BitWrPortI(TACR, &TACRShadow, 1, 3);
	}
	else
	{
		BitWrPortI(TACR, &TACRShadow, 0, 3);
	}
	WrPortI(TAT2R, &TAT3RShadow, (char)divisor);

	//set up mode and options
	if (mode == PKT_GAPMODE)
	{
		epkt_rxgapsize = options;
   	epkt_init(epkt_gapisr);
   }
   else if (mode == PKT_9BITMODE)
   {
   	epkt_9bittype = options;
   	epkt_init(epkt_9bitisr);
	}
	else
	{
		epkt_startchar = options;
		epkt_init(epkt_charisr);
	}
   epkt_divisor = (char)divisor;
   epkt_fastdivisor = (char)divisor / 8;
   if (epkt_fastdivisor < 1) epkt_fastdivisor = 1;

   // let baud timer time out before using port
   t = MS_TIMER;
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   pktEinit();
   epkt_disableport();
   return (((long)((BASEFREQ*freq_divider) /
   	(32 * (divisor + 1)) + 0.5)) == baud);    // rounded baud actually used
}

/* START FUNCTION DESCRIPTION ********************************************
pktEinitBuffers                   <PACKET.LIB>

SYNTAX:		   int pktEinitBuffers(int buf_count, int buf_size);

DESCRIPTION:   Allocates extended memory for the channel E receive buffers.
					This function should not be called more than once in a program.
					The total memory allocated is count*(size + 2) bytes

PARAMETER1:    buf_count - the number of buffers to allocate. Each buffer can
					store one received packet. Increasing this number allows for
					more pending packets and a larger latency time before packets
					must be processed by the user's program.

PARAMETER2:		buf_size - the number of bytes each buffer can accomodate. This
					should be set to the size of the largest possible packet
					that can be expected.

RETURN VALUE:	1: The xmem allocation was successful
               0: The allocation failed. This packet channel cannot be used.

END DESCRIPTION **********************************************************/

nodebug int pktEinitBuffers(int buf_count, int buf_size)
{
	epkt_rxcount = buf_count;
	if(buf_size % 2)
	{
		buf_size++;   //make sure buffer sizes are even
	}
	epkt_rxsize = buf_size;
	epkt_rxbuffers = xalloc(buf_count*(buf_size+2)+2);
	if(epkt_rxbuffers % 2)
	{
		epkt_rxbuffers++;		//make sure buffers start on even boundaries
	}
	if(!epkt_rxbuffers)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}


/* START FUNCTION DESCRIPTION ********************************************
pktEclose                   <PACKET.LIB>

SYNTAX:		   void pktEclose();

DESCRIPTION:   Disables the E serial port.

PARAMETER1:    None

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

#if _USER
#asm root
pktEclosed::
	ret
#endasm
#endif

#asm root
pktEclose::
#if _USER
c	 SetVectIntern(SERE_OFS/0x10, pktEclosed);
#else
	 ld	 a,0xc9         ; ret in first byte
	 ipset 1
	 ld	 (INTVEC_BASE + SERE_OFS),a
#endif

	 ld	 a, 0x00
;ioi ld	 (SECR),a
	IOWRITE_A(SECR)
	 ipres
	 ret

;
; epkt_init
;

epkt_init::
#if _USER
	push	hl
   ld		hl,SERE_OFS/0x10
   push	hl
   call  SetVectIntern
   add	sp,2
#else
	 ld	 iy, INTVEC_BASE + SERE_OFS
	 ipset 1
	 ld	 (iy), 0C3h			; the JP command
	 ld	 (iy+1), hl			; ISR for a particular mode
#endif

	 call	 epkt_isr_disableport

	 //set pin to output
	 ld	 a, (PGDDRShadow)
	 or	 a, EDRIVE_TXMASK
	 ld	 (PGDDRShadow), a
;ioi ld	 (PGDDR), a
	IOWRITE_A(PGDDR)
	 ld	 a, (PGDCRShadow)
	 and	 a, ~EDRIVE_TXMASK
	 ld	 (PGDCRShadow), a
;ioi ld	 (PGDCR), a				;set to push-pull output
	IOWRITE_A(PGDCR)


	 ld	 a,0x01			; enable interrupts for port
;ioi ld	 (SECR),a
	IOWRITE_A(SECR)
	 ipres
	 ret

epkt_isr_enableport::
    ld	 a,(PGFRShadow)
    or	 EDRIVE_TXMASK              ; enable serial port D transmitter
    ld	 (PGFRShadow),a
;ioi ld	 (PGFR),a
	IOWRITE_A(PGFR)
	 call  pktEtx			;user defined asm routine
	 ld	 a, 0x01
	 ld	 (epkt_portenabled), a
	 ret

epkt_enableport::
	 ipset 1
	 call	 epkt_isr_enableport
	 ipres
	 ret

epkt_isr_disableport::
	 call	 epkt_disabledrive
	 call  pktErx		;user defined asm routine
	 ret

epkt_disableport::
	 ipset 1
	 call	 epkt_isr_disableport
	 ipres
	 ret

epkt_disabledrive::		;seperate call for longstops
	 ld	 a, (PGDRShadow)
	 or	 EDRIVE_TXMASK
	 ld	 (PGDRShadow), a
;ioi ld	 (PGDR), a
	IOWRITE_A(PGDR)
    ld	 a,(PGFRShadow)
    and	 ~EDRIVE_TXMASK              ; disable serial port D transmitter
    ld	 (PGFRShadow),a
;ioi ld	 (PGFR),a
	IOWRITE_A(PGFR)
	 xor	 a
	 ld	 (epkt_portenabled), a
	 ret

#endasm

#asm root

epkt_sendbyte::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (epkt_txcount)
	 ld	 hl, (epkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (epkt_txcount)
	 ld	 hl, (epkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (epkt_txcount), de	;increment txcount
	 ld	 a, (epkt_parity)
	 or	 a
	 jr	 z, .send8bit
	 dec	 a
	 jr	 z, .sendodd
	 dec	 a
	 jr	 z, .sendeven
	 jr	 .send9high		;2 stop bits, 9th bit always high

.sendeven:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity		;returns true if odd
	 bool	 hl
	 jr	 nz, .send9low		;byte is already even parity
	 jr	 .send9high
.sendodd:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .send9low	;byte is already odd parity
	 jr	 .send9high
.send8bit:
	 ld	 a, c
;ioi ld	 (SEDR), a
	IOWRITE_A(SEDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SEAR), a
	IOWRITE_A(SEAR)
	 jr	 .sendexit
.send9high:
	 ld	 a, c
;ioi ld	 (SELR), a
	IOWRITE_A(SELR)
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

epkt_send9bit::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (epkt_txcount)
	 ld	 hl, (epkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (epkt_txcount)
	 ld	 hl, (epkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (epkt_txcount), de	;increment txcount

	 ld	 a, (epkt_9bittype)
	 or	 a
	 jr	 z, .rabbitstart
	 dec	 a
	 jr	 z, .lowstart
.highstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9high
	 jr	 .send9low
.lowstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low	;if de <= 1
	 jr	 .send9high
.rabbitstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low
.send8bit:
	 ld	 a, c
;ioi ld	 (SEDR), a
	IOWRITE_A(SEDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SEAR), a
	IOWRITE_A(SEAR)
	 jr	 .sendexit
.send9high:
	 ld	 a, c
;ioi ld	 (SELR), a
	IOWRITE_A(SELR)
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

; assumes byte is stored in B, can trash other registers
epkt_recvbyte::

	 push	 ix
	 ld	 ix, (epkt_rxcurrent_ptr)
	 ld	 a, (epkt_rxcurrent_ptr + 2)
	 ldp	 hl, (ix)		;get length field
	 bool	 hl
	 jr	 nz, .no_buffer		;buffer is full
	 ld	 de, 2
	 add	 ix, de
	 adc	 a, 0					;carry if needed
	 ld	 de, (epkt_rxpos)
	 add	 ix, de
	 adc	 a, 0					;carry add into high bit
	 ldp	 hl, (ix)
	 ld	 L, b					;from ISR, b holds received byte
	 ldp	 (ix), hl
	 inc	 de					;de still holds rxpos
	 ld	 hl, (epkt_rxsize)
	 or	 a						;clear carry
	 sbc	 hl, de
	 jr	 z, .buffer_overflow
	 ld	 (epkt_rxpos), de
	 jr	 .recvdone

.no_buffer:
	 ld	 a, 0x01
	 ld	 (epkt_nobuffer), a
	 jr	 .recvdone

.buffer_overflow:
	 ld	 a, 0x01
	 ld	 (epkt_overflow), a
	 ld	 hl, 0
	 ld	 (epkt_rxpos), hl		;set pos to beginning of buffer
.recvdone:
	 pop	 ix
	 ret

#endasm

#asm root

epkt_finish::
	 push	 bc
	 push	 ix
	 ld	 hl, (epkt_rxpos)
	 bool	 hl
	 jr	 z, .done		;no packet
	 ld	 ix, (epkt_rxcurrent_ptr)
	 ld	 a, (epkt_rxcurrent_ptr + 2)
	 ld	 hl, (epkt_rxpos)		;load length into buffer
	 ldp	 (ix), hl
	 ld	 de, (epkt_rxcurrent)
	 inc	 de
	 ld	 hl, (epkt_rxcount)
	 or	 a		;clear carry
	 sbc	 hl, de
	 jr	 nz, .newbuffer
	 ld	 d, 0
	 ld	 e, 0					;zero out current buffer number
.newbuffer:
	 ld	 (epkt_rxcurrent), de
	 ld	 hl, (epkt_rxsize)
	 inc	 hl
	 inc	 hl					;add 2 to size for total buffer size
	 ld	 c, L
	 ld	 b, h
	 mul							;current * (size+2)
	 ld	 e, L					;high byte of result now in e
	 ld	 hl, (epkt_rxbuffers)		;base of buffer array
	 ld	 a, (epkt_rxbuffers + 2)
	 add	 hl, bc
	 adc	 a, e
	 ld	 (epkt_rxcurrent_ptr), hl	;set new current ptr
	 ld	 (epkt_rxcurrent_ptr + 2), a
	 bool	 hl
	 ld	 L, 0
	 ld	 (epkt_rxpos), hl			;zero out position
.done:
	 pop	 ix
	 pop	 bc
	 ret

#endasm

#asm root

epkt_nextdone::
	 ipset 1
	 ld	 hl, (epkt_rxnext)
	 ld	 de, (epkt_rxcurrent)
	 or	 a
	 sbc	 hl, de
	 jr	 nz, .done
	 call	 epkt_finish			;complete current packet
.done:
	 ipres
	 ret

#endasm

#asm root

;assumes byte is in B, SDSR snapshot is in C
epkt_paritytest::
	 ld	 a, (epkt_parity)
	 dec	 a
	 or	 a
	 jr	 z, .oddparity
.evenparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	hl
	 jr	 z, .check9high
	 jr	 .check9low

.oddparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .check9low
.check9high:
	 bit	 6, c
	 jr	 z, .paritydone
	 jr	 .setparityerror

.check9low:
	 bit	 6, c
	 jr	 nz, .paritydone
.setparityerror:
	 ld	 a, 0x01
	 ld	 (epkt_parityerror), a
.paritydone:
	 ret

#endasm

#asm root

epkt_gapisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SESR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SESR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SESR), a			;clear interrupt
	IOWRITE_A(SESR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (epkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 epkt_sendbyte		;try and send another byte,
	 									; with possible parity bit
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
										;handle gaps, transitions, etc.
	 ld	 a, (epkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 ;decide if we need to send a gap or data???
	 ld	 a, (epkt_txactive)	;are we transmitting?
	 or	 a
	 jr	 z, .isr_rxdummy		;dummy is for rx gap timing
	 ld	 a, (epkt_txdelay)
	 or	 a
	 jr	 nz, .isr_txdummy
	 call	 epkt_isr_enableport		;make sure we can send data
	 call	 epkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (epkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 epkt_isr_disableport
;ioi ld	 (SEDR), a				;load final dummy
	IOWRITE_A(SEDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:							;moved up to keep jump in range
;ioi ld	 a, (SEDR)			;read byte, clear interrupt
	IOREAD_A(SEDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_txdummy:						;dummy for tx delay
	 dec	 a
	 ld	 (epkt_txdelay), a
	 call	 epkt_isr_disableport
;ioi ld	 (SEDR), a				;load dummy
	IOWRITE_A(SEDR)
	 jr	 .isr_txdone

.isr_rxdummy:
	 ld	 a, (epkt_rxgapcount)
	 or	 a
	 jr	 z, .isr_rxendpacket		;a full gap was detected
	 dec	 a
	 ld	 (epkt_rxgapcount), a
;ioi ld	 (SEDR), a					;load dummy
	IOWRITE_A(SEDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (epkt_txdone), a
	 ld	 (epkt_txactive), a
	 jr	 .isr_txdone

.isr_rxendpacket:
	 call	 epkt_finish
	 jr	 .isr_txdone


.isr_rxchecktx:
	 ld	 a, (epkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcheckparity
	 ld	 a, 0x01
	 ld	 (epkt_rxoverrun), a
.isr_rxcheckparity:
	 ld	 a, (epkt_parity)
	 or	 a
	 jr	 z, .isr_rxcontinue		;next step
	 call  epkt_paritytest

.isr_rxcontinue:					;no defined start byte, just load it
	 ld	 a, (epkt_waitforgap)
	 or	 a
	 jr	 nz, .isr_rxresetgap		;waiting for a gap
	 call	 epkt_recvbyte
.isr_rxresetgap:
	 ld	 a, (epkt_rxgapsize)
	 ld	 (epkt_rxgapcount), a	;reset the gap counter
;ioi ld	 (SEDR), a					;send dummy byte for gap timing
	IOWRITE_A(SEDR)
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

epkt_9bitisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SESR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SESR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SESR), a			;clear interrupt
	IOWRITE_A(SESR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (epkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 epkt_send9bit			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (epkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 epkt_isr_enableport		;make sure we can send data
	 call	 epkt_send9bit			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (epkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 epkt_isr_disableport
;ioi ld	 (SEDR), a				;load final dummy
	IOWRITE_A(SEDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SEDR)			;read byte, clear interrupt
	IOREAD_A(SEDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_txfinish:
	 xor	 a
	 ld	 (epkt_txdone), a
	 ld	 (epkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (epkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (epkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (epkt_9bittype)
	 or	 a							;zero test A
	 jr	 z, .isr_rxchecklowstart
	 dec	 a
	 jr	 z, .isr_rxchecklowstart
.isr_rxcheckhighstart:
	 bit	 6, c
	 jr	 z, .isr_rxstart
	 jr	 .isr_rxnotstart
.isr_rxchecklowstart:
	 bit	 6, c
	 jr	 nz, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (epkt_rxpos)
	 bool	 hl
	 jr	 nz, .isr_rxload		;we are in the middle of a packet
	 jr	 .isr_rxdone
.isr_rxload:
	 call	 epkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call	 epkt_finish
	 call	 epkt_recvbyte

.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

epkt_charisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SESR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SESR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SESR), a			;clear interrupt
	IOWRITE_A(SESR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (epkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (epkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 epkt_sendbyte			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (epkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 epkt_isr_enableport		;make sure we can send data
	 call	 epkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (epkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 epkt_isr_disableport
;ioi ld	 (SEDR), a				;load final dummy
	IOWRITE_A(SEDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SEDR)			;read byte, clear interrupt
	IOREAD_A(SEDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_txfinish:
	 xor	 a
	 ld	 (epkt_txdone), a
	 ld	 (epkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (epkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (epkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (epkt_startchar)
	 cp	 b
	 jr	 z, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (epkt_rxpos)
	 bool	 hl
	 jr	 z, .isr_rxdone		;keep waiting for a start byte
.isr_rxload:
	 call	 epkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call epkt_finish
	 call	 epkt_recvbyte
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

/*** BeginHeader pktEsetParity */
void pktEsetParity(char mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktEsetParity                   <PACKET.LIB>

SYNTAX:		   void pktEsetParity(char mode);

DESCRIPTION:   Configures parity generation and checking
					Can also configure for 2 stop bits.

PARAMETER1:		Code for mode of parity bit
					PKT_NOPARITY - no parity bit (8N1 format, default)
					PKT_OPARITY 1 - odd parity (8O1 format)
					PKT_EPARITY 2 - even parity (8E1 format)
					PKT_TWOSTOP 3 - an extra stop bit (8N2 format)

END DESCRIPTION **********************************************************/

nodebug void pktEsetParity(char mode)
{
	epkt_parity = mode;
}

/*** BeginHeader pktEsending */
int pktEsending();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktEsending                   <PACKET.LIB>

SYNTAX:		   int pktEsending();

DESCRIPTION:   Tests if a packet is currently being sent. If this returns
					true, the transmitter is bus and cannot accept another packet.

RETURN VALUE:	1: A packet is being transmitted on port E
               0: port E is idle, ready for a new packet

END DESCRIPTION **********************************************************/

nodebug int pktEsending()
{
	return (int)epkt_txactive;
}

/*** BeginHeader pktEsend */
int pktEsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktEsend                   <PACKET.LIB>

SYNTAX:		   int pktEsend(void *send_buffer,
									 int buffer_length,
									 char delay);

DESCRIPTION:   Initiates the sending of a packet of data. This function will
					always return immediately. If there is already a packet being
					transmitted, this call will return 0 and the packet will not be
					transmitted, otherwise it will return 1.
					The pktEsending() function is used to check
					if the packet is done transmitting. The system will be using the
					buffer until then.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

RETURN VALUE:	1 if the packet is goint to be transmitted
					0 if there is already a packet transmitting, and the new packet
						was refused.

END DESCRIPTION **********************************************************/

nodebug int pktEsend(void *send_buffer, int buffer_length, char delay)
{
	//loop until tx is ready
	if (pktEsending())
	{
		return 0;
	}
	else
	{
		epkt_txframe = send_buffer;
		epkt_txsize = buffer_length;
		epkt_txcount = 0;
		epkt_txdelay = delay;
		epkt_txactive = 1;				//set active flag
		if(delay)
		{
			epkt_disableport();
			WrPortI(SEDR, NULL, 23);		//send a dummy character to start
		}
		else
		{
			epkt_enableport();
			if(epkt_type == PKT_9BITMODE)
			{
				epkt_send9bit();
			}
			else
			{
				epkt_sendbyte();
			}
		}
		return 1;
	}
}

/*** BeginHeader cof_pktEsend */
scofunc void cof_pktEsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktEsend                   <PACKET.LIB>

SYNTAX:		   void cof_pktEsend(void *send_buffer,
									  		int buffer_length,
									  		char delay);

DESCRIPTION:   Cofunction version of pktEsend(). This function will yield
					to other tasks while the packet is being sent. It differs from
					pktEsend() in that it will not return until the packet is
					done transmitting.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_pktEsend(void *send_buffer,
											 int buffer_length,
											 char delay)
{
	//wait until tx is ready
	while (pktEsending()) yield;

	epkt_txframe = send_buffer;
	epkt_txsize = buffer_length;
	epkt_txcount = 0;
	epkt_txdelay = delay;
	epkt_txactive = 1;				//set active flag
	if(delay)
	{
		epkt_disableport();
		WrPortI(SEDR, NULL, 23);		//send a dummy character to start
	}
	else
	{
		epkt_enableport();
		if(epkt_type == PKT_9BITMODE)
		{
			epkt_send9bit();
		}
		else
		{
			epkt_sendbyte();
		}
	}
	while (pktEsending()) yield;	//wait for this packet to finish
}

/*** BeginHeader pktEreceive */
int pktEreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktEreceive                   <PACKET.LIB>

SYNTAX:		   int pktEreceive(void *buffer, int buffer_size);

DESCRIPTION:   Gets a received packet if there is one in the packet buffer.
					Otherwise, it will immediately return 0.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE: >0: The number of bytes in the received packet.
				  0: indicates that no new packets have been received.
				  -1: indicates that the packet is too large for the given buffer
				  -2: if a needed test_packet function is not defined

END DESCRIPTION **********************************************************/

nodebug int pktEreceive(void *buffer, int buffer_size)
{
	auto int rxpos;
	auto int packet_length;
	auto int buffer_offset;
	auto int temp;

	rxpos = epkt_rxpos;
	buffer_offset = epkt_rxnext*(epkt_rxsize+2);
	xmem2root(&packet_length, epkt_rxbuffers + buffer_offset, 2);
	if(packet_length)
	{
		//packet is definitely done
		if(packet_length <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, epkt_rxbuffers + buffer_offset + 2, packet_length);
			temp = 0;
			root2xmem(epkt_rxbuffers + buffer_offset, &temp, 2); //clear out
			epkt_rxnext = (epkt_rxnext + 1) % epkt_rxcount;
			epkt_lastpos = 0;
			return packet_length;
		}
		else
		{
			return -1;
		}
	}
	else if(epkt_type != PKT_GAPMODE && rxpos != epkt_lastpos)
	{
		if (epkt_testpacket == NULL)
		{
			return -2;
		}
		//check for complete packet
		if(rxpos <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, epkt_rxbuffers + buffer_offset + 2, rxpos);
			if ( (*epkt_testpacket)(buffer, rxpos) )
			{
				epkt_nextdone(); //complete packet
				temp = 0;
				root2xmem(epkt_rxbuffers + buffer_offset, &temp, 2); //clear out
				epkt_rxnext = (epkt_rxnext + 1) % epkt_rxcount;
				epkt_lastpos = 0;
				return rxpos;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return 0;
	}
}

/*** BeginHeader cof_pktEreceive */
scofunc int cof_pktEreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktEreceive                   <PACKET.LIB>

SYNTAX:		   int cof_pktEreceive(void *buffer, int buffer_size);

DESCRIPTION:   This cofunction is used to listen for received packets.
					It will return with a packet immediately if there is one in
					in the buffer. Otherwise, it will wait for one while yielding
					to other tasks.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE:	The length of the received packet or an error code
					identical to those in pktEreceive()

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_pktEreceive(void *buffer, int buffer_size)
{
	auto int length;
	while((length = pktEreceive(buffer, buffer_size)) == 0)
	{
		yield;
	}
	return length;
}


/*** BeginHeader pktEgetErrors */
char pktEgetErrors();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktEgetErrors                   <PACKET.LIB>

SYNTAX:		   char pktEgetErrors();

DESCRIPTION:   Gets a bit field with flags set for any errors that occured.
					These flags are then cleared, so that a particular error
					will only cause the flag to be set once.

RETURN VALUE:	A bit field with flags for various errors. The errors
					along with their bit masks are as follows:
						PKT_BUFFEROVERFLOW 0x01
						PKT_RXOVERRUN 0x02
						PKT_PARITYERROR 0x04
						PKT_NOBUFFER 0x08

END DESCRIPTION **********************************************************/

nodebug char pktEgetErrors()
{
	auto char error_flags;

	error_flags = 0;
	if (epkt_overflow) {
		error_flags |= PKT_BUFFEROVERFLOW;
		epkt_overflow = 0;		//clear the error after reporting it
	}
	if (epkt_rxoverrun) {
		error_flags |= PKT_RXOVERRUN;
		epkt_rxoverrun = 0;
	}
	if (epkt_parityerror) {
		error_flags |= PKT_PARITYERROR;
		epkt_parityerror = 0;
	}
	if (epkt_nobuffer) {
		error_flags |= PKT_NOBUFFER;
		epkt_nobuffer = 0;
	}
	return error_flags;
}


//************************************************************************
//****************************** PORT F **********************************
//************************************************************************


/*** Beginheader pktFopen, pktFclose, pktFinitBuffers, fpkt_nextdone */
int pktFopen(long baud, int mode, char options, int (*test_packet)());
root void pktFclose();
int pktFinitBuffers(int buf_count, int buf_size);
void fpkt_nextdone();

int fpkt_sendbyte();
void fpkt_enableport();
void fpkt_disableport();

extern unsigned long fpkt_rxbuffers;
extern int fpkt_rxcount;
extern int fpkt_rxsize;
extern int fpkt_rxpos;
extern int fpkt_rxnext;		//next buffer to be read out
extern int fpkt_rxcurrent;	//buffer being written to
extern unsigned long fpkt_rxcurrent_ptr; //temp pointer to start of current buffer

extern int fpkt_lastpos;
extern char *fpkt_txframe;
extern int fpkt_txcount;
extern int fpkt_txsize;
extern char fpkt_type;
extern char fpkt_parity;
extern char fpkt_rxgapcount;
extern char fpkt_rxgapsize;
extern char fpkt_txdelay;
extern char fpkt_startchar;
extern char fpkt_txdone;
extern char fpkt_9bittype;
extern char fpkt_divisor;
extern char fpkt_fastdivisor;
extern char fpkt_longstop;
extern char fpkt_portenabled;
//pointer to function that tests for complete packets
extern int (*fpkt_testpacket)(); //takes (void *, int) as args
extern char fpkt_txactive;
extern char fpkt_waitforgap;

//errors
extern char fpkt_parityerror;
extern char fpkt_rxoverrun;
extern char fpkt_overflow;
extern char fpkt_nobuffer;

/*** endheader */

unsigned long fpkt_rxbuffers;
int fpkt_rxcount;
int fpkt_rxsize;
int fpkt_rxpos;
int fpkt_rxnext;		//next buffer to be read out
int fpkt_rxcurrent;	//buffer being written to
unsigned long fpkt_rxcurrent_ptr; //temp pointer to start of current buffer

int fpkt_lastpos;
char *fpkt_txframe;
int fpkt_txcount;
int fpkt_txsize;
char fpkt_type;
char fpkt_parity;
char fpkt_rxgapcount;
char fpkt_rxgapsize;
char fpkt_txdelay;
char fpkt_startchar;
char fpkt_txdone;
char fpkt_9bittype;
char fpkt_divisor;
char fpkt_fastdivisor;
char fpkt_longstop;
char fpkt_portenabled;
//pointer to function that tests for complete packets
int (*fpkt_testpacket)(); //takes (void *, int) as args
char fpkt_txactive;
char fpkt_waitforgap;

//errors
char fpkt_parityerror;
char fpkt_rxoverrun;
char fpkt_overflow;
char fpkt_nobuffer;

extern void pktFinit();
extern void pktFrx();
extern void pktFtx();

#define FDRIVE_TXMASK 0x04


//internal functions
void fpkt_init( void (*isr)() );
void fpkt_gapisr();
void fpkt_9bitisr();
void fpkt_charisr();

/* START FUNCTION DESCRIPTION ********************************************
pktFopen                   <PACKET.LIB>

SYNTAX:		   int pktFopen(long baud,
									 int mode,
									 char options,
									 int (*test_packet)() );

DESCRIPTION:   Opens the F serial port.

PARAMETER1:    Bits per second of data transfer: min 2400

PARAMETER2:		mode - type of packet scheme used, options are:
						PKT_GAPMODE
						PKT_9BITMODE
						PKT_CHARMODE

PARAMETER3:		options - further specification for the packet scheme
						The value of this depends on the mode used.
						gap mode - minimum gap size(in byte times)
						9bit mode - type of 9bit protocol
							PKT_RABBITSTARTBYTE
							PKT_LOWSTARTBYTE
							PKT_HIGHSTARTBYTE
						char mode - character marking start of packet

PARAMETER4:		ptr to function that tests for completeness of a packet. The
					function should return 1 if the packet is complete, or 0 if
					more data should be read in. For gap mode the test function is
					not used and should be set to NULL.

RETURN VALUE:	1: The baud set on the rabbit is the same as the input baud
               0: The baud set on the rabbit does not match the input baud

END DESCRIPTION **********************************************************/

nodebug int pktFopen(long baud, int mode, char options, int (*test_packet)())
{
   auto long divisor, ta1div;
	auto float baud_ratio;
	auto unsigned long t;
	auto int temp, i;

   fpkt_type = mode;
   fpkt_parity = 0;
	fpkt_txactive = 0;
	fpkt_txdone = 0;
	fpkt_waitforgap = 0;
	fpkt_longstop = 0;
	fpkt_rxgapcount = 0;
	fpkt_lastpos = 0;

	fpkt_parityerror = 0;
	fpkt_rxoverrun = 0;
	fpkt_overflow = 0;
	fpkt_nobuffer = 0;

	fpkt_rxcurrent = 0;
	fpkt_rxcurrent_ptr = fpkt_rxbuffers; //first buffer
	fpkt_rxpos = 0;
	fpkt_rxnext = 0;
	//initialize the buffers
	temp = 0;
	for(i = 0;i < fpkt_rxcount;i++)
	{
		root2xmem(fpkt_rxbuffers + i*(fpkt_rxsize + 2), &temp, 2);
	}


	fpkt_testpacket = test_packet;

   if (baud < 1) baud = 1;
   // (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"

	ta1div = 0;
	// (divisor+1) for 19200 baud is stored in BIOS variable "freq_divider"
	divisor = (long)(freq_divider * 19200.0/(float)baud + 0.5) - 1L;
	while ((divisor / (1L + ta1div)) > 255L && ta1div < 255L)
	{
		++ta1div;
	}

	if (ta1div)
	{
		divisor /= (1L + ta1div);
   	WrPortI(TAT1R, &TAT1RShadow, (char)ta1div);
   	BitWrPortI(TACR, &TACRShadow, 1, 3);
	}
	else
	{
		BitWrPortI(TACR, &TACRShadow, 0, 3);
	}
	WrPortI(TAT3R, &TAT3RShadow, (char)divisor);

	//set up mode and options
	if (mode == PKT_GAPMODE)
	{
		fpkt_rxgapsize = options;
   	fpkt_init(fpkt_gapisr);
   }
   else if (mode == PKT_9BITMODE)
   {
   	fpkt_9bittype = options;
   	fpkt_init(fpkt_9bitisr);
	}
	else
	{
		fpkt_startchar = options;
		fpkt_init(fpkt_charisr);
	}
   fpkt_divisor = (char)divisor;
   fpkt_fastdivisor = (char)divisor / 8;
   if (fpkt_fastdivisor < 1) fpkt_fastdivisor = 1;

   // let baud timer time out before using port
   t = MS_TIMER;
   while (MS_TIMER - t < 1000 / (baud / 10)) ;

   pktFinit();
   fpkt_disableport();
   return (((long)((BASEFREQ*freq_divider) /
   	(32 * (divisor + 1)) + 0.5)) == baud);    // rounded baud actually used
}

/* START FUNCTION DESCRIPTION ********************************************
pktFinitBuffers                   <PACKET.LIB>

SYNTAX:		   int pktFinitBuffers(int buf_count, int buf_size);

DESCRIPTION:   Allocates extended memory for the channel F receive buffers.
					This function should not be called more than once in a program.
					The total memory allocated is count*(size + 2) bytes

PARAMETER1:    buf_count - the number of buffers to allocate. Each buffer can
					store one received packet. Increasing this number allows for
					more pending packets and a larger latency time before packets
					must be processed by the user's program.

PARAMETER2:		buf_size - the number of bytes each buffer can accomodate. This
					should be set to the size of the largest possible packet
					that can be expected.

RETURN VALUE:	1: The xmem allocation was successful
               0: The allocation failed. This packet channel cannot be used.

END DESCRIPTION **********************************************************/

nodebug int pktFinitBuffers(int buf_count, int buf_size)
{
	fpkt_rxcount = buf_count;
	if(buf_size % 2)
	{
		buf_size++;   //make sure buffer sizes are even
	}
	fpkt_rxsize = buf_size;
	fpkt_rxbuffers = xalloc(buf_count*(buf_size+2)+2);
	if(fpkt_rxbuffers % 2)
	{
		fpkt_rxbuffers++;		//make sure buffers start on even boundaries
	}
	if(!fpkt_rxbuffers)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}


/* START FUNCTION DESCRIPTION ********************************************
pktFclose                   <PACKET.LIB>

SYNTAX:		   void pktFclose();

DESCRIPTION:   Disables the F serial port.

PARAMETER1:    None

RETURN VALUE:	None

END DESCRIPTION **********************************************************/

#if _USER
#asm root
pktFclosed::
	ret
#endasm
#endif

#asm root
pktFclose::
#if _USER
c	 SetVectIntern(SERF_OFS/0x10, pktFclosed);
#else
	 ld	 a,0xc9         ; ret in first byte
	 ipset 1
	 ld	 (INTVEC_BASE + SERF_OFS),a
#endif

	 ld	 a, 0x00
;ioi ld	 (SFCR),a
	IOWRITE_A(SFCR)
	 ipres
	 ret

;
; fpkt_init
;

fpkt_init::
#if _USER
	push	hl
   ld		hl,SERF_OFS/0x10
   push	hl
   call  SetVectIntern
   add	sp,2
#else
	 ld	 iy, INTVEC_BASE + SERF_OFS
	 ipset 1
	 ld	 (iy), 0C3h			; the JP command
	 ld	 (iy+1), hl			; ISR for a particular mode
#endif

	 call	 fpkt_isr_disableport

	 //set pin to output
	 ld	 a, (PGDDRShadow)
	 or	 a, FDRIVE_TXMASK
	 ld	 (PGDDRShadow), a
;ioi ld	 (PGDDR), a
	IOWRITE_A(PGDDR)
	 ld	 a, (PGDCRShadow)
	 and	 a, ~FDRIVE_TXMASK
	 ld	 (PGDCRShadow), a
;ioi ld	 (PGDCR), a				;set to push-pull output
	IOWRITE_A(PGDCR)

	 ld	 a,0x01			; enable interrupts for port
;ioi ld	 (SFCR),a
	IOWRITE_A(SFCR)
	 ipres
	 ret

fpkt_isr_enableport::
    ld	 a,(PGFRShadow)
    or	 FDRIVE_TXMASK              ; enable serial port D transmitter
    ld	 (PGFRShadow),a
;ioi ld	 (PGFR),a
	IOWRITE_A(PGFR)
	 call  pktFtx			;user defined asm routine
	 ld	 a, 0x01
	 ld	 (fpkt_portenabled), a
	 ret

fpkt_enableport::
	 ipset 1
	 call	 fpkt_isr_enableport
	 ipres
	 ret

fpkt_isr_disableport::
	 call	 fpkt_disabledrive
	 call  pktFrx		;user defined asm routine
	 ret

fpkt_disableport::
	 ipset 1
	 call	 fpkt_isr_disableport
	 ipres
	 ret

fpkt_disabledrive::		;seperate call for longstops
	 ld	 a, (PGDRShadow)
	 or	 FDRIVE_TXMASK
	 ld	 (PGDRShadow), a
;ioi ld	 (PGDR), a
	IOWRITE_A(PGDR)
    ld	 a,(PGFRShadow)
    and	 ~FDRIVE_TXMASK              ; disable serial port D transmitter
    ld	 (PGFRShadow),a
;ioi ld	 (PGFR),a
	IOWRITE_A(PGFR)
	 xor	 a
	 ld	 (fpkt_portenabled), a
	 ret

#endasm

#asm root

fpkt_sendbyte::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (fpkt_txcount)
	 ld	 hl, (fpkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (fpkt_txcount)
	 ld	 hl, (fpkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (fpkt_txcount), de	;increment txcount
	 ld	 a, (fpkt_parity)
	 or	 a
	 jr	 z, .send8bit
	 dec	 a
	 jr	 z, .sendodd
	 dec	 a
	 jr	 z, .sendeven
	 jr	 .send9high		;2 stop bits, 9th bit always high

.sendeven:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity		;returns true if odd
	 bool	 hl
	 jr	 nz, .send9low		;byte is already even parity
	 jr	 .send9high
.sendodd:
	 bool	 hl
	 ld	 L, c
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .send9low	;byte is already odd parity
	 jr	 .send9high
.send8bit:
	 ld	 a, c
;ioi ld	 (SFDR), a
	IOWRITE_A(SFDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SFAR), a
	IOWRITE_A(SFAR)
	 jr	 .sendexit
.send9high:
	 ld	 a, c
;ioi ld	 (SFLR), a
	IOWRITE_A(SFLR)
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

fpkt_send9bit::		;returns boolean in HL, 1 if a byte was sent
	 ;check to see if there is a byte available
	 ld	 de, (fpkt_txcount)
	 ld	 hl, (fpkt_txsize)
	 or	 a							;clear carry
	 sbc	 hl, de
	 jr	 nz, .sendcontinue
	 bool	 hl
	 xor	 a
	 ld	 L, a	;zero out hl
	 ret

.sendcontinue:
	 ;stash the byte in c
	 ld	 de, (fpkt_txcount)
	 ld	 hl, (fpkt_txframe)
	 add	 hl, de					;HL points to next byte to send
	 ld	 a, (hl)
	 ld	 c, a						;stash byte in C
	 inc	 de
	 ld	 (fpkt_txcount), de	;increment txcount

	 ld	 a, (fpkt_9bittype)
	 or	 a
	 jr	 z, .rabbitstart
	 dec	 a
	 jr	 z, .lowstart
.highstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9high
	 jr	 .send9low
.lowstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low	;if de <= 1
	 jr	 .send9high
.rabbitstart:
	 or	 a					;clear carry
	 rr	 de				;de should still contain rxcount
	 jr	 z, .send9low
.send8bit:
	 ld	 a, c
;ioi ld	 (SFDR), a
	IOWRITE_A(SFDR)
	 jr	 .sendexit
.send9low:
	 ld	 a, c
;ioi ld	 (SFAR), a
	IOWRITE_A(SFAR)
	 jr	 .sendexit
.send9high:
	 ld	 a, c
;ioi ld	 (SFLR), a
	IOWRITE_A(SFLR)
.sendexit:
	 bool	 hl
	 ld	 a, 0x01
	 ld	 L, a			;set HL to 1
	 ret

#endasm

#asm root

; assumes byte is stored in B, can trash other registers
fpkt_recvbyte::

	 push	 ix
	 ld	 ix, (fpkt_rxcurrent_ptr)
	 ld	 a, (fpkt_rxcurrent_ptr + 2)
	 ldp	 hl, (ix)		;get length field
	 bool	 hl
	 jr	 nz, .no_buffer		;buffer is full
	 ld	 de, 2
	 add	 ix, de
	 adc	 a, 0					;carry if needed
	 ld	 de, (fpkt_rxpos)
	 add	 ix, de
	 adc	 a, 0					;carry add into high bit
	 ldp	 hl, (ix)
	 ld	 L, b					;from ISR, b holds received byte
	 ldp	 (ix), hl
	 inc	 de					;de still holds rxpos
	 ld	 hl, (fpkt_rxsize)
	 or	 a						;clear carry
	 sbc	 hl, de
	 jr	 z, .buffer_overflow
	 ld	 (fpkt_rxpos), de
	 jr	 .recvdone

.no_buffer:
	 ld	 a, 0x01
	 ld	 (fpkt_nobuffer), a
	 jr	 .recvdone

.buffer_overflow:
	 ld	 a, 0x01
	 ld	 (fpkt_overflow), a
	 ld	 hl, 0
	 ld	 (fpkt_rxpos), hl		;set pos to beginning of buffer
.recvdone:
	 pop	 ix
	 ret

#endasm

#asm root

fpkt_finish::
	 push	 bc
	 push	 ix
	 ld	 hl, (fpkt_rxpos)
	 bool	 hl
	 jr	 z, .done		;no packet
	 ld	 ix, (fpkt_rxcurrent_ptr)
	 ld	 a, (fpkt_rxcurrent_ptr + 2)
	 ld	 hl, (fpkt_rxpos)		;load length into buffer
	 ldp	 (ix), hl
	 ld	 de, (fpkt_rxcurrent)
	 inc	 de
	 ld	 hl, (fpkt_rxcount)
	 or	 a		;clear carry
	 sbc	 hl, de
	 jr	 nz, .newbuffer
	 ld	 d, 0
	 ld	 e, 0					;zero out current buffer number
.newbuffer:
	 ld	 (fpkt_rxcurrent), de
	 ld	 hl, (fpkt_rxsize)
	 inc	 hl
	 inc	 hl					;add 2 to size for total buffer size
	 ld	 c, L
	 ld	 b, h
	 mul							;current * (size+2)
	 ld	 e, L					;high byte of result now in e
	 ld	 hl, (fpkt_rxbuffers)		;base of buffer array
	 ld	 a, (fpkt_rxbuffers + 2)
	 add	 hl, bc
	 adc	 a, e
	 ld	 (fpkt_rxcurrent_ptr), hl	;set new current ptr
	 ld	 (fpkt_rxcurrent_ptr + 2), a
	 bool	 hl
	 ld	 L, 0
	 ld	 (fpkt_rxpos), hl			;zero out position
.done:
	 pop	 ix
	 pop	 bc
	 ret

#endasm

#asm root

fpkt_nextdone::
	 ipset 1
	 ld	 hl, (fpkt_rxnext)
	 ld	 de, (fpkt_rxcurrent)
	 or	 a
	 sbc	 hl, de
	 jr	 nz, .done
	 call	 fpkt_finish			;complete current packet
.done:
	 ipres
	 ret

#endasm

#asm root

;assumes byte is in B, SDSR snapshot is in C
fpkt_paritytest::
	 ld	 a, (fpkt_parity)
	 dec	 a
	 or	 a
	 jr	 z, .oddparity
.evenparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	hl
	 jr	 z, .check9high
	 jr	 .check9low

.oddparity:
	 bool	 hl
	 ld	 L, b
	 call	 pkt_checkparity
	 bool	 hl
	 jr	 z, .check9low
.check9high:
	 bit	 6, c
	 jr	 z, .paritydone
	 jr	 .setparityerror

.check9low:
	 bit	 6, c
	 jr	 nz, .paritydone
.setparityerror:
	 ld	 a, 0x01
	 ld	 (fpkt_parityerror), a
.paritydone:
	 ret

#endasm

#asm root

fpkt_gapisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SFSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SFSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SFSR), a			;clear interrupt
	IOWRITE_A(SFSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (fpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 fpkt_sendbyte		;try and send another byte,
	 									; with possible parity bit
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
										;handle gaps, transitions, etc.
	 ld	 a, (fpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 ;decide if we need to send a gap or data???
	 ld	 a, (fpkt_txactive)	;are we transmitting?
	 or	 a
	 jr	 z, .isr_rxdummy		;dummy is for rx gap timing
	 ld	 a, (fpkt_txdelay)
	 or	 a
	 jr	 nz, .isr_txdummy
	 call	 fpkt_isr_enableport		;make sure we can send data
	 call	 fpkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (fpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 fpkt_isr_disableport
;ioi ld	 (SFDR), a				;load final dummy
	IOWRITE_A(SFDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:							;moved up to keep jump in range
;ioi ld	 a, (SFDR)			;read byte, clear interrupt
	IOREAD_A(SFDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_txdummy:						;dummy for tx delay
	 dec	 a
	 ld	 (fpkt_txdelay), a
	 call	 fpkt_isr_disableport
;ioi ld	 (SFDR), a				;load dummy
	IOWRITE_A(SFDR)
	 jr	 .isr_txdone

.isr_rxdummy:
	 ld	 a, (fpkt_rxgapcount)
	 or	 a
	 jr	 z, .isr_rxendpacket		;a full gap was detected
	 dec	 a
	 ld	 (fpkt_rxgapcount), a
;ioi ld	 (SFDR), a					;load dummy
	IOWRITE_A(SFDR)
	 jr	 .isr_txdone

.isr_txfinish:
	 xor	 a
	 ld	 (fpkt_txdone), a
	 ld	 (fpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxendpacket:
	 call	 fpkt_finish
	 jr	 .isr_txdone


.isr_rxchecktx:
	 ld	 a, (fpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcheckparity
	 ld	 a, 0x01
	 ld	 (fpkt_rxoverrun), a
.isr_rxcheckparity:
	 ld	 a, (fpkt_parity)
	 or	 a
	 jr	 z, .isr_rxcontinue		;next step
	 call  fpkt_paritytest

.isr_rxcontinue:					;no defined start byte, just load it
	 ld	 a, (fpkt_waitforgap)
	 or	 a
	 jr	 nz, .isr_rxresetgap		;waiting for a gap
	 call	 fpkt_recvbyte
.isr_rxresetgap:
	 ld	 a, (fpkt_rxgapsize)
	 ld	 (fpkt_rxgapcount), a	;reset the gap counter
;ioi ld	 (SFDR), a					;send dummy byte for gap timing
	IOWRITE_A(SFDR)
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

fpkt_9bitisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SFSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SFSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SFSR), a			;clear interrupt
	IOWRITE_A(SFSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (fpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 fpkt_send9bit			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (fpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 fpkt_isr_enableport		;make sure we can send data
	 call	 fpkt_send9bit			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (fpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 fpkt_isr_disableport
;ioi ld	 (SFDR), a				;load final dummy
	IOWRITE_A(SFDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SFDR)			;read byte, clear interrupt
	IOREAD_A(SFDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_txfinish:
	 xor	 a
	 ld	 (fpkt_txdone), a
	 ld	 (fpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (fpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (fpkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (fpkt_9bittype)
	 or	 a							;zero test A
	 jr	 z, .isr_rxchecklowstart
	 dec	 a
	 jr	 z, .isr_rxchecklowstart
.isr_rxcheckhighstart:
	 bit	 6, c
	 jr	 z, .isr_rxstart
	 jr	 .isr_rxnotstart
.isr_rxchecklowstart:
	 bit	 6, c
	 jr	 nz, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (fpkt_rxpos)
	 bool	 hl
	 jr	 nz, .isr_rxload		;we are in the middle of a packet
	 jr	 .isr_rxdone
.isr_rxload:
	 call	 fpkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call	 fpkt_finish
	 call	 fpkt_recvbyte

.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

#asm root

fpkt_charisr::
    push	 af              ; save registers needed by isr
    push	 bc              ;
	 push	 de
	 push	 hl

;ioi ld	 a,(SFSR)        ; interrupt source rx or tx (in or out)
	IOREAD_A(SFSR)
    ld	 c,a             ;
    rla                    ;
    jr	 c,.isr_rx        ;
.isr_tx:                   ; stopbit left data register or tx idle
;ioi ld	 (SFSR), a			;clear interrupt
	IOWRITE_A(SFSR)
	 bit	 2, c					; see if tx is busy
	 jr	 z, .isr_txidle
.isr_txbusy:
	 ld	 a, (fpkt_longstop)		;check if we need a longstop
	 or	 a
	 jr	 nz, .isr_txdone				;wait for txidle to put in longstop
	 ld	 a, (fpkt_portenabled)		;check if we are sending real data
	 or	 a
	 jr	 z, .isr_txdone
.isr_sendingdata:
	 call	 fpkt_sendbyte			;try and send another byte
	 jr	 .isr_txdone

.isr_txidle:							;nothing is being transmitted at the moment
	 ld	 a, (fpkt_txdone)
	 or	 a
	 jr	 nz, .isr_txfinish
	 call	 fpkt_isr_enableport		;make sure we can send data
	 call	 fpkt_sendbyte			;no delay, so send some data if we have it
	 bool	 hl
	 jr	 nz, .isr_txdone			;was a byte actually sent?
	 ld	 a, 0x01
	 ld	 (fpkt_txdone), a		;signal that we are done with packet
	 									;send one more dummy to avoid race with rx
	 call	 fpkt_isr_disableport
;ioi ld	 (SFDR), a				;load final dummy
	IOWRITE_A(SFDR)
.isr_txdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

.isr_rx:
;ioi ld	 a, (SFDR)			;read byte, clear interrupt
	IOREAD_A(SFDR)
	 ld	 b, a
	 jr	 .isr_rxchecktx		;see if transmitter is active

.isr_txfinish:
	 xor	 a
	 ld	 (fpkt_txdone), a
	 ld	 (fpkt_txactive), a
	 jr	 .isr_txdone

.isr_rxchecktx:
	 ld	 a, (fpkt_txactive)
	 or	 a
	 jr	 nz, .isr_rxdone		;transmitter is active
	 ;do overrun check
	 bit	 5, c
	 jr	 z, .isr_rxcontinue
	 ld	 a, 0x01
	 ld	 (fpkt_rxoverrun), a

.isr_rxcontinue:					;no defined start byte, just load it
	 ;check for start byte
	 ld	 a, (fpkt_startchar)
	 cp	 b
	 jr	 z, .isr_rxstart
.isr_rxnotstart:
	 ld	 hl, (fpkt_rxpos)
	 bool	 hl
	 jr	 z, .isr_rxdone		;keep waiting for a start byte
.isr_rxload:
	 call	 fpkt_recvbyte
	 jr	 .isr_rxdone

.isr_rxstart:
	 call fpkt_finish
	 call	 fpkt_recvbyte
.isr_rxdone:
	 ipres
	 pop	 hl
	 pop	 de
	 pop	 bc
	 pop	 af
	 ret

#endasm

/*** BeginHeader pktFsetParity */
void pktFsetParity(char mode);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktFsetParity                   <PACKET.LIB>

SYNTAX:		   void pktFsetParity(char mode);

DESCRIPTION:   Configures parity generation and checking
					Can also configure for 2 stop bits.

PARAMETER1:		Code for mode of parity bit
					PKT_NOPARITY - no parity bit (8N1 format, default)
					PKT_OPARITY 1 - odd parity (8O1 format)
					PKT_EPARITY 2 - even parity (8E1 format)
					PKT_TWOSTOP 3 - an extra stop bit (8N2 format)

END DESCRIPTION **********************************************************/

nodebug void pktFsetParity(char mode)
{
	fpkt_parity = mode;
}

/*** BeginHeader pktFsending */
int pktFsending();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktFsending                   <PACKET.LIB>

SYNTAX:		   int pktFsending();

DESCRIPTION:   Tests if a packet is currently being sent. If this returns
					true, the transmitter is bus and cannot accept another packet.

RETURN VALUE:	1: A packet is being transmitted on port F
               0: port F is idle, ready for a new packet

END DESCRIPTION **********************************************************/

nodebug int pktFsending()
{
	return (int)fpkt_txactive;
}

/*** BeginHeader pktFsend */
int pktFsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktFsend                   <PACKET.LIB>

SYNTAX:		   int pktFsend(void *send_buffer,
									 int buffer_length,
									 char delay);

DESCRIPTION:   Initiates the sending of a packet of data. This function will
					always return immediately. If there is already a packet being
					transmitted, this call will return 0 and the packet will not be
					transmitted, otherwise it will return 1.
					The pktFsending() function is used to check
					if the packet is done transmitting. The system will be using the
					buffer until then.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

RETURN VALUE:	1 if the packet is goint to be transmitted
					0 if there is already a packet transmitting, and the new packet
						was refused.

END DESCRIPTION **********************************************************/

nodebug int pktFsend(void *send_buffer, int buffer_length, char delay)
{
	//loop until tx is ready
	if (pktFsending())
	{
		return 0;
	}
	else
	{
		fpkt_txframe = send_buffer;
		fpkt_txsize = buffer_length;
		fpkt_txcount = 0;
		fpkt_txdelay = delay;
		fpkt_txactive = 1;				//set active flag
		if(delay)
		{
			fpkt_disableport();
			WrPortI(SFDR, NULL, 23);		//send a dummy character to start
		}
		else
		{
			fpkt_enableport();
			if(fpkt_type == PKT_9BITMODE)
			{
				fpkt_send9bit();
			}
			else
			{
				fpkt_sendbyte();
			}
		}
		return 1;
	}
}

/*** BeginHeader cof_pktFsend */
scofunc void cof_pktFsend(void *send_buffer, int buffer_length, char delay);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktFsend                   <PACKET.LIB>

SYNTAX:		   void cof_pktFsend(void *send_buffer,
									  		int buffer_length,
									  		char delay);

DESCRIPTION:   Cofunction version of pktFsend(). This function will yield
					to other tasks while the packet is being sent. It differs from
					pktFsend() in that it will not return until the packet is
					done transmitting.

PARAMETER1:    The data to be sent
PARAMETER2:		Length of the data buffer to transmit
PARAMETER3:		The number of byte times to delay before sending the
					data (0-255) This is used to implement protocol-specific
					delays between packets

END DESCRIPTION **********************************************************/

nodebug scofunc void cof_pktFsend(void *send_buffer,
											 int buffer_length,
											 char delay)
{
	//wait until tx is ready
	while (pktFsending()) yield;

	fpkt_txframe = send_buffer;
	fpkt_txsize = buffer_length;
	fpkt_txcount = 0;
	fpkt_txdelay = delay;
	fpkt_txactive = 1;				//set active flag
	if(delay)
	{
		fpkt_disableport();
		WrPortI(SFDR, NULL, 23);		//send a dummy character to start
	}
	else
	{
		fpkt_enableport();
		if(fpkt_type == PKT_9BITMODE)
		{
			fpkt_send9bit();
		}
		else
		{
			fpkt_sendbyte();
		}
	}
	while (pktFsending()) yield;	//wait for this packet to finish
}

/*** BeginHeader pktFreceive */
int pktFreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktFreceive                   <PACKET.LIB>

SYNTAX:		   int pktFreceive(void *buffer, int buffer_size);

DESCRIPTION:   Gets a received packet if there is one in the packet buffer.
					Otherwise, it will immediately return 0.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE: >0: The number of bytes in the received packet.
				  0: indicates that no new packets have been received.
				  -1: indicates that the packet is too large for the given buffer
				  -2: if a needed test_packet function is not defined

END DESCRIPTION **********************************************************/

nodebug int pktFreceive(void *buffer, int buffer_size)
{
	auto int rxpos;
	auto int packet_length;
	auto int buffer_offset;
	auto int temp;

	rxpos = fpkt_rxpos;
	buffer_offset = fpkt_rxnext*(fpkt_rxsize+2);
	xmem2root(&packet_length, fpkt_rxbuffers + buffer_offset, 2);
	if(packet_length)
	{
		//packet is definitely done
		if(packet_length <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, fpkt_rxbuffers + buffer_offset + 2, packet_length);
			temp = 0;
			root2xmem(fpkt_rxbuffers + buffer_offset, &temp, 2); //clear out
			fpkt_rxnext = (fpkt_rxnext + 1) % fpkt_rxcount;
			fpkt_lastpos = 0;
			return packet_length;
		}
		else
		{
			return -1;
		}
	}
	else if(fpkt_type != PKT_GAPMODE && rxpos != fpkt_lastpos)
	{
		if (fpkt_testpacket == NULL)
		{
			return -2;
		}
		//check for complete packet
		if(rxpos <= buffer_size)
		{
			//add 2 to offset for start of data
			xmem2root(buffer, fpkt_rxbuffers + buffer_offset + 2, rxpos);
			if ( (*fpkt_testpacket)(buffer, rxpos) )
			{
				fpkt_nextdone(); //complete packet
				temp = 0;
				root2xmem(fpkt_rxbuffers + buffer_offset, &temp, 2); //clear out
				fpkt_rxnext = (fpkt_rxnext + 1) % fpkt_rxcount;
				fpkt_lastpos = 0;
				return rxpos;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return 0;
	}
}

/*** BeginHeader cof_pktFreceive */
scofunc int cof_pktFreceive(void *buffer, int buffer_size);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
cof_pktFreceive                   <PACKET.LIB>

SYNTAX:		   int cof_pktFreceive(void *buffer, int buffer_size);

DESCRIPTION:   This cofunction is used to listen for received packets.
					It will return with a packet immediately if there is one in
					in the buffer. Otherwise, it will wait for one while yielding
					to other tasks.

PARAMETER1:   	A buffer for the packet to be written into
PARAMETER2:		Length of the data buffer

RETURN VALUE:	The length of the received packet or an error code
					identical to those in pktFreceive()

END DESCRIPTION **********************************************************/

nodebug scofunc int cof_pktFreceive(void *buffer, int buffer_size)
{
	auto int length;
	while((length = pktFreceive(buffer, buffer_size)) == 0)
	{
		yield;
	}
	return length;
}


/*** BeginHeader pktFgetErrors */
char pktFgetErrors();
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
pktFgetErrors                   <PACKET.LIB>

SYNTAX:		   char pktFgetErrors();

DESCRIPTION:   Gets a bit field with flags set for any errors that occured.
					These flags are then cleared, so that a particular error
					will only cause the flag to be set once.

RETURN VALUE:	A bit field with flags for various errors. The errors
					along with their bit masks are as follows:
						PKT_BUFFEROVERFLOW 0x01
						PKT_RXOVERRUN 0x02
						PKT_PARITYERROR 0x04
						PKT_NOBUFFER 0x08

END DESCRIPTION **********************************************************/

nodebug char pktFgetErrors()
{
	auto char error_flags;

	error_flags = 0;
	if (fpkt_overflow) {
		error_flags |= PKT_BUFFEROVERFLOW;
		fpkt_overflow = 0;		//clear the error after reporting it
	}
	if (fpkt_rxoverrun) {
		error_flags |= PKT_RXOVERRUN;
		fpkt_rxoverrun = 0;
	}
	if (fpkt_parityerror) {
		error_flags |= PKT_PARITYERROR;
		fpkt_parityerror = 0;
	}
	if (fpkt_nobuffer) {
		error_flags |= PKT_NOBUFFER;
		fpkt_nobuffer = 0;
	}
	return error_flags;
}



/*******************************************
Parity Check
******************************************/

/*** Beginheader pkt_checkparity */
int pkt_checkparity(char);
/*** Endheader */

//returns 1 if even, 0 if odd

#asm root
; corrupts af and hl

pkt_checkparity::
	 push	 de
	 push	 iy
	 ld	 e, L
	 xor	 a
	 ld	 d, a		;zero out D
	 ld	 iy, ser_paritytable   ;defined in RS232.LIB
	 add	 iy, de
	 ld	 a, (iy)
	 bool	 hl
	 ld	 L, a
	 bool	 hl
	 pop	 iy
	 pop	 de
	 ret

#endasm



/*** BeginHeader */

#endif

/*** EndHeader */

