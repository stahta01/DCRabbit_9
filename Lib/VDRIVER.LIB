/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader */
#ifndef __VDRIVER_LIB
#define __VDRIVER_LIB

#ifndef _vd_debug
   #ifdef VD_DEBUG
	   #define _vd_debug debug
   #else
   	#define _vd_debug nodebug
   #endif
#endif



/*** EndHeader */

/* START LIBRARY DESCRIPTION *********************************************
vdriver.lib
	This library supports the virtual watchdogs.

	VdInit() must be called to initialize the virtual driver

END DESCRIPTION **********************************************************/

/*** BeginHeader */

#ifndef N_WATCHDOG
#define N_WATCHDOG 10

#undef WD_UNUSED
#define WD_UNUSED 0x00

#endif

/*** EndHeader */

/*** Beginheader VdInit */
void VdInit(void);
/*** Endheader */

#makechain _GLOBAL_INIT

#ifdef USE_SECONDARY_WD
	#if _CPU_ID_ < R3000_R1
	#error "Secondary watchdog can only be used on an R3000a or higher CPU"
	#endif
#endif


/* START FUNCTION DESCRIPTION ********************************************
VdInit           <vdriver.lib>

SYNTAX:       void VdInit(void);

DESCRIPTION:  Initializes virtual watchdogs. If this is not a RabbitSys
system the periodic interrupt is initialized.

PARAMETER1:   None

RETURN VALUE: None.

END DESCRIPTION **********************************************************/
_vd_debug
void VdInit (void)
{
   #asm xmemok
      push ip
      ipset 3
   #endasm

   vwdogInit();
   #if __RABBITSYS==0
	   periodic_init();
	#endif

   #asm xmemok
      pop ip
   #endasm
} //VdInit()


/*** Beginheader hitwd */
void hitwd(void);
/*** Endheader */
/* START FUNCTION DESCRIPTION ********************************************
hitwd                       <VDRIVER.LIB>

SYNTAX:		void hitwd();

DESCRIPTION: Hits the watchdog timer, postponing a hardware reset for
2 seconds. Unless the watchdog timer is disabled, a program must call this
function periodically, or the controller will automatically reset itself.
If the virtual driver is enabled (which it is by default), it will call
hitwd in the background. The virtual driver also makes additional "virtual"
watchdog timers available.

If this is a RabbitSys system this routine calls _sys_tick() with a
parameter of zero (0).

This function does not service the secondary watchdog.

RETURN VALUE:	None.

END DESCRIPTION **********************************************************/
#asm
hitwd::
#if _USER
	ld		hl,0
	push	hl
	call	_sys_tick
	add	sp,2
#else
 	ld a,0x5a
	ioi 	ld (WDTCR),a
#endif
	ret
#endasm



/*** BeginHeader vd_wdogarray, vwdogInit, topVd */

xmem void vwdogInit();

extern unsigned char topVd;
extern unsigned int vd_wdogarray[N_WATCHDOG];
#if _USER
	extern unsigned int eventHandle;
#endif

/*** endheader */
unsigned char topVd;
unsigned int vd_wdogarray[N_WATCHDOG];
#if _USER
   	unsigned int eventHandle;
#endif

_vd_debug
xmem void vwdogInit()
{
   topVd = 0;
   memset(vd_wdogarray,0,sizeof(vd_wdogarray));
#if _USER
	eventHandle = 0;
#endif
} //vwdogInit()

#if !__RABBITSYS
#funcchain _GLOBAL_INIT vwdogInit
#endif

/*** BeginHeader VdGetFreeWd */
int VdGetFreeWd(char count);
/*** Endheader */


/* START FUNCTION DESCRIPTION ********************************************
VdGetFreeWd               <vdriver.lib>

SYNTAX:       int VdGetFreeWd(char count);

DESCRIPTION:  Returns a free virtual watchdog and initializes that watchdog
				  so that the virtual driver begins counting it down from
				  count. The number of virtual watchdogs available is 10.

				  Virtual Watchdogs are counted down every 62.5 ms (64 ms for
 				  RabbitSys code). If any virtual watchdog reaches zero (0) an
 				  exception will be thrown.  Once a virtual watchdog is active it
 				  should be reset periodically with a call to VdHitWd to prevent
 				  timing out.  RabbitSys Virtual Watchdogs will trigger all
				  shutdown events if a Watchdog times-out.

EXAMPLE: // VdGetFreeWd virtual watchdog example
			main()
			{
				int wd;               // handle for a virtual watchdog
				unsigned long tm;
				tm = SEC_TIMER;
				wd = VdGetFreeWd(33); // wd activated, 9 virtual watchdogs available
				                      // wd must be hit at least every 2 seconds
				while(SEC_TIMER - tm < 60) { // let it run for a minute
					VdHitWd(wd);       // counter corresponding to wd is reset to 33
				}
				VdReleaseWd(wd);      // now there are 10 virtual watchdogs again
			}

PARAMETER1:   count: 1 < count <= 255

RETURN VALUE: 	>=0		Integer id number of a virtual watchdog timer.

END DESCRIPTION **********************************************************/
_vd_debug
int VdGetFreeWd (char count)
{
	auto unsigned int i;
#if _USER
	auto _sys_event_data_t data;

	if (!eventHandle)
	{
	   data.timer.interval = 64;
	   data.timer.data = NULL;
	   data.timer.tflags = _SYS_EVENT_RECUR;
	   if (i = _sys_add_event(_SYS_EVENT_TIMER, vwdog, &eventHandle, &data) )
	   {
	      exception(i);
	      exit(i);
	   }
	}
#endif
	if (topVd >= 0 && topVd < N_WATCHDOG)
	{
		for(i=0; i<N_WATCHDOG; i++)
		{
			if((char)vd_wdogarray[i] == WD_UNUSED)
			{
   			if (!count)
					count = 1;
				vd_wdogarray[i]=(count << 8) | count;
				if (i == topVd) topVd++;  // only iterate down from highest active
   			                          // wd, not all N_WATCHDOG allocated
				return i;
			}
		}
	}
	exception(-ERR_NOVIRTWDOGAVAIL);
	exit(-ERR_NOVIRTWDOGAVAIL);
} //VdGetFreeWd()

/*** BeginHeader VdReleaseWd  */
int VdReleaseWd(int ndog);
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
VdReleaseWd               <vdriver.lib>

SYNTAX:       int VdReleaseWd(int ndog);

DESCRIPTION:  Deactivates a virtual watchdog and makes it available again.

EXAMPLE: // VdReleaseWd virtual watchdog example
			main()
			{
				int wd;               // handle for a virtual watchdog
				unsigned long tm;
				tm = SEC_TIMER;
				wd = VdGetFreeWd(255);// wd activated, 9 virtual wds now available
				                      // wd must be hit at least every 16.32 secs
				while(SEC_TIMER - tm < 60) { // let it run for a minute
					VdHitWd(wd);       // decrementing counter corresponding to wd
                                  //   reset to 255
				}
				VdReleaseWd(wd);      // now there are 10 virtual wds available
			}

PARAMETER1:   ndog: handle returned by VdGetFreeWd

RETURN VALUE: 0 - ndog out of range
 				  1 - success

END DESCRIPTION **********************************************************/
_vd_debug
int VdReleaseWd (int ndog)
{
	auto unsigned char i;
	auto unsigned char *vda;

	vda = (unsigned char *)vd_wdogarray;
	if( ndog >= 0 && ndog < N_WATCHDOG )
	{
		vda[ndog<<1] = WD_UNUSED;
		for (i=topVd; i>0 && vda[(i-1)<<1]==WD_UNUSED; i--)
		{ // topVd=top active
			topVd--;
		}
		return 1;
	}
	else
	{
		return 0;
	}
} //VdReleaseWd()


/*** BeginHeader  VdHitWd */
int VdHitWd(int ndog);
/*** endheader */

/* START FUNCTION DESCRIPTION ********************************************
VdHitWd               <vdriver.lib>

SYNTAX:       int VdHitWd(int ndog);

PARAMETER1:	  ndog: id of virtual watchdog returned by VdGetFreeWd()

KEYWORDS:     timer, virtual driver

DESCRIPTION:  Resets virtual watchdog counter to N counts where N is the
				  argument to the call to VdGetFreeWd() that obtained the virtual
				  watchdog ndog.

				  The virtual driver counts down watchdogs every 64ms (62.5ms for
 				  non-RabbitSys code). If a virtual watchdog reaches 0, a fatal
 				  error will occur. Once a virtual watchdog is active it should
 				  be reset periodically with a call to VdHitWd to prevent timing
 				  out.

				  If count = 2 the VdHitWd will need to be called again for
				  virtual watchdog ndog within 64 ms or 62.5 ms.

				  If count = 255 the VdHitWd will need to be called again for
				  virtual watchdog ndog within 16.32 sec. or 15.9375 sec.

EXAMPLE: // VdHitWd virtual watchdog example
			main()
			{
				int wd;               // handle for a virtual watchdog
				unsigned long tm;
				tm = SEC_TIMER;
				wd = VdGetFreeWd(16); // wd activated, 9 virtual wds now available
				                      // wd must be hit at least once 1024ms.
				while(SEC_TIMER - tm < 60) { // let it run for a minute
					VdHitWd(wd);       // decrementing counter corresponding
                                  //   to wd reset to 16
				}
				VdReleaseWd(wd);      // now there are 10 virtual wds available
			}


RETURN VALUE: 0			success
				  -EINVAL	ndog not valid

END DESCRIPTION **********************************************************/
#asm xmem nodebug
; virtual watchdog
VdHitWd::   				 ; N_WATCHDOG
	;if ( ! ndog<N_WATCHDOG)
   ld		de, N_WATCHDOG
   or		a
   sbc	hl,de
   	;return -EINVAL
	   ld		hl,-EINVAL
	   jr		nc,.vdHitWdExit

   ;vd_wdogarray[ndog] = (vd_wdogarray[ndog] & 0x0F) | (vd_wdogarray[ndog]<<8);
   ld		hl,(sp+3)
	ld		de,vd_wdogarray
	sla	l               ; ndog * 2  since vd_wdogarray[i]'s are 2 bytes

	add	hl,de           ; now hl points to correct element

	ld		d,(hl)          ; move the low byte containing
	inc	hl              ; the max count for this wdog into
	ld		(hl),d          ; the high byte to reset countdown

	;return 0;
	bool	hl
	ld		L,h
.vdHitWdExit:
	lret
#endasm


/*** BeginHeader vwdog */
#if _USER
	xmem void vwdog(_sys_event_handle *seh, void *data);
#else
	xmem void vwdog();
#endif
/*** endheader */

#asm xmem
; The virtual watchdog engine
vwdog::
; this code is used if dynamic C debugger present only
	ld		a,(OPMODE)    		; 9
	and	8             		; 2
	jr		z,.wvdog0      		; 5, if run from ram mode skip inhibit of watchdog

	ld		a,(dkStatusFlags)
	bit	DKF_STAT_RUNMODE,a
	jr		nz,.wvdog0		; if program is running, count down watchdogs
	push	hl
	jr		.vwdogz

.wvdog0:
	push  hl
	ld		a,(topVd)     ; 9, traverse down from highest active watchdog
	or		a             ; 2
	jr		z,.vwdogz      ; 5
	ld		d,a           ; 2
	ld		hl,vd_wdogarray;11
	ld		a,WD_UNUSED   ; 4, 'unused' code to compare with watchdog low byte

.vwdog1:
	cp		(hl)          ; 5, low byte of array element contains maxcount
	jr		z,.vwdog1a     ; 5,  for this wd (WD_UNUSED if disabled)
	inc	hl            ; 2, point to byte 2 of the array element and
	dec	(hl)          ; 8,   decrement actual count of wd
	jr		z,.vwdog5      ; 5, crash - timeout
	dec	hl            ; 2, point back to start of element

.vwdog1a:
	inc	hl            ; 2, point to next element
	inc   hl            ; 2
	dec	d             ; 2
	jr		nz,.vwdog1     ; 5
.vwdogz:
	pop   hl
	#if __RABBITSYS==0
		call	hitwd         ; 12, hit the real watchdog too
	#endif
	lret                 ; 8

.vwdog5:                ; crash location
	pop   hl
c	exception(-ERR_VIRTWDOGTIMEOUT);
c	exit(-ERR_VIRTWDOGTIMEOUT);

#endasm


/*** BeginHeader  runtime_error */
root void runtime_error();
/*** EndHeader */

#asm nodebug
__runtime_error::
	jr		__runtime_error

#endasm

/*** BeginHeader */
#endif
/*** EndHeader */