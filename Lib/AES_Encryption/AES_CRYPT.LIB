/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
AES_CRYPT.LIB

DESCRIPTION:
   Implementation of the Rijndael AES cipher.

END DESCRIPTION *********************************************************/


/*** BeginHeader */
#ifndef __AES_CRYPT_LIB
#define __AES_CRYPT_LIB

//#define AES_ONLY		// App may define this to delete code for non-standard Rijndael
								// i.e. blocks != 4 or key sizes not 4,6 or 8 longwords.
                        // Define this to save space if using only AES.

#ifndef _RAB4K
	#define _RAB4K 0
#endif

// State for 128,192 or 256-bit CFB(Periodic Cipher Feedback Mode) stream cipher
// Uses 176, 208 or 240 bytes from expanded_key respectively.
typedef struct {
	char feedback_index;			// Current byte in block (0..15, 0..15 etc.)
   char nk;							// Number of longwords in key (4,6,8 supported)
	char feedback_register[16];// Block size always 16 bytes for AES.
	char expanded_key[240];		// Max possible expanded key size
	} AESstreamState;

#ifdef AES_STATS
	#define AES_S(addr) push hl $ ld hl,(addr) $ inc hl $ ld (addr),hl $ pop hl
	word aes_s_sbox;
	word aes_s_rowshift;
	word aes_s_colmix;
	word aes_s_addkey;
#else
	#define AES_S(addr)
#endif


/*** EndHeader */

/*** BeginHeader AESinitStream */
void AESinitStream(AESstreamState *state, char *key, char *init_vector);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESinitStream                   <AES_CRYPT.LIB>

SYNTAX:		   void AESinitStream(AESstreamState *state,
											 char *key,
											 char *init_vector);

DESCRIPTION:   Sets up a stream state structure to begin encrypting or
					decrypting a stream. A particular stream state can only be
					used for one direction.

PARAMETER1:		state - An AESstreamState structure to be initialized
PARAMETER2:		key - the 16-byte cipher key, using a NULL pointer will prevent
 						an existing key from being recalculated.
PARAMETER3:		init_vector - a 16-byte array representing the initial state
						of the feedback registers. Both ends of the stream must
						begin with the same initialization vector and key.

END DESCRIPTION **********************************************************/

nodebug void AESinitStream(AESstreamState *state, char *key, char *init_vector)
{
	memcpy(state->feedback_register, init_vector, 16);
	if (key)
		AESexpandKey(state->expanded_key, key, 4, 4);
	state->feedback_index = 0;
   state->nk = 4;
}

/*** BeginHeader AESinitStream192 */
void AESinitStream192(AESstreamState *state, char *key, char *init_vector);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESinitStream                   <AES_CRYPT.LIB>

SYNTAX:		   void AESinitStream192(AESstreamState *state,
											 char *key,
											 char *init_vector);

DESCRIPTION:   See AESinitStream().  This version assumes a 192 bit key
               (24 bytes).  Everything else is the same.

PARAMETER1:		state - An AESstreamState structure to be initialized
PARAMETER2:		key - the 24-byte cipher key, using a NULL pointer will prevent
 						an existing key from being recalculated.
PARAMETER3:		init_vector - a 16-byte array representing the initial state
						of the feedback registers. Both ends of the stream must
						begin with the same initialization vector and key.

END DESCRIPTION **********************************************************/

nodebug void AESinitStream192(AESstreamState *state, char *key, char *init_vector)
{
	memcpy(state->feedback_register, init_vector, 16);
	if (key)
		AESexpandKey(state->expanded_key, key, 4, 6);
	state->feedback_index = 0;
   state->nk = 6;
}

/*** BeginHeader AESinitStream256 */
void AESinitStream256(AESstreamState *state, char *key, char *init_vector);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESinitStream                   <AES_CRYPT.LIB>

SYNTAX:		   void AESinitStream256(AESstreamState *state,
											 char *key,
											 char *init_vector);

DESCRIPTION:   See AESinitStream().  This version assumes a 256 bit key
               (32 bytes).  Everything else is the same.

PARAMETER1:		state - An AESstreamState structure to be initialized
PARAMETER2:		key - the 32-byte cipher key, using a NULL pointer will prevent
 						an existing key from being recalculated.
PARAMETER3:		init_vector - a 16-byte array representing the initial state
						of the feedback registers. Both ends of the stream must
						begin with the same initialization vector and key.

END DESCRIPTION **********************************************************/

nodebug void AESinitStream256(AESstreamState *state, char *key, char *init_vector)
{
	memcpy(state->feedback_register, init_vector, 16);
	if (key)
		AESexpandKey(state->expanded_key, key, 4, 8);
	state->feedback_index = 0;
   state->nk = 8;
}

/*** BeginHeader AESencryptStream */
void AESencryptStream(AESstreamState *state, char *data, int count);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESencryptStream                   <AES_CRYPT.LIB>

SYNTAX:		   void AESencryptStream(AESstreamState *state,
											    char *data,
											    int count);

DESCRIPTION:   Encrypts an array of bytes

PARAMETER1:		state - The AESstreamState structure
PARAMETER2:		data - an array of bytes that will be encrypted in place.
PARAMETER3:		count - size of data array

END DESCRIPTION **********************************************************/

nodebug void AESencryptStream(AESstreamState *state, char *data, int count)
{
#asm
	push	ix
	ld		ix,hl
	ld		hl,(sp+@sp+2+count)
	ld		c,L
	ld		b,h
	bool	hl
	jr		z,.aes_enc_exit
	ld		hl,(sp+@sp+2+data)
	ex		de,hl
	; DE = data, IX = state, BC = count
.aes_enc_loop:
	ld		hl,(ix)
   ld		a,h
   ld		h,0	; Now A is NK, HL is fb_index
	bool	hl
	jr		nz,.aes_enc_1	; Not 0 (mod 16), so continue with current feedback
	push	bc
	push	de

	ld		l,a	; Get NK (H is 0)
	push	hl
	ld		hl,ix
	ld		de,18	; Offset to expanded key
	add	hl,de
	push	hl
	ld		de,-16
	add	hl,de	; Back to offset 2 (feedback, block to be re-encrypted)
	push	hl
	call	AESencrypt4
	add	sp,6

	pop	de
	pop	bc
.aes_enc_1:
	exx
	ld		hl,ix
   ld		a,(hl)	; Get feedback index
	inc	hl
   inc	hl			; HL points to feedback
	ex		de,hl		; DE points to feedb reg.
   ld		l,a
	inc	a
	and	0x0F
	ld		(ix),a	; add 1 to offset, modulo 16
   ld		h,0
	add	hl,de
	ld		h',h
	ld		l',L
	exx
	ld		a,(de)
	xor	(hl)
	ld		(de),a
	ld		(hl),a
	inc	de
	dec	bc
	ld		a,b
	or		c
	jr		nz,.aes_enc_loop
.aes_enc_exit:
	pop	ix
#endasm
}

/*** BeginHeader AESdecryptStream */
void AESdecryptStream(AESstreamState *state, char *data, int count);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESdecryptStream                   <AES_CRYPT.LIB>

SYNTAX:		   void AESdecryptStream(AESstreamState *state,
											    char *data,
											    int count);

DESCRIPTION:   Decrypts an array of bytes

PARAMETER1:		state - The AESstreamState structure
PARAMETER2:		data - an array of bytes that will be decrypted in place.
PARAMETER3:		count - size of data array

END DESCRIPTION **********************************************************/

nodebug void AESdecryptStream(AESstreamState *state, char *data, int count)
{
	/*
	int i;
	char ct_byte;

	for(i = 0;i < count;i++)
	{
		if(state->feedback_index == 0)
		{
			//new register block
			AESencrypt4(state->feedback_register,
							state->expanded_key,
							state->nk);
		}
		ct_byte = data[i]; //temp store for the current ciphertext
		data[i] ^= state->feedback_register[state->feedback_index];
		state->feedback_register[state->feedback_index] = ct_byte;
		state->feedback_index = (state->feedback_index + 1) & 0x0f;
	}
	*/
#asm
	push	ix
	ld		ix,hl
	ld		hl,(sp+@sp+2+count)
	ld		c,L
	ld		b,h
	bool	hl
	jr		z,.aes_enc_exit
	ld		hl,(sp+@sp+2+data)
	ex		de,hl
	; DE = data, IX = state, BC = count
.aes_enc_loop:
	ld		hl,(ix)
   ld		a,h
   ld		h,0
	bool	hl
	jr		nz,.aes_enc_1
	push	bc
	push	de

	ld		l,a
	push	hl
	ld		hl,ix
	ld		de,18	; Offset to expanded key
	add	hl,de
	push	hl
	ld		de,-16
	add	hl,de	; Back to offset 2 (feedback, block to be re-encrypted)
	push	hl
	call	AESencrypt4
	add	sp,6

	pop	de
	pop	bc
.aes_enc_1:
	exx
	ld		hl,ix
   ld		a,(hl)
	inc	hl
	inc	hl
	ex		de,hl		; DE points to feedb reg.
	ld		l,a
	inc	a
	and	0x0F
	ld		(ix),a	; add 1 to offset, modulo 16
   ld		h,0
	add	hl,de
	ld		h',h
	ld		l',L
	exx
	ld		a,(de)
	ld		a',a
	xor	(hl)
	ld		(de),a
	ex		af,af'
	ld		(hl),a
	inc	de
	dec	bc
	ld		a,b
	or		c
	jr		nz,.aes_enc_loop
.aes_enc_exit:
	pop	ix
#endasm
}


/*** Beginheader AESsubBytes */
//assume count < 256
root void AESsubBytes(char *table, char *bytes, int count);
/*** EndHeader */

#asm root

AESsubBytes::
	AES_S(aes_s_sbox)
	 ex	 de, hl 		 ; 2 DE = table base
	 ld	 hl, (sp+6)	; 9
	 ld	 b, L			; 2  B holds byte count
	 ld	 hl, (sp+4) ; 9 Data to transform
subloop:
	 ld	a,(hl)
	 ex	de',hl
	 bool	hl
	 ld	l,a
	 add	hl,de
	 ld	a,(hl)
	 ex	de',hl
	 ld	(hl),a
	 inc	hl
	 djnz	 subloop		; 33*16 + 22 + 8 = 558 clocks
	 ret

#endasm

/*** Beginheader AESsubBytes4 */
root void AESsubBytes4(char *bytes);
/*** EndHeader */

#asm root

#if _RAB4K

AESsubBytes4::
	ld		bcde, pw
   ld		a,b
	sbox	a
   ld		b,a
   ld		a,c
	sbox	a
   ld		c,a
   ld		a,d
	sbox	a
   ld		d,a
   ld		a,e
	sbox	a
   ld		e,a
	ld		pw, bcde

	ld		bcde, px
   ld		a,b
	sbox	a
   ld		b,a
   ld		a,c
	sbox	a
   ld		c,a
   ld		a,d
	sbox	a
   ld		d,a
   ld		a,e
	sbox	a
   ld		e,a
	ld		px, bcde

	ld		bcde, py
   ld		a,b
	sbox	a
   ld		b,a
   ld		a,c
	sbox	a
   ld		c,a
   ld		a,d
	sbox	a
   ld		d,a
   ld		a,e
	sbox	a
   ld		e,a
	ld		py, bcde

	ld		bcde, pz
   ld		a,b
	sbox	a
   ld		b,a
   ld		a,c
	sbox	a
   ld		c,a
   ld		a,d
	sbox	a
   ld		d,a
   ld		a,e
	sbox	a
   ld		e,a
	ld		pz, bcde

   ret

#else

AESsubBytes4::
	AES_S(aes_s_sbox)
	 ld	de,AESsbox 		 ; 2 DE = table base
	 ld	 b,16			; 2  B holds byte count
subloop:
	 ld	a,(hl)
	 ex	de',hl
	 bool	hl
	 ld	l,a
	 add	hl,de
	 ld	a,(hl)
	 ex	de',hl
	 ld	(hl),a
	 inc	hl
	 djnz	 subloop		; 33*16 + 13 + 8 = 549 clocks
	 ret

#endif

#endasm

/*** Beginheader AESinvSubBytes4 */
root void AESinvSubBytes4(char *bytes);
/*** EndHeader */

#asm root

#if _RAB4K

AESinvSubBytes4::
	ld		bcde, pw
   ld		a,b
	ibox	a
   ld		b,a
   ld		a,c
	ibox	a
   ld		c,a
   ld		a,d
	ibox	a
   ld		d,a
   ld		a,e
	ibox	a
   ld		e,a
	ld		pw, bcde

	ld		bcde, px
   ld		a,b
	ibox	a
   ld		b,a
   ld		a,c
	ibox	a
   ld		c,a
   ld		a,d
	ibox	a
   ld		d,a
   ld		a,e
	ibox	a
   ld		e,a
	ld		px, bcde

	ld		bcde, py
   ld		a,b
	ibox	a
   ld		b,a
   ld		a,c
	ibox	a
   ld		c,a
   ld		a,d
	ibox	a
   ld		d,a
   ld		a,e
	ibox	a
   ld		e,a
	ld		py, bcde

	ld		bcde, pz
   ld		a,b
	ibox	a
   ld		b,a
   ld		a,c
	ibox	a
   ld		c,a
   ld		a,d
	ibox	a
   ld		d,a
   ld		a,e
	ibox	a
   ld		e,a
	ld		pz, bcde

   ret

#else

AESinvSubBytes4::
	AES_S(aes_s_sbox)
	 ld	 de,AESsboxI 		 ; 2 DE = table base
	 ld	 b,16			; 2  B holds byte count
subloop:
	 ld	a,(hl)
	 ex	de',hl
	 bool	hl
	 ld	l,a
	 add	hl,de
	 ld	a,(hl)
	 ex	de',hl
	 ld	(hl),a
	 inc	hl
	 djnz	 subloop		; 33*16 + 13 + 8 = 549 clocks
	 ret

#endif

#endasm

/*** Beginheader AESshiftRows4 */
// takes pointer to data block.  Optimised for 4-column case.
void AESshiftRows4(char *block);
/*** EndHeader */
#asm

#if _RAB4K

AESshiftRows4::
	ld		bcde,py
   ld		jkhl,pz
   exx
   ld		bcde,pw
   ld		jkhl,px

   ex		jk',hl
   ex		de,hl
   ex		jk,hl
   ld		a,e
   ld		e,L
   ld		l,a
   ld		a,b
   ld		b,d
   exx
   ld		d',b
   exx
   ld		b',h
   ld		h,a
   ex		jk,hl
   ex		de,hl
   ex		jk',hl
   ld		a,c
   exx
   ld		c',c
   ld		c,a
   exx
   ld		a,d
   ld		d,h
   exx
   ld		h',d
   ld		d,h
   ld		h,a

   ld		py,bcde
   ld		pz,jkhl
   exx
	ld		pw,bcde
   ld		px,jkhl
   ret

#else

AESshiftRows4::
	AES_S(aes_s_rowshift)
	push	ix				; 12
	ld		ix,hl			; 4
	ld		hl,(ix+1)	; 9
	ex		de,hl			; 2
	ld		hl,(ix+5)	; 9
	ex		de',hl		; 2
	ld		hl,(ix+9)	; 9
	ld		b,h			; 2
	ld		c,L			; 2
	ld		hl,(ix+13)	; 9
	ld		a,h			; 2
	ld		h,d			; 2
	ld		(ix+9),hl	; 11
	ld		l,c			; 2
	ld		h,a			; 2
	ld		(ix+5),hl	; 11
	ex		de',hl		; 2
	ld		a,h			; 2
	ld		h,b			; 2
	ld		(ix+1),hl	; 11
	ld		l,e			; 2
	ld		h,a			; 2
	ld		(ix+13),hl	; 11 =122
	ld		hl,ix			; 4
	ld		de,4			; 6
	add	hl,de			; 2
	dec	hl				; 2
	ld		a,(hl)		; 5
	add	hl,de			; 2
	ld		b,(hl)		; 5
	ld		(hl),a		; 6
	add	hl,de			; 2
	ld		a,(hl)		; 5
	ld		(hl),b		; 6
	add	hl,de			; 2
	ld		b,(hl)		; 5
	ld		(hl),a		; 6
	ld		(ix+3),b		; 10
	pop	ix				; 9
	ret					; 8  : total 207

#endif

#endasm

/*** Beginheader AESinvShiftRows4 */
// takes pointer to data block.  Optimised for 4-column case.
void AESinvShiftRows4(char *block);
/*** EndHeader */
#asm

#if _RAB4K

AESinvShiftRows4::
	ld		bcde,pw
   ld		jkhl,px
   exx
   ld		bcde,py
   ld		jkhl,pz

   ld		a,h
   ld		h,d
   exx
   ld		d',h
   ld		h,d
   ld		d,a
   exx
   ld		a,c
   exx
   ld		c',c
   ld		c,a
	ex		jk',hl
   ex		de,hl
   ex		jk,hl
   ld		a,h
   exx
   ld		h',b
	exx
   ld		b',d
   ld		d,b
   ld		b,a
   ld		a,L
   ld		L,e
   ld		e,a
   ex		jk,hl
   ex		de,hl
   ex		jk',hl

   ld		pw,bcde
   ld		px,jkhl
   exx
	ld		py,bcde
   ld		pz,jkhl
   ret

#else

AESinvShiftRows4::
	AES_S(aes_s_rowshift)
	push	ix				; 12
	ld		ix,hl			; 4
	ld		hl,(ix+13)
   ld		a,h
   ld		e,L
   ld		hl,(ix+1)
   ld		b,h
   ld		h,a
   ex		de',hl
   ld		hl,(ix+5)
   ld		a,h
   ld		c,L
   ld		hl,(ix+9)
   ld		d,h
   ld		h,a
   ld		(ix+13),hl
   ld		l,c
   ld		h,b
   ld		(ix+9),hl
   ex		de',hl
   ld		(ix+5),hl
   ex		de,hl
   ld		(ix+1),hl

	ld		hl,ix
   ld		de,15
   add	hl,de
   ld		de,-4

   ld		b,(ix+3)
   ld		a,(hl)
   ld		(hl),b
   add	hl,de
   ld		b,(hl)
   ld		(hl),a
   add	hl,de
   ld		a,(hl)
   ld		(hl),b
   add	hl,de
   ld		(hl),a

	pop	ix
	ret

#endif

#endasm

/*** Beginheader AESshiftRows */
// takes pointer to data block and size of data block in columns (4,6, or 8)
void AESshiftRows(char *block, int nb);
/*** EndHeader */

#asm

;hl is starting point, b is column counter, assumes start point is also on stack
aes_shiftone:
	 ld	 e, (hl)
	 ld	 (hl), a
	 ld	 a, e
	 dec	 b
	 jr	 z, aes_shiftone_end
	 ld	 de, 4
	 or	 a		;clear carry
	 sbc	 hl, de		;subtract 4 from pointer
	 jr	 aes_shiftone

aes_shiftone_end:
	 ld	 hl, (sp+2)	;reload start point, on stack right after return address
	 ld	 (hl), e		;store last shift
	 ret


AESshiftRows::
	 ld	 hl, (sp+4)
	 ld	 c, L		;c holds block size

	 ;row 2
	 ld	 b, c		;set counter
	 ld	 d, 0x00
	 ld	 e, c
	 dec	 e
	 sla	 e
	 sla	 e			;offset for first row is Nb*4 -4
	 inc	 e			;offset for second row
	 ld	 hl, (sp+2)	;hl holds block pointer
	 add	 hl, de		;start point of shift
	 push	 hl			;store start point
	 call  aes_shiftone		;hl is start of shift, b is counter
aes_row3:
	 ld	 b, c					;reset counter
	 pop	 hl				;reload start point
	 inc	 hl					;set for row 3
	 push	 hl
	 call	 aes_shiftone
	 ld	 b, c					;reset counter
	 ld	 hl, (sp)			;reload start point
	 call	 aes_shiftone
	 ld	 a, c
	 cp	 8
	 jr	 nz, aes_row4		;no extra shift for Nb=4,6
	 ld	 b, c
	 ld	 hl, (sp)			;grab start point
	 call	 aes_shiftone
aes_row4:
	 ld	 b, c					;reset counter
	 pop	 hl
	 inc	 hl					;set for row 4
	 push	 hl
	 call	 aes_shiftone
	 ld	 b, c
	 ld	 hl, (sp)
	 call	 aes_shiftone
	 ld	 b, c					;reset counter
	 ld	 hl, (sp)
	 call	 aes_shiftone
	 ld	 a, c
	 cp	 8
	 jr	 nz, aes_shiftexit 	;no extra shift for Nb=4,6
	 ld	 b, c
	 ld	 hl, (sp)
	 call	 aes_shiftone
aes_shiftexit:
	 pop	 hl						;restore stack
	 ret

#endasm

/*** Beginheader AESinvShiftRows */
// takes pointer to data block and size of data block in columns (4,6, or 8)
void AESinvShiftRows(char *block, int nb);
/*** EndHeader */

#asm

;iy is starting point, b is column counter, preserves hl
aes_ishiftone:
	 push	 hl				;save start point
aes_ishift_loop:
	 ld	 e, (hl)
	 ld	 (hl), a
	 ld	 a, e
	 dec	 b
	 jr	 z, aes_ishiftone_end
	 ld	 de, 0x04		;for incrementing pointer
	 add	 hl, de
	 jr	 aes_ishift_loop

aes_ishiftone_end:
	 pop	 hl			;restore start point
	 ld	 (hl), e		;store last shift
	 ret


AESinvShiftRows::
	 ld	 hl, (sp+4)
	 ld	 c, L		;c holds block size

	 ;row 2
	 ld	 b, c		;set counter
	 ld	 d, 0x00
	 ld	 hl, (sp+2)	;hl holds block pointer
	 inc	 hl			;start at row 2
	 call  aes_ishiftone		;iy is start point, b is counter
aes_irow3:
	 ld	 b, c					;reset counter
	 inc	 hl					;set for row 3
	 call	 aes_ishiftone
	 ld	 b, c					;reset counter
	 call	 aes_ishiftone
	 ld	 a, c
	 cp	 8
	 jr	 nz, aes_irow4		;no extra shift for Nb=4,6
	 ld	 b, c
	 call	 aes_ishiftone
aes_irow4:
	 ld	 b, c					;reset counter
	 inc	 hl					;set for row 4
	 call	 aes_ishiftone
	 ld	 b, c
	 call	 aes_ishiftone
	 ld	 b, c					;reset counter
	 call	 aes_ishiftone
	 ld	 a, c
	 cp	 8
	 jr	 nz, aes_ishiftexit 	;no extra shift for Nb=4,6
	 ld	 b, c
	 call	 aes_ishiftone
aes_ishiftexit:

	 ret

#endasm

/*** Beginheader AESmixColumns */
void AESmixColumns(char *data, int nb);
/*** EndHeader */

#asm

AESmixColumns::
	AES_S(aes_s_colmix)
	push 	ix			; 12
	 ;using 8-bit algorithm in Rijndael spec
	 ; b = a[0], c = a[1], d=a[2], e=a[3], L = Tmp
	 ld	 ix, hl		; 4 start of block
	 ld	 hl, (sp+6)	; 9
	 ex	 de', hl		; 2  de' holds nb (loop counter)  : 27 clocks
aes_mixloop:
	ld		hl,(ix)		; 9
	ld		c,h			; 2
	ld		b,L			; 2
	ld		hl,(ix+2)	; 9
	ld		e,h			; 2
	ld		d,L			; 2
	 ld	 a, b			; 2
	 xor	 c				; 2
	 xor	 d				; 2
	 xor	 e				; 2
	 ld	 L, a			; 2  calculate Tmp
	 ld	h,0x1B		; 4

	 ld	 a, b			; 2
	 xor	 c				; 2
	 rla					; 2 do xtime on a[0] ^ a[1]
	 jr	 nc, continue_0 ; 5
	 xor	 h				; 2
continue_0:
	 xor	 L				; 2
	 xor	 b				; 2
	 ld	 (ix), a		; 10  load new value into column

	 ld	 a, c			; 2
	 xor	 d				; 2
	 rla					; 2 do xtime on a[1] ^ a[2]
	 jr	 nc, continue_1	; 5
	 xor	 h				; 2
continue_1:
	 xor	 L				; 2
	 xor	 c				; 2
	 ld	 (ix+1), a	; 10  load new value into column

	 ld	 a, d			; 2
	 xor	 e				; 2
	 rla					; 2  do xtime on a[2] ^ a[3]
	 jr	 nc, continue_2	; 5
	 xor	 h				; 2
continue_2:
	 xor	 L				; 2
	 xor	 d				; 2
	 ld	 (ix+2), a	; 10  load new value into column

	 ld	 a, e			; 2
	 xor	 b				; 2
	 rla					; 2  do xtime on a[3] ^ a[0]
	 jr	 nc, continue_3	; 5
	 xor	 h				; 2
continue_3:
	 xor	 L				; 2
	 xor	 e				; 2
	 ld	 (ix+3), a	; 10  load new value into column

	 ex	 de', hl			; 2  get countdown
	 dec	 L					; 2  assumes nb is less than 256
	 jr	 z, aes_mixexit  ; 5		: 157 per loop

	 ex	 de', hl			; 2  put countdown back into de'
	 ld	 de, 4			; 6
	 add	 ix, de			; 4  point to next column
	 jr	 aes_mixloop	; 5	: 174 per loop, *3 = 522

aes_mixexit:
	pop	ix				; 9
	 ret					; 8 : total = 27 + 174*3 + 157 + 17 = 723 clocks

#endasm

/*** Beginheader AESmixColumns4 */
void AESmixColumns4(char *data);
/*** EndHeader */

#asm

#if _RAB4K

AESmixColumns4::
	ld		bcde,pw
	ld		jkhl,pw
	rrc	8,jkhl
   xor	jkhl,bcde
   ex		jkhl,bcde
   rlc	b $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	c $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	d $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	e $ sbc a,a $ and 0x1A $ rlb a,jkhl
   xor	jkhl,bcde
   ld		bcde,pw
   xor	jkhl,bcde
   ld		a,b $ xor c $ xor d $ xor e
   ld		b,a $ ld c,a $ ld d,a $ ld e,a
   xor	jkhl,bcde
   ld		pw,jkhl

	ld		bcde,px
	ld		jkhl,px
	rrc	8,jkhl
   xor	jkhl,bcde
   ex		jkhl,bcde
   rlc	b $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	c $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	d $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	e $ sbc a,a $ and 0x1A $ rlb a,jkhl
   xor	jkhl,bcde
   ld		bcde,px
   xor	jkhl,bcde
   ld		a,b $ xor c $ xor d $ xor e
   ld		b,a $ ld c,a $ ld d,a $ ld e,a
   xor	jkhl,bcde
   ld		px,jkhl

	ld		bcde,py
	ld		jkhl,py
	rrc	8,jkhl
   xor	jkhl,bcde
   ex		jkhl,bcde
   rlc	b $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	c $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	d $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	e $ sbc a,a $ and 0x1A $ rlb a,jkhl
   xor	jkhl,bcde
   ld		bcde,py
   xor	jkhl,bcde
   ld		a,b $ xor c $ xor d $ xor e
   ld		b,a $ ld c,a $ ld d,a $ ld e,a
   xor	jkhl,bcde
   ld		py,jkhl

	ld		bcde,pz
	ld		jkhl,pz
	rrc	8,jkhl
   xor	jkhl,bcde
   ex		jkhl,bcde
   rlc	b $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	c $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	d $ sbc a,a $ and 0x1A $ rlb a,jkhl
   rlc	e $ sbc a,a $ and 0x1A $ rlb a,jkhl
   xor	jkhl,bcde
   ld		bcde,pz
   xor	jkhl,bcde
   ld		a,b $ xor c $ xor d $ xor e
   ld		b,a $ ld c,a $ ld d,a $ ld e,a
   xor	jkhl,bcde
   ld		pz,jkhl


	ret

#else

AESmixColumns4::
	AES_S(aes_s_colmix)
	push 	ix				; 12
	 ld	 ix,hl		; 4  start of block
	 ld	c,0x1B		; 2  C holds constant 0x1B for modulo operation
	exx					; 2
	ld		de,4			; 6  de' holds constant 4 for row iteration
	 ld	 b,e			; 2  b' holds loop counter
aes_mixloop:
	exx					; 2
	 ;using 8-bit algorithm in Rijndael spec
	 ; e = a[0], d = a[1], l=a[2], h=a[3], b = Tmp
	ld		hl,(ix)		; 9
	ex		de,hl			; 2
	ld		hl,(ix+2)	; 9
	 ld	 a,e			; 2
	 xor	 d				; 2
	 xor	 L				; 2
	 xor	 h				; 2
	 ld	 b, a			; 2  calculate Tmp

	 ld	 a,e			; 2
	 xor	 d				; 2
	 rla					; 2 do xtime on a[0] ^ a[1]
	 jr	 nc, continue_0 ; 5
	 xor	 c				; 2
continue_0:
	 xor	 b				; 2
	 xor	 e				; 2
	 ld	 L', a		; 4  load new value into column

	 ld	 a,d			; 2
	 xor	 L				; 2
	 rla					; 2 do xtime on a[1] ^ a[2]
	 jr	 nc, continue_1	; 5
	 xor	 c				; 2
continue_1:
	 xor	 b				; 2
	 xor	 d				; 2
	 ld	 h', a		; 4  load new value into column

	 ld	 a,L			; 2
	 xor	 h				; 2
	 rla					; 2  do xtime on a[2] ^ a[3]
	 jr	 nc, continue_2	; 5
	 xor	 c				; 2
continue_2:
	 xor	 b				; 2
	 xor	 L				; 2
	 ld	 L, a			; 2  load new value into column (finished using old L)

	 ld	 a,h			; 2
	 xor	 e				; 2
	 rla					; 2  do xtime on a[3] ^ a[0]
	 jr	 nc, continue_3	; 5
	 xor	 c				; 2
continue_3:
	 xor	 b				; 2
	 xor	 h				; 2
	 ld	 h, a			; 2  load new value into column (finished using old h)
	 ld    (ix+2),hl	; 11 save a[2,3]
	 exx					; 2  get countdown
	 ld	 (ix),hl		; 11 save a[0,1]
	 add	 ix,de		; 4  increment to next column to mix
	 djnz	 aes_mixloop	; 5	: 145 per loop

	pop	ix				; 9
	 ret					; 8 : total = 28 + 145*4 + 17 = 625 clocks

#endif

#endasm

/*** BeginHeader AESinvMixColumns */
void AESinvMixColumns(char *data, int columns);
/*** EndHeader */

#asm

AESinvMixColumns::
	 ; b = a[0], c = a[1], d=a[2], e=a[3], L = Tmp
	 ld	 iy, hl
	 ld	 hl, (sp+4)		;hl holds column counter
	 push	 ix			;this may be necessary
	 add	 sp, -12		;reserve 12 bytes on the stack
	 ld	 ix, 0x00
	 add	 ix, sp		;ix now points to new 12 bytes
aes_invmixloop:
	 ld	 b, (iy)
	 ld	 c, (iy+1)
	 ld	 d, (iy+2)
	 ld	 e, (iy+3)

	 ;calculate the mult table
	 ;for a[0]
	 ld	 a, b
	 sla	 a
	 jr	 nc, continue_a0x2
	 xor	 0x1B
continue_a0x2:
	 ld	 (ix), a
	 sla	 a
	 jr	 nc, continue_a0x4
	 xor	 0x1B
continue_a0x4:
	 ld	 (ix+1), a
	 sla	 a
	 jr	 nc, continue_a0x8
	 xor	 0x1B
continue_a0x8:
	 ld	 (ix+2), a

	 ;for a[1]
	 ld	 a, c
	 sla	 a
	 jr	 nc, continue_a1x2
	 xor	 0x1B
continue_a1x2:
	 ld	 (ix+3), a
	 sla	 a
	 jr	 nc, continue_a1x4
	 xor	 0x1B
continue_a1x4:
	 ld	 (ix+4), a
	 sla	 a
	 jr	 nc, continue_a1x8
	 xor	 0x1B
continue_a1x8:
	 ld	 (ix+5), a

	 ;for a[2]
	 ld	 a, d
	 sla	 a
	 jr	 nc, continue_a2x2
	 xor	 0x1B
continue_a2x2:
	 ld	 (ix+6), a
	 sla	 a
	 jr	 nc, continue_a2x4
	 xor	 0x1B
continue_a2x4:
	 ld	 (ix+7), a
	 sla	 a
	 jr	 nc, continue_a2x8
	 xor	 0x1B
continue_a2x8:
	 ld	 (ix+8), a

	 ;for a[3]
	 ld	 a, e
	 sla	 a
	 jr	 nc, continue_a3x2
	 xor	 0x1B
continue_a3x2:
	 ld	 (ix+9), a
	 sla	 a
	 jr	 nc, continue_a3x4
	 xor	 0x1B
continue_a3x4:
	 ld	 (ix+10), a
	 sla	 a
	 jr	 nc, continue_a3x8
	 xor	 0x1B
continue_a3x8:
	 ld	 (ix+11), a

	 ;do matrix multiply
	 ;for a[0]
	 ld	 a, (ix)	;0x0e x a[0]
	 xor	 (ix+1)
	 xor   (ix+2)
	 xor	 c			; x (0x0b x a[1])
	 xor	 (ix+3)
	 xor	 (ix+5)
	 xor	 d			; x (0x0d X a[2])
	 xor	 (ix+7)
	 xor	 (ix+8)
	 xor	 e			; x (0x09 x a[3])
	 xor	 (ix+11)
	 ld	 (iy), a		;load mixed a[0]

	 ;for a[1]
	 ld	 a, b		;0x09 x a[0]
	 xor   (ix+2)
	 xor	 (ix+3)	; x (0x0e x a[1])
	 xor	 (ix+4)
	 xor	 (ix+5)
	 xor	 d			; x (0x0b X a[2])
	 xor	 (ix+6)
	 xor	 (ix+8)
	 xor	 e			; x (0x0d x a[3])
	 xor	 (ix+10)
	 xor	 (ix+11)
	 ld	 (iy+1), a		;load mixed a[1]

	 ;for a[2]
	 ld	 a, b		;0x0d x a[0]
	 xor	 (ix+1)
	 xor   (ix+2)
	 xor	 c			; x (0x09 x a[1])
	 xor	 (ix+5)
	 xor	 (ix+6)	; x (0x0e X a[2])
	 xor	 (ix+7)
	 xor	 (ix+8)
	 xor	 e			; x (0x0b x a[3])
	 xor	 (ix+9)
	 xor	 (ix+11)
	 ld	 (iy+2), a		;load mixed a[2]

	 ;for a[3]
	 ld	 a, b		;0x0b x a[0]
	 xor	 (ix)
	 xor   (ix+2)
	 xor	 c			; x (0x0d x a[1])
	 xor	 (ix+4)
	 xor	 (ix+5)
	 xor	 d			; x (0x09 X a[2])
	 xor	 (ix+8)
	 xor	 (ix+9)	; x (0x0e x a[3])
	 xor	 (ix+10)
	 xor	 (ix+11)
	 ld	 (iy+3), a		;load mixed a[3]

	 dec	 L					;assume columns < 256
	 jr	 z, aes_invmixexit
	 ld	 de, 4
	 add	 iy, de
	 jp	 aes_invmixloop

aes_invmixexit:
	 ;restore stack
	 add	 sp, 12
	 pop	 ix

	 ret


#endasm

/*** BeginHeader AESinvMixColumns4 */
void AESinvMixColumns4(char *data);
/*** EndHeader */

#asm

AESimc_sub:
	; mix BCDE and return in same

	 ;calculate the mult table
	 ;for a[0]
    ld	 L,0x1A
	 ld	 a, e
	 rlca
	 jr	 nc, continue_a0x2
	 xor	 L
continue_a0x2:
	 ld	 e', a
	 rlca
	 jr	 nc, continue_a0x4
	 xor	 L
continue_a0x4:
	 ld	 d', a
	 rlca
	 jr	 nc, continue_a0x8
	 xor	 L
continue_a0x8:
	 ld	 h, a

	 ;for a[1]
	 ld	 a, d
	 rlca
	 jr	 nc, continue_a1x2
	 xor	 L
continue_a1x2:
	 ld	 c', a
	 rlca
	 jr	 nc, continue_a1x4
	 xor	 L
continue_a1x4:
	 ld	 b', a
	 rlca
	 jr	 nc, continue_a1x8
	 xor	 L
continue_a1x8:
	 xor	 h
	 ld	 h, a

	 ;for a[2]
	 ld	 a, c
	 rlca
	 jr	 nc, continue_a2x2
	 xor	 L
continue_a2x2:
	 ld	 l', a
	 rlca
	 jr	 nc, continue_a2x4
	 xor	 L
continue_a2x4:
	 ld	 h', a
	 rlca
	 jr	 nc, continue_a2x8
	 xor	 L
continue_a2x8:
	 xor	 h
	 ld	 h, a
    exx
    ld    (iy+6),hl
    exx

	 ;for a[3]
	 ld	 a, b
	 rlca
	 jr	 nc, continue_a3x2
	 xor	 L
continue_a3x2:
	 ld	 l', a
	 rlca
	 jr	 nc, continue_a3x4
	 xor	 L
continue_a3x4:
	 ld	 h', a
	 rlca
	 jr	 nc, continue_a3x8
	 xor	 L
continue_a3x8:
	 xor	 h
    xor	 e
    xor	 d
    xor	 c
    xor	 b
	 ld	 h, a

	 ;do matrix multiply
	 ;for a[0]
    exx
	 ld	 a,e
	 xor	 d
	 xor	 c
	 xor	 (iy+7)
    exx
	 xor	 e
	 xor	 h
	 ld	 e, a		;load mixed a[0]

	 ;for a[1]
    exx
	 ld	 a,c
	 xor	 b
	 xor	 (iy+6)
	 xor	 h
    exx
	 xor	 d
	 xor	 h
	 ld	 d, a		;load mixed a[1]

	 ;for a[2]
    exx
	 ld	 a,d
	 xor	 (iy+6)
	 xor	 (iy+7)
	 xor	 L
    exx
	 xor	 c
	 xor	 h
	 ld	 c, a		;load mixed a[2]

	 ;for a[3]
    exx
	 ld	 a,e
	 xor	 b
	 xor	 L
	 xor	 h
    exx
	 xor	 b
	 xor	 h
	 ld	 b, a		;load mixed a[3]

	 ret

#if _RAB4K
AESinvMixColumns4::
	push	iy
   add	sp,-12
   ld		iy,0
   add	iy,sp
	ld		bcde,pw
	call	AESimc_sub
   ld		pw,bcde
	ld		bcde,px
	call	AESimc_sub
   ld		px,bcde
	ld		bcde,py
	call	AESimc_sub
   ld		py,bcde
	ld		bcde,pz
	call	AESimc_sub
   ld		pz,bcde
   add	sp,12
   pop	iy
   ret
#else
AESinvMixColumns4::
	push	ix
	ld		ix, hl
   add	sp,-12
   ld		iy,0
   add	iy,sp
   ld		hl,(ix+0)
   ex		de,hl
   ld		hl,(ix+2)
   ld		b,h
   ld		c,L
	call	AESimc_sub
	ld		h,b
   ld		l,c
   ld		(ix+2),hl
   ex		de,hl
   ld		(ix+0),hl

   ld		hl,(ix+4)
   ex		de,hl
   ld		hl,(ix+6)
   ld		b,h
   ld		c,L
	call	AESimc_sub
	ld		h,b
   ld		l,c
   ld		(ix+6),hl
   ex		de,hl
   ld		(ix+4),hl
   ld		hl,(ix+8)
   ex		de,hl
   ld		hl,(ix+10)
   ld		b,h
   ld		c,L
	call	AESimc_sub
	ld		h,b
   ld		l,c
   ld		(ix+10),hl
   ex		de,hl
   ld		(ix+8),hl
   ld		hl,(ix+12)
   ex		de,hl
   ld		hl,(ix+14)
   ld		b,h
   ld		c,L
	call	AESimc_sub
	ld		h,b
   ld		l,c
   ld		(ix+14),hl
   ex		de,hl
   ld		(ix+12),hl
   add	sp,12
   pop	ix
   ret
#endif


#endasm

/*** Beginheader AESaddKey */
// takes pointer to data block, round key, and size of data block in columns (4,6, or 8)
void AESaddKey(char *block, char *key, int nb);
/*** EndHeader */

#asm

AESaddKey::
	AES_S(aes_s_addkey)
	 ld	 hl, (sp+4)		; 9  de holds pointer to key
	 ex	de,hl				; 2
	 ld	 hl, (sp+6)		; 9
	 add	hl,hl				; 2
	 add	hl,hl				; 2
	 ld	 b, L				; 2  b holds column count
	 ld	 hl, (sp+2)		; 9  hl holds block pointer : 35
aes_addkey_loop:
	 ld	 a, (de)			; 6
	 xor	 (hl)				; 5
	 ld	 (hl), a			; 6  XOR block with key
	 inc	 hl				; 2
	 inc	 de				; 2
	 djnz	aes_addkey_loop	; 5  : 26
	 ret	 					; 8 : total = 35 + 26*16 + 8 = 459

#endasm

/*** Beginheader AESaddKey4, AESinvAddKey4 */
// takes pointer to data block, round key, and size of data block in assumed to be 4 (16bytes)
void AESaddKey4(char *block, char *key);
#if _RAB4K
void AESinvAddKey4(char *block, char *key);
#endif
/*** EndHeader */

#asm

#if _RAB4K

AESaddKey4::
	; IY points to expanded key
	ld		bcde, pw
   ld		jkhl, (iy+0)
   xor	jkhl, bcde
   ld		pw, jkhl

	ld		bcde, px
   ld		jkhl, (iy+4)
   xor	jkhl, bcde
   ld		px, jkhl

	ld		bcde, py
   ld		jkhl, (iy+8)
   xor	jkhl, bcde
   ld		py, jkhl

	ld		bcde, pz
   ld		jkhl, (iy+12)
   xor	jkhl, bcde
   ld		pz, jkhl
	ld		de,16
   add	iy,de
   ret

AESinvAddKey4::
	; IY points to expanded key.
   ; This is same as above except key pointer is decremented at end
	ld		bcde, pw
   ld		jkhl, (iy+0)
   xor	jkhl, bcde
   ld		pw, jkhl

	ld		bcde, px
   ld		jkhl, (iy+4)
   xor	jkhl, bcde
   ld		px, jkhl

	ld		bcde, py
   ld		jkhl, (iy+8)
   xor	jkhl, bcde
   ld		py, jkhl

	ld		bcde, pz
   ld		jkhl, (iy+12)
   xor	jkhl, bcde
   ld		pz, jkhl
	ld		de,-16
   add	iy,de
   ret

#else

AESaddKey4::
	AES_S(aes_s_addkey)
	 ld	 hl, (sp+4)		; 9  de holds pointer to key
	 ex	de,hl				; 2
	 ld	 b,16				; 4  b holds byte count
	 ld	 hl, (sp+2)		; 9  hl holds block pointer : 24
aes_addkey4_loop:
	 ld	 a, (de)			; 6
	 xor	 (hl)				; 5
	 ld	 (hl), a			; 6  XOR block with key
	 inc	 hl				; 2
	 inc	 de				; 2
	 djnz	aes_addkey4_loop	; 5  : 26
	 ret	 					; 8 : total = 24 + 26*16 + 8 = 448

#endif

#endasm


/*** Beginheader AESexpandKey */
// takes pointer to space for expanded key, pointer to cipher key, numbers for Nb, Nk
void AESexpandKey(char *expanded, char *key, int nb, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESexpandKey                   <AES_CRYPT.LIB>

SYNTAX:		   void AESexpandKey(char *expanded,
											 char *key,
											 int nb,
											 int nk);

DESCRIPTION:   Prepares a key for use by expanding it into a set of round
					keys.

               Note: previous versions required the number of rounds
               to be specified.  This is now calculated automatically.

PARAMETER1:		expanded - A buffer for storing the expanded key. The size of
						the expanded key is 4*nb*(rounds+1)
                  where rounds is according to following table:
                  nk      rounds    AES usage
                  -----   --------  ----------
                  4       10        AES-128
                  6       12        AES-192
                  8       14        AES-256
               Other key sizes are not supported.
PARAMETER2:		key - the cipher key, the size in bytes should be 4*nk
PARAMETER3:		nb - the block size to use; must be '4' for AES.
PARAMETER4:		nk - the key size to use; must be 4,6 or 8 for AES.

END DESCRIPTION **********************************************************/

nodebug void AESexpandKey(char *expanded, char *key, int nb, int nk)
{
	auto int i, j, columns;
	auto char temp[4];
	auto char other_temp[4];
	auto char temp_byte;
   auto int rounds;

   rounds = AEScalcRounds(nb, nk);

	//copy cipher key into beginning of expanded key
	memcpy(expanded, key, 4*nk);

	columns = nb * (rounds + 1);
	memcpy(temp, expanded + 4*(nk - 1), 4);	//get first temp column
	for(i = nk; i < columns;i++)
	{
		if(i % nk == 0)
		{
			//rotate
			temp_byte = temp[0];
			temp[0] = temp[1];
			temp[1] = temp[2];
			temp[2] = temp[3];
			//memcpy(temp, temp+1, 3);
			temp[3] = temp_byte;
			//sub
			AESsubBytes(AESsbox, temp, 4);
			//add rcon
			temp[0] ^= AESrcon[i / nk - 1]; //AESrcon[0] is for second round
		}
		if(nk > 6 && i % nk == 4)
		{
			AESsubBytes(AESsbox, temp, 4);
		}
		memcpy(other_temp, expanded+(4*(i-nk)), 4);
		temp[0] ^= other_temp[0];
		temp[1] ^= other_temp[1];
		temp[2] ^= other_temp[2];
		temp[3] ^= other_temp[3];
		memcpy(expanded + (4*i), temp, 4);
	}
}

/*** Beginheader AESencrypt */
// takes data block, expanded key, Nb, and Nk
void AESencrypt(char *data, char *expandedkey, int nb, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESencrypt                  <AES_CRYPT.LIB>

SYNTAX:		   void AESencrypt(char *data,
									 	 char *expandedkey,
										 int nb,
										 int nk );

DESCRIPTION:   Encrypts a block of data in place
               Note that AES (as such) uses only nb==4 and
               nk==4,6 or 8.  Rijndael allows different block and key
               sizes than AES, however performance will be slower if
               nb is not 4.

               You can #define AES_ONLY before #use AES_CRYPT.LIB if
               you are adhering to AES.  This saves some code space.

PARAMETER1:		data - A block of data to be encrypted; must be nb*4 bytes.
PARAMETER2:		expandedkey - a set of round keys (generated by AESexpandKey,
               with the same nb and nk parameters!)
PARAMETER3:		nb - the block size to use. Block is 4*nb bytes long.
               Must be '4' for AES.
PARAMETER4:		nk - the key size to use. Cipher key is 4*nk bytes long.
               Must be 4,6 or 8 for AES.

END DESCRIPTION **********************************************************/


nodebug void AESencrypt(char *data, char *expandedkey, int nb, int nk)
{
	int rounds, i, j;


#ifdef AES_ONLY
	AESencrypt4(data, expandedkey, nk);

#else

	if (nb == 4) {
		AESencrypt4(data, expandedkey, nk);
      return;
   }

	rounds = AEScalcRounds(nb, nk);
	//initial key addition
	AESaddKey(data, expandedkey, nb);
	//do rounds
	for(i = 1;i < rounds;i++)
	{
		AESsubBytes(AESsbox, data, 4*nb);
		AESshiftRows(data, nb);
		AESmixColumns(data, nb);
		AESaddKey(data, expandedkey + 4*nb*i, nb);
	}
	//final round
	AESsubBytes(AESsbox, data, 4*nb);
	AESshiftRows(data, nb);
	AESaddKey(data, expandedkey + 4*nb*rounds, nb);

#endif // AES_ONLY
}

/*** Beginheader AESencrypt4 */
// takes data block, expanded key.  Optimized for Nb=4.
void AESencrypt4(char *data, char *expandedkey, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESencrypt44                  <AES_CRYPT.LIB>

SYNTAX:		   void AESencrypt4(char *data,
									 	 char *expandedkey,
                               int nk);

DESCRIPTION:   Encrypts a block of data in place.  Same as AESencrypt()
               except optimized for most common case of 16-byte block
               size (the only size supported for AES as such).

PARAMETER1:		data - A block of data to be encrypted
PARAMETER2:		expandedkey - a set of round keys (generated by AESexpandKey)
PARAMETER2:		nk - key size in longwords.  Must be 4,6 or 8 for AES.

END DESCRIPTION **********************************************************/


nodebug void AESencrypt4(char *data, char *expandedkey, int nk)
{
	auto int rounds;
	auto word i;

	rounds = 6+nk;

#if _RAB4K
#asm
	push	pw		; These regs must be preserved

   ldl	pz,(sp+@sp+data+4)	; Data block
   ld		pw,(pz+0)
   ld		px,(pz+4)
   ld		py,(pz+8)
   ld		pz,(pz+12)

   ld		iy,(sp+@sp+expandedkey+4)

	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4

   ld		hl,(sp+@sp+rounds+4)
   ld		a,L
   cp		10
   jr		z,.rounds_10
   cp		12
   jr		z,.rounds_12

.rounds_14:
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
.rounds_12:
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
.rounds_10:
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4
	call	AESsubBytes4
	call	AESshiftRows4
	call	AESmixColumns4
	call	AESaddKey4

	call	AESsubBytes4					; last round
	call	AESshiftRows4
	call	AESaddKey4

   ld		bcde,pz
   ldl	pz,(sp+@sp+data+4)
   ld		(pz+0),pw
   ld		(pz+4),px
   ld		(pz+8),py
   ld		(pz+12),bcde

   pop	pw
#endasm
#else

	//initial key addition
	AESaddKey4(data, expandedkey);
	expandedkey += 16;
	//do rounds
	for(i = 1;i < rounds;i++)
	{
		AESsubBytes4(data);
		AESshiftRows4(data);
		AESmixColumns4(data);
		AESaddKey4(data, expandedkey);
		expandedkey += 16;
	}
	//final round
	AESsubBytes4(data);
	AESshiftRows4(data);
	AESaddKey4(data, expandedkey);
#endif
}

/*** Beginheader AESdecrypt */
// takes data block, expanded key, Nb, and Nk
void AESdecrypt(char *data, char *expandedkey, int nb, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESdecrypt                  <AES_CRYPT.LIB>

SYNTAX:		   void AESdecrypt(char *data,
									 	 char *expandedkey,
										 int nb,
										 int nk );

DESCRIPTION:   Decrypts a block of data in place

PARAMETER1:		data - A block of data to be decrypted
PARAMETER2:		expandedkey - a set of round keys (generated by AESexpandKey)
PARAMETER3:		nb - the block size to use. Block is 4*nb bytes long
PARAMETER4:		nk - the key size to use. Cipher key is 4*nk bytes long

END DESCRIPTION **********************************************************/


nodebug void AESdecrypt(char *data, char *expandedkey, int nb, int nk)
{
	int rounds, i, j;

#ifdef AES_ONLY
	AESdecrypt4(data, expandedkey, nk);

#else

	if (nb == 4) {
		AESdecrypt4(data, expandedkey, nk);
      return;
   }

	rounds = AEScalcRounds(nb, nk);

	//first round
	AESaddKey(data, expandedkey + 4*nb*rounds, nb);
	AESinvShiftRows(data, nb);
	AESsubBytes(AESsboxI, data, 4*nb);
	//do rounds
	for(i = rounds-1;i > 0;i--)
	{
		AESaddKey(data, expandedkey + 4*nb*i, nb);
		AESinvMixColumns(data, nb);
		AESinvShiftRows(data, nb);
		AESsubBytes(AESsboxI, data, 4*nb);
	}
	//last key addition
	AESaddKey(data, expandedkey, nb);
#endif
}

/*** Beginheader AESdecrypt4 */
// takes data block, expanded key, Nb=4, and Nk
void AESdecrypt4(char *data, char *expandedkey, int nk);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
AESdecrypt                  <AES_CRYPT.LIB>

SYNTAX:		   void AESdecrypt4(char *data,
									 	 char *expandedkey,
										 int nk );

DESCRIPTION:   Decrypts a block of data in place.  This function assumes
               that the block size (Nb) is 4 words (i.e. 16 bytes).  This
               is always the case for AES, in which case this function is
               more efficient than the general purpose AESdecrypt().

PARAMETER1:		data - A block of data to be decrypted
PARAMETER2:		expandedkey - a set of round keys (generated by AESexpandKey)
PARAMETER3:		nk - the key size to use. Cipher key is 4*nk bytes long.
               This parameter should be 4,6 or 8 for AES-128, AES-192 or
               AES-256 respectively.

END DESCRIPTION **********************************************************/


nodebug void AESdecrypt4(char *data, char *expandedkey, int nk)
{
	auto word rounds, i;
	auto char * ek;

	rounds = AEScalcRounds(4, nk);
	ek = expandedkey + (rounds<<4);

#if _RAB4K

#asm
	push	pw		; These regs must be preserved

   ldl	pz,(sp+@sp+data+4)	; Data block
   ld		pw,(pz+0)
   ld		px,(pz+4)
   ld		py,(pz+8)
   ld		pz,(pz+12)

   ld		iy,(sp+@sp+ek+4)

   call  AESinvAddKey4
   call	AESinvShiftRows4
   call	AESinvSubBytes4

   ld		hl,(sp+@sp+rounds+4)
   ld		a,L
   cp		10
   jr		z,.rounds_10
   cp		12
   jr		z,.rounds_12

.rounds_14:
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
.rounds_12:
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
.rounds_10:
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4
   call  AESinvAddKey4
   call	AESinvMixColumns4
   call	AESinvShiftRows4
   call	AESinvSubBytes4

   call	AESinvAddKey4

   ld		bcde,pz
   ldl	pz,(sp+@sp+data+4)
   ld		(pz+0),pw
   ld		(pz+4),px
   ld		(pz+8),py
   ld		(pz+12),bcde

   pop	pw
#endasm
#else

	//first round
	AESaddKey4(data, ek);
   ek -= 16;
	AESinvShiftRows4(data);
	AESinvSubBytes4(data);
	//do rounds
	for(i = rounds-1;i > 0;i--)
	{
		AESaddKey4(data, ek);
      ek -= 16;
		AESinvMixColumns4(data);
		AESinvShiftRows4(data);
		AESinvSubBytes4(data);
	}
	//last key addition
	AESaddKey4(data, expandedkey);
#endif
}

/*** Beginheader AEScalcRounds */
// takes Nb and Nk, returns number of rounds to use
int AEScalcRounds(int nb, int nk);
/*** EndHeader */

nodebug int AEScalcRounds(int nb, int nk)
{
	if(nb == 4 && nk == 4)
	{
		return 10;
	}
	else if(nb == 8 || nk == 8)
	{
		return 14;
	}
	else
	{
		return 12;
	}
}



//tables
/*** BeginHeader AESsbox */
extern const char AESsbox[256];
/*** Endheader */

const char AESsbox[256] = {
 99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 103,  43, 254, 215, 171, 118,
202, 130, 201, 125, 250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 114, 192,
183, 253, 147,  38,  54,  63, 247, 204,  52, 165, 229, 241, 113, 216,  49,  21,
  4, 199,  35, 195,  24, 150,   5, 154,   7,  18, 128, 226, 235,  39, 178, 117,
  9, 131,  44,  26,  27, 110,  90, 160,  82,  59, 214, 179,  41, 227,  47, 132,
 83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 190,  57,  74,  76,  88, 207,
208, 239, 170, 251,  67,  77,  51, 133,  69, 249,   2, 127,  80,  60, 159, 168,
 81, 163,  64, 143, 146, 157,  56, 245, 188, 182, 218,  33,  16, 255, 243, 210,
205,  12,  19, 236,  95, 151,  68,  23, 196, 167, 126,  61, 100,  93,  25, 115,
 96, 129,  79, 220,  34,  42, 144, 136,  70, 238, 184,  20, 222,  94,  11, 219,
224,  50,  58,  10,  73,   6,  36,  92, 194, 211, 172,  98, 145, 149, 228, 121,
231, 200,  55, 109, 141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 174,   8,
186, 120,  37,  46,  28, 166, 180, 198, 232, 221, 116,  31,  75, 189, 139, 138,
112,  62, 181, 102,  72,   3, 246,  14,  97,  53,  87, 185, 134, 193,  29, 158,
225, 248, 152,  17, 105, 217, 142, 148, 155,  30, 135, 233, 206,  85,  40, 223,
140, 161, 137,  13, 191, 230,  66, 104,  65, 153,  45,  15, 176,  84, 187,  22,
};

/*** BeginHeader AESsboxI */
extern const char AESsboxI[256];
/*** Endheader */

const char AESsboxI[256] = {
 82,   9, 106, 213,  48,  54, 165,  56, 191,  64, 163, 158, 129, 243, 215, 251,
124, 227,  57, 130, 155,  47, 255, 135,  52, 142,  67,  68, 196, 222, 233, 203,
 84, 123, 148,  50, 166, 194,  35,  61, 238,  76, 149,  11,  66, 250, 195,  78,
  8,  46, 161, 102,  40, 217,  36, 178, 118,  91, 162,  73, 109, 139, 209,  37,
114, 248, 246, 100, 134, 104, 152,  22, 212, 164,  92, 204,  93, 101, 182, 146,
108, 112,  72,  80, 253, 237, 185, 218,  94,  21,  70,  87, 167, 141, 157, 132,
144, 216, 171,   0, 140, 188, 211,  10, 247, 228,  88,   5, 184, 179,  69,   6,
208,  44,  30, 143, 202,  63,  15,   2, 193, 175, 189,   3,   1,  19, 138, 107,
 58, 145,  17,  65,  79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115,
150, 172, 116,  34, 231, 173,  53, 133, 226, 249,  55, 232,  28, 117, 223, 110,
 71, 241,  26, 113,  29,  41, 197, 137, 111, 183,  98,  14, 170,  24, 190,  27,
252,  86,  62,  75, 198, 210, 121,  32, 154, 219, 192, 254, 120, 205,  90, 244,
 31, 221, 168,  51, 136,   7, 199,  49, 177,  18,  16,  89,  39, 128, 236,  95,
 96,  81, 127, 169,  25, 181,  74,  13,  45, 229, 122, 159, 147, 201, 156, 239,
160, 224,  59,  77, 174,  42, 245, 176, 200, 235, 187,  60, 131,  83, 153,  97,
 23,  43,   4, 126, 186, 119, 214,  38, 225, 105,  20,  99,  85,  33,  12, 125,
};

/*** BeginHeader AESrcon */
extern const char AESrcon[30];
/*** Endheader */

const char AESrcon[30] = {
  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
  0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4,
  0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 };



/*** BeginHeader */
#endif
/*** EndHeader */

