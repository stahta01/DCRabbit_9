/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** Beginheader */
#ifndef __RNET_AIN_LIB
#define __RNET_AIN_LIB
/*** Endheader */

/* START LIBRARY DESCRIPTION *********************************************
RNET_AIN.LIB

DESCRIPTION:	Support for RabbitNet RN1200 Analog-to-Digital boards
					and analog section of RN1100 Digital I/O boards.

SUPPORT LIBS:

REVISION HISTORY:
	01/20/04	pel	Added support device	timing.
	10/10/03 pel	Changed !=RNREADY to ==RNBUSY in rn_anaIn().
	07/09/03	pel	RN1100 sections in anaInVolts()and anaInDiff().
   					_rn_dio_ai_in() should be _rn_dio_ai_volts().
	06/20/03 EK    Changed code to be able to access 2nd Rabbitnet Port.
	05/20/03 pel	Contains both analog functions for both RN1200 and
   					RN1100.
	05/06/03	pel	Initial creation.

END DESCRIPTION **********************************************************/

/*** Beginheader rn_AinData */
// macro that user can identify with in applications
#ifndef RN1200
#define RN1200 RN1200A
#endif

// this macro overrides default microcode timing
#ifndef _RN1200TIME
#define _RN1200TIME {tCS=2; tCD=29; tDD=17; tDS=20; tMC=6;}
#endif

///// Command Set
/// regnum is octal
/// datalen is byte count
/////
/// read registers
#define AINR10	{regnum=0110; datalen=1;}	//Read ADC channel update status

#define AINR20	{regnum=0120; datalen=8;}	//AIN00 raw, gain, offset
#define AINR21	{regnum=0121; datalen=8;}	//AIN01 raw, gain, offset
#define AINR22	{regnum=0122; datalen=8;}	//AIN02 raw, gain, offset
#define AINR23	{regnum=0123; datalen=8;}	//AIN03 raw, gain, offset
#define AINR24	{regnum=0124; datalen=8;}	//AIN04 raw, gain, offset
#define AINR25	{regnum=0125; datalen=8;}	//AIN05 raw, gain, offset
#define AINR26	{regnum=0126; datalen=8;}	//AIN06 raw, gain, offset
#define AINR27	{regnum=0127; datalen=8;}	//AIN07 raw, gain, offset

#define AINR30	{regnum=0130; datalen=6;}	//AIN00 gain, offset
#define AINR31	{regnum=0131; datalen=6;}	//AIN01 gain, offset
#define AINR32	{regnum=0132; datalen=6;}	//AIN02 gain, offset
#define AINR33	{regnum=0133; datalen=6;}	//AIN03 gain, offset
#define AINR34	{regnum=0134; datalen=6;}	//AIN04 gain, offset
#define AINR35	{regnum=0135; datalen=6;}	//AIN05 gain, offset
#define AINR36	{regnum=0136; datalen=6;}	//AIN06 gain, offset
#define AINR37	{regnum=0137; datalen=6;}	//AIN07 gain, offset

#define AINR40	{regnum=0140; datalen=1;}	//read A/D reg, initiated by AINW40

/// write registers
#define AINW10	{regnum=0010; datalen=1;}	//AIN0 configure opcode, gaincode
#define AINW11	{regnum=0011; datalen=1;}	//AIN1 configure opcode, gaincode
#define AINW12	{regnum=0012; datalen=1;}	//AIN2 configure opcode, gaincode
#define AINW13	{regnum=0013; datalen=1;}	//AIN3 configure opcode, gaincode
#define AINW14	{regnum=0014; datalen=1;}	//AIN4 configure opcode, gaincode
#define AINW15	{regnum=0015; datalen=1;}	//AIN5 configure opcode, gaincode
#define AINW16	{regnum=0016; datalen=1;}	//AIN6 configure opcode, gaincode
#define AINW17	{regnum=0017; datalen=1;}	//AIN7 configure opcode, gaincode

#define AINW20	{regnum=0020; datalen=0;}	//AIN0 start conversion
#define AINW21	{regnum=0021; datalen=0;}	//AIN1 start conversion
#define AINW22	{regnum=0022; datalen=0;}	//AIN2 start conversion
#define AINW23	{regnum=0023; datalen=0;}	//AIN3 start conversion
#define AINW24	{regnum=0024; datalen=0;}	//AIN4 start conversion
#define AINW25	{regnum=0025; datalen=0;}	//AIN5 start conversion
#define AINW26	{regnum=0026; datalen=0;}	//AIN6 start conversion
#define AINW27	{regnum=0027; datalen=0;}	//AIN7 start conversion

#define AINW30	{regnum=0030; datalen=8; key0=0x56; key1=0xAE;}	//AIN00 gain, offset
#define AINW31	{regnum=0031; datalen=8; key0=0x56; key1=0xAE;}	//AIN01 gain, offset
#define AINW32	{regnum=0032; datalen=8; key0=0x56; key1=0xAE;}	//AIN02 gain, offset
#define AINW33	{regnum=0033; datalen=8; key0=0x56; key1=0xAE;}	//AIN03 gain, offset
#define AINW34	{regnum=0034; datalen=8; key0=0x56; key1=0xAE;}	//AIN04 gain, offset
#define AINW35	{regnum=0035; datalen=8; key0=0x56; key1=0xAE;}	//AIN05 gain, offset
#define AINW36	{regnum=0036; datalen=8; key0=0x56; key1=0xAE;}	//AIN06 gain, offset
#define AINW37	{regnum=0037; datalen=8; key0=0x56; key1=0xAE;}	//AIN07 gain, offset

#define AINW40	{regnum=0040; datalen=1;}	//Send command to read A/D device
#define AINW41	{regnum=0041; datalen=2;}	//write command directly to A/D device


/// user opmode parameters
#ifndef RNSINGLE
#define RNSINGLE 0
#endif

#ifndef RNDIFF
#define RNDIFF 1
#endif

#ifndef RNmAMP
#define RNmAMP 2
#endif

#ifndef RNmAMP_GAINCODE
#define RNmAMP_GAINCODE 4
#endif


#define ADCENABLE 	1
#define ADCDISABLE 	0

typedef struct
{
	int rawdata;
   float gain;
   int offset;
} rn_AinData;
/*** Endheader */


/*** BeginHeader rn_anaIn */

int rn_anaIn(int handle, int channel, int *retdata, int sample, int reserved);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
rn_anaIn							<RNET_AIN.LIB>

SYNTAX:			int rn_anaIn(int handle, int channel, int *retdata,
									 int sample, int reserved);

DESCRIPTION:	Reads the raw data value of an analog input channel.

               By setting the sample parameter to a value greater than
               one, the readings taken will be averaged.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:    For analog input on Analog-to-Digital boards:
					Channel number 0 to 7 for AIN00-AIN07. Voltage range
               will be depend on the gain code you specified in the
               rn_anaInConfig function.

               Gaincode  Actual Gain     Single-Ended    Differential
					--------  -----------	 --------------   ------------
		 				0 		 	(x1)			   0 - 20v         +- 20v
		 				1 		  	(x2)			   0 - 10v         +- 10v
		 				2 		 	(x4)			   0 - 5v          +- 5v
		 				3 		 	(x5)			   0 - 4v          +- 4v
		 				4 		 	(x8)			   0 - 2.5v        +- 2.5v
		 				5 		 	(x10)	 		   0 - 2v          +- 2v
		 				6 		 	(x16)			   0 - 1.25v       +- 1.25v
		 				7 		 	(x20)			   0 - 1v          +- 1v
					==========================================================

					For analog input on Digital I/O boards:
 					Channel number 0 to 3, AIN00-AIN03.
					AIN00,  0 to +10V
					AIN01,  0 to +10V
					AIN02,  0 to +1V
               AIN03,  +/- 250mV

PARAMETER3:		Pointer to a integer rawdata value, which will be
               updated for the channel being accessed.

               ADC Board:
               ----------
               Raw data value of  0-2047, for 11 bit A/D conversions
               with a signed 12th bit.

               Digital I/O Board:
               ------------------
               Raw data value of 0 - 1023, for 10 bit A/D conversions

PARAMETER4:    X number of samples.

					ADC Board:
               ----------
               1  Read current value of the given ADC channel.

               >1 Read given channel x times, and average the readings
                  taken.

               Digital I/O board:
               ------------------
              	1 sample = approximately 500 microseconds.
               >1 samples = each sampling will wait for an updated conversion,
               this may take 40 to 160 microseconds longer depending if one or
               all channels are enabled.


PARAMETER5:		Reserved.  Set as 0.

RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command.

SEE ALSO:		rn_anaInConfig, rn_anaInVolts, rn_anaInmAmps, rn_anaInDiff

END DESCRIPTION **********************************************************/

nodebug
int rn_anaIn(int handle, int channel, int *retdata,
             int sample, int reserved)
{
	auto int msgcode, regnum, datalen, smp, cmd1, cmd2;
	auto rn_devstruct *devaddr;
	auto rn_AinData adata;
   auto long totalsmp;

   auto rnDataSend ds;
   auto rnDataRec dr;
   auto int i;

   *retdata = 0;
	devaddr = (rn_devstruct *)handle;
	if (devaddr->productid == RN1100A)
	{
   	if (sample == 0)
      	sample++;
		for (smp=0, totalsmp=0; smp<sample; smp++)
  		{
  	      do {
				msgcode = _rn_dio_ai_in(handle, channel, (char*)&adata, sample);
         }	while ((msgcode&RNDEVSTATE)==RNBUSY);
         if (msgcode&(RNCMDREJ|RNWDTO))	//cmd reject or wdtimeout
           	break;
     		totalsmp+= (long)adata.rawdata;
      }

      if ( !(msgcode&(RNCMDREJ|RNWDTO)) )		//cmd reject or wdtimeout)
      {
   	  	*retdata = (int)(totalsmp/sample);
      }
	}
	else
	{
      adata.rawdata=0xffff;   //filled as dummy bytes

     	AINW20;	 //start the conversion busy
   	cmd1 = regnum+channel;

     	AINR20;	//read conversion register
   	cmd2 = regnum+channel;
     	datalen++;  // Add 1 for the command byte

     	for (smp=0, totalsmp=0; smp<sample; smp++)
		{
   		ds.cmd = cmd1;
         _rn_sp_fastenable(devaddr->portnum);
         _mosi_driver(1, &ds, &dr, &devaddr->cmdtiming, &rn_spi[devaddr->portnum]);
         _rn_sp_fastdisable(devaddr->portnum);
         for(i=0; i<20; i++);
        	do
         {
         	ds.cmd = cmd2;
            _rn_sp_fastenable(devaddr->portnum);
            _mosi_driver(datalen-6, &ds, &dr, &devaddr->cmdtiming, &rn_spi[devaddr->portnum]);
            _rn_sp_fastdisable(devaddr->portnum);
	      }	while ((dr.statusbyte&RNDEVSTATE)==RNBUSY);
         if (dr.statusbyte&(RNCMDREJ|RNWDTO))	//cmd reject or wdtimeout
         	break;
         memcpy(&adata.rawdata, &dr.miso[0], 2);
         if(sample > 1)
         	totalsmp += (long)adata.rawdata;
      }
      msgcode = dr.statusbyte;

      if(sample > 1)
      	adata.rawdata = (int) (totalsmp/sample);
      else
         adata.rawdata = adata.rawdata;

      // check bit 12 for sign and sign extend
		if (adata.rawdata&0x0800)
			adata.rawdata = adata.rawdata|0xf000;
      *retdata  = adata.rawdata;
   }
	return (msgcode);
}

/*** BeginHeader rn_anaInVolts */
int rn_anaInVolts(int handle, int channel, float *retdata,
                  int sample, int reserved);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
rn_anaInVolts					<RNET_AIN.LIB>

SYNTAX:			int rn_anaInVolts(int handle, int channel, float *retdata,
											int sample, int reserved)

DESCRIPTION:	Reads the state of a single-ended analog input channel.

               By setting the sample parameter to a value greater than
               one, the readings taken will be averaged.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:		Channel number 0 to 7 for AIN00-AIN07. Voltage range
               will be depend on the gain code you specified in the
               rn_anaInConfig function.

               Gaincode  Actual Gain     Single-Ended
					--------  -----------	 --------------
		 				0 		 	(x1)			   0 - 20v
		 				1 		  	(x2)			   0 - 10v
		 				2 		 	(x4)			   0 - 5v
		 				3 		 	(x5)			   0 - 4v
		 				4 		 	(x8)			   0 - 2.5v
		 				5 		 	(x10)	 		   0 - 2v
		 				6 		 	(x16)			   0 - 1.25v
		 				7 		 	(x20)			   0 - 1v
					=========================================

					For analog input on Digital I/O boards:
 					Channel numbers 0 - 2, AIN00-AIN02.
					AIN00,  0 to +10V
					AIN01,  0 to +10V
					AIN02,  0 to +1V

PARAMETER3:    Pointer to a floating point voltage value, which will be
               updated for the channel being accessed.
               (represented in units of volts)

					Note:	If theres a data overflow or out of range error,
               the value will be set to -4096 (as defined by macro
               ADOVERFLOW)

PARAMETER4:    X number of samples.

					ADC Board:
               ----------
               1  Read current value of the given ADC channel.

               >1 Read given channel x times, and average the readings
                  taken.

               Digital I/O board:
               ------------------
               1 sample = approximately 675 microseconds.
               >1 samples = each sampling will wait for an updated conversion,
               this may take 40 to 160 microseconds longer depending if one or
               all channels are enabled.


PARAMETER5:		Reserved.  Set as 0.

RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command.

SEE ALSO:		rn_anaInConfig, rn_anaIn, rn_anaInmAmps, rn_anaInDiff

END DESCRIPTION **********************************************************/

nodebug
int rn_anaInVolts(int handle, int channel, float *retdata,
                  int sample, int reserved)
{
	auto int msgcode, regnum, datalen, smp;
	auto rn_devstruct *devaddr;
	auto rn_AinData adata;
   auto long totalsmp;
   auto int i;

   *retdata = 0;
	devaddr = (rn_devstruct *)handle;
	if (devaddr->productid == RN1100A)
	{
   	if (sample == 0)
      	sample++;
		for (smp=0, totalsmp=0; smp<sample; smp++)
  		{
  	      do {
				msgcode = _rn_dio_ai_volts(handle, channel, (char*)&adata, sample);
         }	while ((msgcode&RNDEVSTATE)==RNBUSY);
         if (msgcode&(RNCMDREJ|RNWDTO))	//cmd reject or wdtimeout
           	break;
     		totalsmp+= (long) adata.rawdata;
      }
      if ( !(msgcode&(RNCMDREJ|RNWDTO)) )		//cmd reject or wdtimeout)
      {
   	  	adata.rawdata = (int)(totalsmp/sample);
		   if (adata.rawdata >= 1023)
   			*retdata = ADOVERFLOW;
         else
         {
				*retdata = _rn_dio_ai_convert(channel, adata.rawdata,
                                          adata.gain, adata.offset);
			   if (*retdata < 0.0)
   				*retdata = 0.0;
         }
      }
	}
	else
	{
   	adata.rawdata=0xffff;  	//filled as dummy bytes
    	for (smp=0, totalsmp=0; smp<sample; smp++)
		{
     	 	AINW20;	 //start the conversion busy
   		regnum+=channel;
      	msgcode = rn_write(handle, regnum, (char*)&adata, datalen);

	  		AINR20;	//read conversion register
   		regnum+=channel;
         for(i=0; i <20; i++);

        	do
         {
				msgcode = rn_read(handle, regnum, (char*)&adata, datalen);
	     	}	while ((msgcode&RNDEVSTATE)==RNBUSY);
        	if (msgcode&(RNCMDREJ|RNWDTO))	//cmd reject or wdtimeout
        		break;

   		totalsmp+= (long) adata.rawdata;
      }
     	adata.rawdata = (int)(totalsmp/sample);
      if (adata.rawdata&0x0800)  			//check bit 12 for sign and sign extend
      {
			adata.rawdata = adata.rawdata|0xf000;
      }
      if (adata.rawdata >= 2047)
      {
  			*retdata = ADOVERFLOW;
         return (msgcode);
      }
      *retdata = (adata.rawdata - adata.offset)*adata.gain;
  	}
	return (msgcode);
}


/*** BeginHeader rn_anaInDiff */

int rn_anaInDiff(int handle, int channel, float *retdata,
                 int sample, int reserved);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
rn_anaInDiff 					<RNET_AIN.LIB>

SYNTAX:			int rn_anaInDiff(int handle, int channel, float *retdata,
						              int sample, int reserved);

DESCRIPTION:	Reads the state of a differential analog input channel.

               By setting the sample parameter to a value greater than
               one, the readings taken will be averaged.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:    Channel Number, is as follows:

					ADC Board:
               ----------
					Channel 0, 2, 4, or 6 as indicated by the differential
					positive line input. See below.

					==============================================
					channel		Differential input lines
					----------	-------------------------------
		 				0			+AIN00 	-AIN01
		 				2			+AIN02 	-AIN03
		 				4			+AIN04 	-AIN05
		 				6			+AIN06 	-AIN07
					==============================================

               Voltage range will be depend on the gain code you specified
               in the rn_anaInConfig function.

               Gaincode  Actual Gain     Differential
					--------  -----------	 --------------
		 				0 		 	(x1)			   +- 20v
		 				1 		  	(x2)			   +- 10v
		 				2 		 	(x4)			   +- 5v
		 				3 		 	(x5)			   +- 4v
		 				4 		 	(x8)			   +- 2.5v
		 				5 		 	(x10)	 		   +- 2v
		 				6 		 	(x16)			   +- 1.25v
		 				7 		 	(x20)			   +- 1v
					===============================================

               Digital I/O board:
               ------------------
					Only channel 3 (AIN03), which has a fixed range
               of +/- 250mV

PARAMETER3:		Pointer to a floating point voltage value, which will be
               updated for the channel being accessed.
               (represented in units of volts)

					Note:	If theres a data overflow or out of range error,
               the value will be set to -4096 (as defined by macro
               ADOVERFLOW)

PARAMETER4:    X number of samples.

					ADC Board:
               ----------
               1  Read current value of the given ADC channel.

               >1 Read given channel x times, and average the readings
                  taken.

               Digital I/O board:
               ------------------
					1 sample = approximately 675 microseconds.
               >1 samples = each sampling will wait for an updated conversion,
               this may take 40 to 160 microseconds longer depending if one or
               all channels are enabled.

PARAMETER5:		Reserved.  Set as 0.


RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command.

SEE ALSO:		rn_anaInConfig, rn_anaIn, rn_anaInmAmps, rn_anaInVolts

END DESCRIPTION **********************************************************/

nodebug
int rn_anaInDiff(int handle, int channel, float *retdata,
                 int sample, int reserved)
{
	auto int msgcode, regnum, datalen, smp;
	auto rn_devstruct *devaddr;
	auto rn_AinData adata;
   auto long totalsmp;
   auto int i;

   *retdata = 0;
	devaddr = (rn_devstruct *)handle;
	if (devaddr->productid == RN1100A)
	{
   	if (sample == 0)
      	sample++;
		for (smp=0, totalsmp=0; smp<sample; smp++)
  		{
			msgcode = _rn_dio_ai_volts(handle, channel, (char*)&adata, sample);
        	if ((msgcode&RNCMDREJ) == RNCMDREJ)
         	break;
     		totalsmp+= (long)adata.rawdata;
      }
     	adata.rawdata = (int)(totalsmp/sample);
	   if (adata.rawdata >= 1023)
  			*retdata = ADOVERFLOW;
      else
      {
			*retdata = _rn_dio_ai_convert(channel, adata.rawdata,
                                       adata.gain, adata.offset);
      }
	}
	else
	{
		adata.rawdata=0xffff;		//filled as dummy bytes
    	for (smp=0, totalsmp=0; smp<sample; smp++)
		{
     	  	AINW20;	 //start the conversion busy
   		regnum+=channel;
      	msgcode = rn_write(handle, regnum, (char*)&adata, datalen);

	  		AINR20;	//read conversion register
   		regnum+=channel;
         for(i=0; i <20; i++);

        	do
         {
				msgcode = rn_read(handle, regnum, (char*)&adata, datalen);
	     	}	while ((msgcode&RNDEVSTATE)==RNBUSY);
        	if (msgcode&(RNCMDREJ|RNWDTO))	//cmd reject or wdtimeout
        		break;

   		totalsmp+= (long)adata.rawdata;
      }
      adata.rawdata = (int)(totalsmp/sample);
      if (adata.rawdata&0x0800)  			//check bit 12 for sign and sign extend
      {
			adata.rawdata = adata.rawdata|0xf000;
      }
      if (adata.rawdata >= 2047 || adata.rawdata <= -2048)
      {
  			*retdata = ADOVERFLOW;
         return (msgcode);
      }
		*retdata = (adata.rawdata - adata.offset)*adata.gain;
	}
	return (msgcode);
}

/*** BeginHeader rn_anaInmAmps */

int rn_anaInmAmps(int handle, int channel, float *retdata,
                  int sample, int reserved);

/*** EndHeader */

/* START FUNCTION DESCRIPTION *************************************************
rn_anaInmAmps					<RNET_AIN.LIB>

SYNTAX:			int rn_anaInmAmps(int handle, int channel, float *retdata,
											int sample, int reserved);

DESCRIPTION:	Reads the state of a milli-Amp analog input channel.

               By setting the sample parameter to a value greater than
               one, the readings taken will be averaged.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:    Channel number, is as follows:

               ADC board:
               ----------
					0 - 7 (AIN00-AIN07).

               Note: Contact Z-world Sales for configuring channels 4 - 7 for
               4-20ma operation. Channels 0 - 3 can be configured for 4-20ma
               operation with adding a jumper to JP1 as follows:

                JP1   Channel
               ------ -------
                1-2     0
                3-4     1
                5-6     2
                7-8     3

               RN_DIO Board:
               -------------
               None.

PARAMETER3:    Pointer to a floating point current value, which will be
               updated for the channel being accessed.
               (represented in units of milli-amps)

					Note:	If theres a data overflow or out of range error,
               the value will be set to -4096 (as defined by macro
               ADOVERFLOW)

PARAMETER4:    X number of samples.

					ADC Board:
               ----------
               1  Read current value of the given ADC channel.

               >1 Read given channel x times, and average the readings
                  taken.

PARAMETER5:		Reserved.  Set as 0.

RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command.

SEE ALSO:		rn_anaInConfig, rn_anaIn, rn_anaInVolts, rn_anaInDiff

END DESCRIPTION ***************************************************************/

nodebug
int rn_anaInmAmps(int handle, int channel, float *retdata,
                  int sample, int reserved)
{
	auto int msgcode, regnum, datalen, smp;
	auto rn_devstruct *devaddr;
	auto rn_AinData adata;
   auto long totalsmp;
   auto int i;

	*retdata = 0;
	adata.rawdata=0xffff;	//filled as dummy bytes
  	for (smp=0, totalsmp=0; smp<sample; smp++)
 	{
 		AINW20;	 //start the conversion busy
 		regnum+=channel;
  		msgcode = rn_write(handle, regnum, (char*)&adata, datalen);

  		AINR20;	//read conversion register
  		regnum+=channel;
      for(i=0; i <20; i++);

     	do
      {
 			msgcode = rn_read(handle, regnum, (char*)&adata, datalen);
	  	}	while ((msgcode&RNDEVSTATE)==RNBUSY);
     	if (msgcode&(RNCMDREJ|RNWDTO))	//cmd reject or wdtimeout
     		break;

   	totalsmp+= (long) adata.rawdata;
   }
	adata.rawdata = (int)(totalsmp/sample);
   if (adata.rawdata&0x0800)  			//check bit 12 for sign and sign extend
   {
		adata.rawdata = adata.rawdata|0xf000;
   }
   if (adata.rawdata >= 2047)
   {
  		*retdata = ADOVERFLOW;
      return(msgcode);
   }
   *retdata = (adata.rawdata - adata.offset)*adata.gain;
   return (msgcode);
}


/*** BeginHeader adc_multable */

//ADC calibration constant data structure
typedef struct
{
	float gain;				// gain = (volt2-volt1)/(data2-data1)
	int offset;				// offset = gain*data2 - volt2
} _rn_adccalib;

extern _rn_adccalib rn_adcCalibTable[8][8];		//[channel][gaincode]
extern const char adc_multable[8];
extern const char adc_diffchan[8];

/*** EndHeader */

// Array for the gain and offset values for each A/D channel
_rn_adccalib rn_adcCalibTable[8][8];		//[channel][gaincode]

// Gain multiplier table related to gain codes
const char adc_multable[8] = {1,2,4,5,8,10,16,20};

// Differential channel table translates to device channels
const char adc_diffchan[8] = {0,4,1,5,2,6,3,7};

/*** BeginHeader rn_anaInCalib */

int rn_anaInCalib(int channel, int opmode, int gaincode,
                  int value1, float volts1,
						int value2, float volts2,
                  rn_AinData *adata);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
rn_anaInCalib					<RNET_AIN.LIB>

SYNTAX:			int rn_anaInCalib(int channel, int opmode, int gaincode,
											int value1, float volts1,
                                 int value2, float volts2,
                                 rn_AinData *adata);

DESCRIPTION:	Calibrates the response of an analog input channel desired
					as a linear function using the two conversion points provided.

               Values are calculated and the results are to be sent
               to the analog input device using the function anaInWrCalib().

               Each channel will have the following information:
						a linear constant or gain,
						a voltage offset.

 					Note: Analog input devices are factory calibrated. This
               function should only be used where a channel needs to
               be recalibrated, or if the calibration constants were
               somehow corrupted in the device.

PARAMETER1:    Channel number, is as follows:

					ADC board:
  					==========================================================
					channel   	SINGLE	DIFFerential 	mAMP
					----------	----------------------------------------------
		 				0			+AIN00 	+AIN00 -AIN01 	+AIN00
		 				1			+AIN01 	 	---			+AIN01
		 				2			+AIN02 	+AIN02 -AIN03	+AIN02
		 				3			+AIN03 		---			+AIN03
		 				4			+AIN04 	+AIN04 -AIN05	+AIN04
		 				5			+AIN05 		---			+AIN05
		 				6			+AIN06 	+AIN06 -AIN07	+AIN06
		 				7			+AIN07 		---			+AIN07

					Digital I/O board:
               ------------------
					Channel 0 to 3 (AIN00-AIN03).

PARAMETER2:		Mode of operation for the specified channel.

					ADC board:
               ----------
               RNSINGLE  		,single-ended input mode
					RNDIFF			,differential input mode
					RNmAMP			,milli-Amp input mode

               Digital I/O board:
               ------------------
					Set to 0, not used.

PARAMETER3:  	Gain code for the specified channel.

					ADC Board:
               =====================================
					gaincode		Multiplier
					---------	-------------
		 				0			1x
		 				1			2x
		 				2			4x
		 				3			5x
		 				4			8x
		 				5			10x
		 				6			16x
		 				7			20x
					=====================================
               For 4-20ma mode of operation set the gaincode
               value to 4 (x8).

               Digital I/O board:
               ------------------
               Set gaincode to 0

PARAMETER4:		The first rawdata value, value read from the A/D channel.
PARAMETER5:		The voltage corresponding to the first input value
					(minimum and maximum voltage with respect to the limits
               of the analog input).
PARAMETER6:		The second rawdata value, value read from the A/D channel.
PARAMETER7:		The voltage corresponding to the second input value
					(minimum and maximum voltage with respect to the limits
               of the analog input).
PARAMETER8:    Structure pointer of where the calibration constants,
               gain and offset values are to be written after being
               calculated.

RETURN VALUE:	0, if sucessful.
					-1, if not able to make calibration constants.

SEE ALSO:		rn_anaInWrCalib

END DESCRIPTION **********************************************************/

nodebug
int rn_anaInCalib(int channel, int opmode, int gaincode,
                  int value1, float volts1,
						int value2, float volts2,
                  rn_AinData *adata)
{
	auto int os;
	auto float gn;

	if( (volts1 == volts2) || (value1 == value2) ) return -1;

	os = (int)((volts2*value1 - volts1*value2)/(volts2-volts1));
   gn = (volts2-volts1)/(value2-value1);

	adata->offset = os;
   adata->gain = gn;
	return 0;
}


/*** BeginHeader rn_anaInWrCalib */
int rn_anaInWrCalib(int handle, int channel, int opmode, int gaincode,
						  rn_AinData adata, int reserved);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
rn_anaInWrCalib					<RNET_AIN.LIB>

SYNTAX:			int rn_anaInWrCalib(int handle, int channel,
                                   int opmode, int gaincode
											  rn_AinData adata, int reserved);

DESCRIPTION:	Writes the calibration constants, gain and offset,
					--previously calculated by rn_anaInCalib()--into the
               analog device flash.  A hardware reset, rn_reset() and
               a read of reset register, rn_rst_status() must be issued
               after this function is called.

					Note: Analog input devices are factory calibrated. This
               function should only be used where a channel needs to
               be recalibrated, or if the calibration constants were
               somehow corrupted in the device.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:    Channel number, is as follows:

					ADC board:
  					==========================================================
					channel   	SINGLE	DIFFerential 	mAMP
					----------	----------------------------------------------
		 				0			+AIN00 	+AIN00 -AIN01 	+AIN00
		 				1			+AIN01 	 	---			+AIN01
		 				2			+AIN02 	+AIN02 -AIN03	+AIN02
		 				3			+AIN03 		---			+AIN03
		 				4			+AIN04 	+AIN04 -AIN05	+AIN04
		 				5			+AIN05 		---			+AIN05
		 				6			+AIN06 	+AIN06 -AIN07	+AIN06
		 				7			+AIN07 		---			+AIN07

					Digital I/O board:
               ------------------
					Channel 0 to 3 (AIN00-AIN03).

PARAMETER3:		Mode of operation for the specified channel.

					ADC board:
               ----------
               RNSINGLE  		,single-ended input mode
					RNDIFF			,differential input mode
					RNmAMP			,milli-Amp input mode

               Digital I/O board:
               ------------------
         		Set to 0,  not used.

PARAMETER4:  	Gain code for the specified channel.

					ADC Board:
               =====================================
					gaincode		Multiplier
					---------	-------------
		 				0			1x
		 				1			2x
		 				2			4x
		 				3			5x
		 				4			8x
		 				5			10x
		 				6			16x
		 				7			20x
					=====================================
               For 4-20ma mode of operation set the gaincode
               value to 4 (x8).

               Digital I/O board:
               ------------------
               Set gaincode to 0

PARAMETER5:    Structure pointer of where the calibration constants,
               gain and offset values are located, which were previously
               calculated and written by the rn_anaInCalib() function.

PARAMETER6:		Reserved.  Set as 0.

RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command.

SEE ALSO:		rn_anaInRdCalib, rn_anaInCalib

END DESCRIPTION **********************************************************/

nodebug
int rn_anaInWrCalib(int handle, int channel, int opmode, int gaincode,
						rn_AinData adata, int reserved)
{
	auto int msgcode, regnum, datalen;
	auto char tmpdata[8], key0, key1;
	auto rn_devstruct *devaddr;

	devaddr = (rn_devstruct *)handle;
	if (devaddr->productid == RN1100A)
	{
   	memcpy(tmpdata, &adata.gain, 6);
		msgcode = _rn_dio_ai_wrcalib(handle, channel, (char*)tmpdata);
	}
	else
	{
      tmpdata[0] = (opmode<<3)|gaincode;

		AINW10;		//configure opmode and gaincode register
      regnum+=channel;
     	msgcode = rn_write(handle, regnum, tmpdata, datalen);

   	AINW30;	//write gain and offset register
      regnum+=channel;
      adata.rawdata = (key1<<8)|key0;
      do {
  			msgcode = rn_write(handle, regnum, (char*)&adata, datalen);
         if (msgcode&(RNCMDREJ|RNWDTO))	//cmd reject or wdtimeout
         	break;
     	}	while ((msgcode&RNDEVSTATE)==RNBUSY);

	}

   rn_msDelay(12);
	return (msgcode);
}

/*** BeginHeader rn_anaInRdCalib */

int rn_anaInRdCalib(int handle, int channel, int opmode, int gaincode,
						rn_AinData *adata, int reserved);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
rn_anaInRdCalib					<RNET_AIN.LIB>

SYNTAX:  		int rn_anaInRdCalib(int handle, int channel,
                                   int opmode, int gaincode,
									  		  rn_AinData *adata,
                                   int reserved);

DESCRIPTION:	Reads the device calibration constants, gain and offset,
					from an analog input device.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:    Channel number, is as follows:

					ADC board:
  					==========================================================
					channel   	SINGLE	DIFFerential 	mAMP
					----------	----------------------------------------------
		 				0			+AIN00 	+AIN00 -AIN01 	+AIN00
		 				1			+AIN01 	 	---			+AIN01
		 				2			+AIN02 	+AIN02 -AIN03	+AIN02
		 				3			+AIN03 		---			+AIN03
		 				4			+AIN04 	+AIN04 -AIN05	+AIN04
		 				5			+AIN05 		---			+AIN05
		 				6			+AIN06 	+AIN06 -AIN07	+AIN06
		 				7			+AIN07 		---			+AIN07

					Digital I/O board:
               ------------------
					Channel 0 to 3 (AIN00-AIN03).

PARAMETER3:		Mode of operation for the specified channel.

					ADC board:
               ----------
               RNSINGLE  		,single-ended input mode
					RNDIFF			,differential input mode
					RNmAMP			,milli-Amp input mode

               Digital I/O board:
               ------------------
         		Set to 0,  not used.

PARAMETER4:  	Gain code for the specified channel.

					ADC Board:
               =====================================
					gaincode		Multiplier
					---------	-------------
		 				0			1x
		 				1			2x
		 				2			4x
		 				3			5x
		 				4			8x
		 				5			10x
		 				6			16x
		 				7			20x
					=====================================
               For 4-20ma mode of operation set the gaincode
               value to 4 (x8).

               Digital I/O board:
               ------------------
               Set gaincode to 0

PARAMETER5:    Structure Pointer of where to put the calibration constants,
               gain and offset, when read from the ADC or Digitial I/O
               board.

PARAMETER6:		Reserved.  Set as 0.

RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command.

SEE ALSO:		rn_anaInWrCalib, rn_anaInCalib

END DESCRIPTION **********************************************************/

nodebug
int rn_anaInRdCalib(int handle, int channel, int opmode, int gaincode,
						rn_AinData *adata, int reserved)
{
	auto int msgcode, regoffset, regnum, datalen;
	auto char tmpdata[RN_MAX_DATA];
	auto rn_devstruct *devaddr;

	devaddr = (rn_devstruct *)handle;
	if (devaddr->productid == RN1100A)
	{
		msgcode = _rn_dio_ai_rdcalib(handle, channel, (char*)adata);
	}
	else
	{
      tmpdata[0] = (opmode<<3)|gaincode;

		AINW10;		//configure opmode and gaincode register
      regnum+=channel;
     	msgcode = rn_write(handle, regnum, tmpdata, datalen);

   	AINR30;
      regnum+=channel;
      do {
      	msgcode = rn_read(handle, regnum, (char*)&adata->gain, datalen);
         if (msgcode&(RNCMDREJ|RNWDTO))	//cmd reject or wdtimeout
         	break;
     	}	while ((msgcode&RNDEVSTATE)==RNBUSY);
	}

	return (msgcode);
}

/*** BeginHeader rn_anaInConfig */

int rn_anaInConfig(int handle, int channel, int opmode,
                   int gaincode, int reserved);
#define ADOVERFLOW -4096	//ADC overflow/out of range error code
#define SE_DEVCHAN 0x08		//Single-ended and milli-Amp device channel
#define AD_OSC_ENABLE 0x39	//internal osc, cclk=2.5Mhz, ref powered,
									// vref= 1.15
#define AD_OSC_DISABLE 0x00 //vref=cclk, OSCE, REFE, BUFE all disabled
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
rn_anaInConfig					<RNET_AIN.LIB>

SYNTAX:			int rn_anaInConfig(int handle, int channel, int opmode,
                                  int gaincode, int reserved);

DESCRIPTION:	Configures an analog input channel to a desired mode of
               operation and gain. Once all channels have been set to
					single-ended, differential or 4-20 milli-Amp mode, and
               to desired the gain, use rn_anaIn(), rn_anaInVolts,
					rn_anaInDiff, and rn_anaInmAmps to read an A/D channel.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:    Channel number, is as follows:

					ADC board:
  					==========================================================
					channel   	SINGLE	DIFFerential 	mAMP
					----------	----------------------------------------------
		 				0			+AIN00 	+AIN00 -AIN01 	+AIN00
		 				1			+AIN01 	 	---			+AIN01
		 				2			+AIN02 	+AIN02 -AIN03	+AIN02
		 				3			+AIN03 		---			+AIN03
		 				4			+AIN04 	+AIN04 -AIN05	+AIN04
		 				5			+AIN05 		---			+AIN05
		 				6			+AIN06 	+AIN06 -AIN07	+AIN06
		 				7			+AIN07 		---			+AIN07

               Digital I/O board:
               ------------------
					Channel 0 to 3 (AIN00-AIN03).

PARAMETER3:		Mode of operation for the specified channel.

					ADC board:
               =============================================================
               Use one of the following predefined MACRO's to set the mode of
               operation.
               RNSINGLE  		,single-ended input mode
					RNDIFF			,differential input mode
					RNmAMP			,milli-Amp input mode

               Digital I/O board:
               ------------------
         		ADCENABLE		,enables conversions
               ADCDISABLE	,disables conversions

PARAMETER4:  	Gain code for the specified channel.

					ADC Board:
               ==========================================================
                Gaincode  Actual Gain     Single-Ended    Differential
					--------  -----------	 --------------   ------------
		 				0 		 	(x1)			   0 - 20v         +- 20v
		 				1 		  	(x2)			   0 - 10v         +- 10v
		 				2 		 	(x4)			   0 - 5v          +- 5v
		 				3 		 	(x5)			   0 - 4v          +- 4v
		 				4 		 	(x8)			   0 - 2.5v        +- 2.5v
		 				5 		 	(x10)	 		   0 - 2v          +- 2v
		 				6 		 	(x16)			   0 - 1.25v       +- 1.25v
		 				7 		 	(x20)			   0 - 1v          +- 1v
					==========================================================
               For 4-20ma mode of operation set the gaincode
               value of 4 (x8).

               Digital I/O board:
               ------------------
               Set gaincode to 0

PARAMETER5:		Reserved.  Set as 0.

RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command.

SEE ALSO:		rn_anaIn, rn_anaInVolts, rn_anaInDiff, rn_anaInmAmps

END DESCRIPTION **********************************************************/

nodebug
int rn_anaInConfig(int handle, int channel, int opmode,
                   int gaincode, int reserved)
{
	auto int msgcode, regnum, datalen, attempt;
	auto char tmpdata[4];
	auto rn_devstruct *devaddr;
   auto int i;

   gaincode |= (opmode & 0x80);
   tmpdata[0] = (opmode<<3)|gaincode;

	devaddr = (rn_devstruct *)handle;
	if (devaddr->productid == RN1100A)
	{
   	if (opmode != ADCDISABLE)
      	opmode = ADCENABLE;
		msgcode = _rn_dio_ai_control(handle, channel, opmode);
	}
   else
	{
   	gaincode   = gaincode | (opmode & 0x80);
      tmpdata[0] = (opmode<<3)|gaincode;

		AINW10;
      regnum+=channel;
      msgcode = rn_write(handle, regnum, tmpdata, datalen);

      for(i=0; i <20; i++);

      // Wait for for slave to become ready
      C0R00;
      do {
         msgcode = rn_write(handle, regnum, tmpdata, datalen);
      }	while ((msgcode&RNDEVSTATE)== RNBUSY);
  	}
	return (msgcode);
}




/*** BeginHeader _rn_rdADdevice */
int _rn_rdADdevice(int handle, char adc_reg, char *data, int reserved);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION *************************************************
_rn_rdADdevice					<RNET_AIN.LIB>

SYNTAX:  		int _rn_rdADdevice(int handle, char register, char *data,
                                  int reserved)

DESCRIPTION:   Internal.
               Read from the analog to digital converter device directly.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:		ADC Register to be Read.

PARAMETER3:    Pointer to data value to be updated by this function.

PARAMETER3:		Reserved.  Set as 0.

RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command

END DESCRIPTION ***************************************************************/

nodebug
int _rn_rdADdevice(int handle, char adc_reg, char *data, int reserved)
{
	auto int msgcode, regnum, datalen;
	auto char tmpdata[4];

   tmpdata[0] = adc_reg;
  	AINW40;	//initiate direct read
   msgcode = rn_write(handle, regnum, tmpdata, datalen);

  	AINR40;	//test for busy then read register
   do {
   	msgcode = rn_read(handle, regnum, (char*)tmpdata, datalen);
   }	while ((msgcode&RNDEVSTATE)== RNBUSY);
   *data = tmpdata[0];
	return (msgcode);
}

/*** BeginHeader _rn_wrADdevice */
int _rn_wrADdevice(int handle, char adc_reg, char data, int reserved);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION *************************************************
_rn_wrADdevice					<RNET_AIN.LIB>

SYNTAX:  		int _rn_wrADdevice(int handle, char register, char data,
                                  int reserved)

DESCRIPTION:   Internal.
               Writes command byte and data directly to the analog
               to digital converter device.

PARAMETER1:		Address index to device information. Use rn_device()
					or rn_find to establish handle.

PARAMETER2:		ADC Register to be written.

PARAMETER3:    Data to be written to specified ADC Register.

PARAMETER4:		Reserved.  Set as 0.

RETURN VALUE:	-1, device information indicates no connection,
					Status byte from previous command

END DESCRIPTION ***************************************************************/

nodebug
int _rn_wrADdevice(int handle, char adc_reg, char data, int reserved)
{
	auto int msgcode, regnum, datalen;
	auto char tmpdata[4];

   tmpdata[0] = adc_reg;
   tmpdata[1] = data;
  	AINW41;
   msgcode = rn_write(handle, regnum, tmpdata, datalen);

	return (msgcode);
}


/*** BeginHeader */
#endif
/*** EndHeader */


