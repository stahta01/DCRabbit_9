/*******************************************************************************
NFLASH.LIB
   Copyright (c) Z-World, Inc., June 2004.

DESCRIPTION:
   Library for interfacing to NAND flash memory devices via the external I/O
   data bus.  Specifically written to work with industry standard (eg:  Samsung,
   Toshiba) NAND flash devices with 528 byte (512 data bytes plus 16 "spare"
   bytes) page program and 16896 byte (32 pages) block erase sizes.

   NAND Flash Restriction:
      According to Toshiba's data sheets for TC58DVM72A1FT00, TC58DVM82A1FT00,
      TC58DVM92A1FT00 and TC58DVG02A1FT00 NAND flash devices (commonly used in
      16 MB through 128 MB xD Picture Card devices, respectively), out of order
      page programming within an erase block is prohibited.  Due to this
      restriction, the NAND flash driver offers only 16896 byte (block erase
      size) at a time read and write capability.

   The NAND flash API functions are designed to be reasonably similar to the
   newer serial flash API functions found in SFLASH.LIB, however, the
   operational differences between serial flash and NAND flash devices
   necessitate several corresponding API differences.

   These API functions make use of an nf_device structure as a handle for a
   specific NAND flash device.  This allows multiple NAND flash devices to be
   used by an application.

   The API functions are:
      nf_initDevice
      nf_readPage
      nf_eraseBlock
      nf_writePage
      nf_getPageCount
      nf_getPageSize
      nf_isBusyRBHW
      nf_isBusyStatus

SUPPORT LIB'S:
   ECC.LIB, PART_DEFS.LIB
*******************************************************************************/

/*** BeginHeader */

#ifndef __NFLASH_LIB__
#define __NFLASH_LIB__

#ifndef __ECC_LIB
#use "ecc.lib"
#endif
#ifndef __PART_DEFS_LIB
#use "part_defs.lib"
#endif

#ifdef NFLASH_DEBUG
#define _nflash_nodebug debug
#else
#define _nflash_nodebug nodebug
#endif

// must define a NAND  flash programming unit size, if not already defined by
//  the application
#ifndef NFLASH_USEERASEBLOCKSIZE
	// if NFLASH_USEERASEBLOCKSIZE is not defined, its value defaults to 1
	//  0 == use 512 byte main data page size; 1 == use 16 KB main data page size
	#define NFLASH_USEERASEBLOCKSIZE 1
#endif

// the application may define NFLASH_CANERASEBADBLOCKS in order to be allowed to
//  erase bad blocks and to read initial bad blocks that would otherwise be
//  skipped over in order to make page zero start at the first good block
//#define NFLASH_CANERASEBADBLOCKS

// a marker value to attest to valid battery backed xmem buffers content, etc.
#define _NFLASH_MARKERVALUE 0xA55A3CC3L

// maximum number of devices supported simultaneously by this library
#define _NFLASH_MAXDEVICES 2	// soldered on device plus socketed device

// NAND flash commands
#define _NFLASH_AUTOPROGRAM	0x10	// execute auto program page (write) command
#define _NFLASH_DATAINPUT		0x80	// load program page data to internal buffer
#define _NFLASH_IDREAD			0x90	// read manufacturer+device ID
#define _NFLASH_READMODE1		0x00	// read starting in first 256 bytes of page
#define _NFLASH_READMODE2		0x01	// read starting in second 256 bytes of page
#define _NFLASH_READMODE3		0x50	// read starting, staying in 16 spare bytes
#define _NFLASH_RESET			0xFF	// reset device (terminates other command)
#define _NFLASH_STATUSREAD		0x70	// report status (Pass/Fail, Ready/Busy

#ifndef _LCALL_RETBYTES
// Not already defined in another library with pure xmem asm functions that use
//  stack parameters.
#define _LCALL_RETBYTES 3		// number of bytes stacked for lcall return
#endif

#define NFLASH_SCANBAD 16   // Bad block scan option for nf_initDevice function

typedef struct nf_device_st {
	unsigned baseaddress;		// base external I/O address
	sys_iopin_t cspin;			// internal /CS output pin information
	sys_iopin_t rbpin;			// internal READY/BUSY input pin information
	int addressbytes;				// number of bytes used for page addressing
	int mbrtype;					// mbr_drvr type, per MBRTYPE_xxxxx macro defs
	long startpage;				// first "good" page's page number
	long pages;						// total number of pages on the flash device
	int erasepages;				// number of program pages in an erase block
	long mainsize;					// size of a page/block, excluding spare data
	int sparesize;					// size of a program page's spare data
	int pagebitshift;				// "don't care" bits in a program page address
	int erasebitshift;			// "don't care" bits in an erase block address
	long mainbfbuf;				// page/block main data backfill buffer address
	long sparebfbuf;				// page/block spare data backfill buffer address
	long sparebuffer;				// single program page spare data buffer address
	long marker;					// possibly valid buffers content marker value
	int crc;							// CRC of prior nf_device struct info
	// Previous structure elements are write once read mostly and are "protected"
	//  by a CRC, so they don't need to be explicitly protected.
	// Following structure elements are general read/write and are not
	//  "protected" by a CRC, so they must be explicitly protected.
	protected int write_state;		// current state of multi-page write
	protected long write_page;		// current page of multi-page write
	protected long write_buffer;	// current buffer address for multi-page write
	protected struct nf_device_st *next;	// next element in linked list
#if _USER
   protected char shadow_value;
#endif
} nf_device;

/*** EndHeader */


/*** BeginHeader _nf_print_data */
void _nf_print_data(char *dataTitle, long dataPage, long dataBuffer,
                   long dataSize);
/*** EndHeader */
//DEBUGGING function invoked by defining NFLASH_VERBOSE
void _nf_print_data(char *dataTitle, long dataPage, long dataBuffer,
                   long dataSize)
{
	auto char ascii_buffer[17];
	auto char hex_buffer[58];
	auto char fbyte;
	auto int k;
	auto long j;

	printf("%s data (page %lx):\n", dataTitle, dataPage);
	for (j = 0L; j < dataSize; j += 16L) {
		sprintf(hex_buffer, "%08lx ", j);
		for (k = 0; k < 16; k++) {
			if ((j + (long) k) < dataSize) {
				xmem2root(&fbyte, dataBuffer + j + (long) k, sizeof(fbyte));
				sprintf(hex_buffer + 9 + (3 * k), "%02x ", fbyte);
				if (fbyte > 31 && fbyte < 127) {
					ascii_buffer[k] = fbyte;
				} else {
					ascii_buffer[k] = '.';
				}
			} else {
				sprintf(hex_buffer + 9 + (3 * k), "   ");
				ascii_buffer[k] = 0;
			}
		}
		ascii_buffer[sizeof(ascii_buffer) - 1] = 0;
		printf("%s%s\n", hex_buffer, ascii_buffer);
	}
}


/*** BeginHeader _nf_print_dev */
void _nf_print_dev(nf_device *dev);
/*** EndHeader */
//DEBUGGING function invoked by defining NFLASH_VERBOSE
void _nf_print_dev(nf_device *dev)
{
	printf("nf_device address: 0x%04x\n", dev );
	printf("\tbaseaddress: 0x%04x\n", dev->baseaddress);
	printf("\tcspin\n");
	printf("\t\tport: 0x%04x\n", dev->cspin.port);
	printf("\t\tshadow: 0x%04x\n", dev->cspin.shadow);
	printf("\t\tmask: 0x%02x\n", dev->cspin.mask);
	printf("\trbpin\n");
	printf("\t\tport: 0x%04x\n", dev->rbpin.port);
	printf("\t\tshadow: 0x%04x\n", dev->rbpin.shadow);
	printf("\t\tmask: 0x%02x\n", dev->rbpin.mask);
	printf("\taddressbytes: %d\n", dev->addressbytes);
	printf("\tmbrtype: 0x%04x\n", dev->mbrtype);
	printf("\tstartpage: 0x%08lx\n", dev->startpage);
	printf("\tpages: %ld\n", dev->pages);
	printf("\terasepages: %d\n", dev->erasepages);
	printf("\tmainsize: %lu\n", dev->mainsize);
	printf("\tsparesize: %u\n", dev->sparesize);
	printf("\tpagebitshift: %d\n", dev->pagebitshift);
	printf("\terasebitshift: %d\n", dev->erasebitshift);
	printf("\tmainbfbuf: 0x%08lx\n", dev->mainbfbuf);
	printf("\tsparebfbuf: 0x%08lx\n", dev->sparebfbuf);
	printf("\tsparebuffer: 0x%08lx\n", dev->sparebuffer);
	printf("\tmarker: 0x%08lx\n", dev->marker);
	printf("\tcrc: 0x%04x\n", dev->crc);
	printf("\twrite_state: %d\n", dev->write_state);
	printf("\twrite_page: 0x%08lx\n", dev->write_page);
	printf("\twrite_buffer: 0x%08lx\n", dev->write_buffer);
	printf("\tnext: 0x%04x\n", dev->next );
}


/*** BeginHeader nf_devtable */
typedef struct {
	long id_code;			// NAND flash ID code (long allows for future expansion)
	long pages;				// total number of program pages
	long pagesize;			// size of each program page, including "spare" bytes
	int addressbytes;		// address bytes needed for page read/program commands
	int pagebitshift;		// "don't care" bits in a program page address
	int erasebitshift;	// "don't care" bits in an erase block address
} nf_devtable_entry;

// if not already defined by the application, to allow for more or less empty
//  entries for future expansion
#ifndef NFLASH_DEVTABLE_SIZE
#define NFLASH_DEVTABLE_SIZE 12
#endif

extern const nf_devtable_entry nf_devtable[NFLASH_DEVTABLE_SIZE];
/*** EndHeader */
/*
** table for NAND flash device configuration
*/
const nf_devtable_entry nf_devtable[NFLASH_DEVTABLE_SIZE] = {
	{0x7320L,  32768L, 528L, 3, 9, 14},	// Micron/Numonyx/ST NAND128W3A
	{0x7520L,  65536L, 528L, 3, 9, 14},	// Micron/Numonyx/ST NAND256W3A
	{0x7620L, 131072L, 528L, 4, 9, 14},	// Micron/Numonyx/ST NAND512W3A
	{0x7920L, 262144L, 528L, 4, 9, 14},	// Micron/Numonyx/ST NAND01GW3A
	{0x73ECL,  32768L, 528L, 3, 9, 14},	// Samsung K9F2808UOC
	{0x75ECL,  65536L, 528L, 3, 9, 14},	// Samsung K9F5608UOC
	{0x76ECL, 131072L, 528L, 4, 9, 14},	// Samsung K9F1208U0A/B/M
	{0x79ECL, 262144L, 528L, 4, 9, 14},	// Samsung K9K1G08U0A/M
	{0x7398L,  32768L, 528L, 3, 9, 14},	// Toshiba TC58DVM72A1FT00
	{0x7598L,  65536L, 528L, 3, 9, 14},	// Toshiba TC58DVM82A1FT00, TC58256AFT(I)
	{0x7698L, 131072L, 528L, 4, 9, 14},	// Toshiba TC58DVM92A1FT00
	{0x7998L, 262144L, 528L, 4, 9, 14}	// Toshiba TC58DVG02A1FT00
};


/*** BeginHeader nf_initDevice */
int nf_initDevice(nf_device *dev, int options);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
nf_initDevice                 <NFLASH.LIB>

SYNTAX: int nf_initDevice(nf_device *dev, int options);

DESCRIPTION:  Initializes a particular nand flash device.  This function
              must be called before the particular nand flash device can
              be used.  See nf_devtable[] in NFLASH.LIB for the user-
              updatable list of supported nand flash devices.  Note that
              xalloc is called to allocate buffer(s) memory for each nand
              flash device; a run time error will occur if the available
              xmem RAM is insufficient.

              There are two modes of operation for nand flash devices: FAT
              and direct.  If you are using the FAT file system in the
              default configuration, i.e., the nand flash has one FAT
              partition that takes up the entire device, you do not need
              to call nf_initDevice.  You only need to call nf_InitDriver,
              which is the default device driver for the FAT file system
              on a nand flash device.

              Configurations other than the default one require more work.
              For example, having two partitions on the device, one a FAT
              partition and the other a non-FAT partition, require you to
              know how to fit more than one partition on a device.  A good
              example of how to do this is in the remote application
              upload utility.  The function dlm_initserialflash in
              /LIB/RCM3300/downloadmanager.lib is where to look for code
              details.  The upload utility is specifically for the
              RCM3300; however, even without the RCM3300, the utility is
              still useful in detailing what is necessary to manage
              multiple partitions.

              The second mode of operation for nand flash devices is
              direct access.  An application that directly accesses the
              nand flash (using calls such as nf_readPage and
              nf_writePage) may define NFLASH_USEERASEBLOCKSIZE to be
              either 0 (zero) or 1 (one) before NFLASH.LIB is #used, in
              order to set the nand flash driver's main data program unit
              size to either the devices' program page size of 512 bytes
              or to its erase block size of 16 KB.

              If not defined by the application, NFLASH_USEERASEBLOCKSIZE
              is set to the value 1 in NFLASH.LIB; this mode should
              maximize the nand flash devices' life.
              NFLASH_USEERASEBLOCKSIZE value 1 sets the driver up to
              program an erase block size at a time.  This mode may be
              best for applications with only a few files open in write
              mode with larger blocks of data being written, and may be
              especially good at append operations.  The trade off is
              reduced flash erasures at the expense of chunkier overhead
              due to the necessity of performing all 32 pages' ECC
              calculations for each programming unit written.

              NFLASH_USEERASEBLOCKSIZE value 0 sets the driver up to
              program a program page size at a time.  This mode may be
              best for applications with more than a few files open in
              write mode with smaller blocks of data being written, and
              may be especially good at interleaved file writes and/or
              random access write operations.  The trade off is increased
              flash erasures with the benefit of spread out overhead due
              to the necessity of performing only 1 page's ECC
              calculations per programming unit written.

PARAMETER1: dev is a pointer to the nf_device struct that will be filled
            in.  The nf_device struct will then act as a handle for the
            NAND flash device.

PARAMETER2: options allows selection of the nand flash device to initialize
            and selection of initial scanning of the device.
            Currently the least significant bit (bit 0) is set to 0 for the
            soldered-on device or 1 for the socketed (xD Card) device.
            Bit 4 should be set if a bad block scan is desired.
            This is defined as NFLASH_SCANBAD for convenience. A bad block
            scan will error if more than 2 percent of the blocks are marked
            bad. All other bits must be zero.

RETURN VALUE: 0 if success,
              -1 if unknown index or bad internal I/O port information,
              -2 if error communicating with flash chip, or
              -3 if unknown flash chip type.
              -4 if device has too many bad blocks (2 percent or higher)
END DESCRIPTION *********************************************************/

#if BBROOTDATASIZE
	// use separate battery backed /CS2 SRAM, when one is available
	#define _XALLOC_FOR_NFLASH XALLOC_BB
#else
	// otherwise, assume standard /CS1 SRAM is battery backed!
//	#warns "Using main /CS1 SRAM, data loss may result if not battery backed."
	#define _XALLOC_FOR_NFLASH XALLOC_ANY
#endif

_nflash_nodebug
int nf_initDevice(nf_device *dev, int options)
{
#if _USER
	auto char gocrshadow;
#endif
	auto int bitShiftDiff, i, scan, which, myCRC;
	auto long  beginMS_TIMER, nandID, page, pagemax, xramSize;
	static long _nf_xallocBuffer[_NFLASH_MAXDEVICES];

	#GLOBAL_INIT { memset(_nf_xallocBuffer, 0, sizeof(_nf_xallocBuffer)); }

	scan = options & NFLASH_SCANBAD;
	which = options - scan;
	switch (which) {
	case 0:
		dev->next = NULL;
		dev->cspin.port = PDDR;
		dev->cspin.shadow = &PDDRShadow;
		dev->cspin.mask = 0x02;
		dev->rbpin.port = PDDR;
		dev->rbpin.shadow = &PDDRShadow;
		dev->rbpin.mask = 0x01;
		dev->baseaddress = 0x5BDC;
		// see MBRTYPE_xxxxx macro definitions in part_defs.lib
		dev->mbrtype = MBRTYPE_FLASH | MBRTYPE_MARKERS;
		break;
	case 1:
		dev->next = NULL;
		dev->cspin.port = GOCR;
#if _USER
		dev->cspin.shadow = NULL;
#else
		dev->cspin.shadow = &GOCRShadow;
#endif
		dev->cspin.mask = 0x01;
		dev->rbpin.port = PDDR;
		dev->rbpin.shadow = &PDDRShadow;
		dev->rbpin.mask = 0x01;
		dev->baseaddress = 0x5BDC;
		// see MBRTYPE_xxxxx macro definitions in part_defs.lib
		dev->mbrtype = MBRTYPE_FLASH | MBRTYPE_MARKERS | MBRTYPE_REMOVE;
		break;
	default:
		return -1;	// unknown index selection, return error!
	}

	switch (dev->cspin.port) {
		// Both possible on-board NAND /CEs must be set up here to avoid possible
		//  bus contention should both be installed but only one initialized and
		//  the other somehow left in an active state from power up.
	case GOCR:
	case PDDR:
		// set up /BUFEN output for socketed NAND /CE (enabled when low)
#if _USER
		_sys_direct_read(GOCR, &gocrshadow);
      _sys_direct_write(GOCR, 0x03 | gocrshadow);
#else
		WrPortI(GOCR, &GOCRShadow, 0x03 | GOCRShadow);
#endif
		// set up port D output for soldered NAND /CE (enabled when low)
		WrPortI(PDDR, &PDDRShadow, dev->cspin.mask | PDDRShadow);
		WrPortI(PDFR, &PDFRShadow, ~(dev->cspin.mask) & PDFRShadow);
		WrPortI(PDDDR, &PDDDRShadow, dev->cspin.mask | PDDDRShadow);
		break;
	default:
		return -1;	// unknown NAND /CE control port, return error!
	}

	switch (dev->rbpin.port) {
	case PDDR:
		// port D input is OK for NAND's R/B (busy when low),
		//  so set open drain output capability (to match NAND's R/B output),
		WrPortI(PDDCR, &PDDCRShadow, dev->rbpin.mask | PDDCRShadow);
		//  and also set normal I/O functionality
		WrPortI(PDFR, &PDFRShadow, ~(dev->rbpin.mask) & PDFRShadow);
/*
// Don't set the DDR up yet, as it may interfere with the User's desired LED
//  function.  Instead, we'll only enforce the I/O pin's input mode briefly,
//  later on, when we need to check the NAND's Ready/Busy hardware status.
		WrPortI(PDDDR, &PDDDRShadow, ~(dev->rbpin.mask) & PDDDRShadow);
*/
		break;
	default:
		return -1;	// unknown NAND R/B status port, return error!
	}

	// set up the external I/O control register
	i = 0x07 & (dev->baseaddress >> 13);			// index to I/O register, shadow
	WrPortI(IB0CR + i, &IB0CRShadow - i, 0x89);	// 3WS, /CS stb, wr OK, mem bus

	// set up port E output as external I/O /CS strobe
	WrPortI(PEDR, &PEDRShadow, (1 << i) | PEDRShadow);
	WrPortI(PEFR, &PEFRShadow, (1 << i) | PEFRShadow);
	WrPortI(PEDDR, &PEDDRShadow, (1 << i) | PEDDRShadow);

	// reset the NAND flash to get it into a known state
	_nf_deviceReset(dev);

	// save the current MS_TIMER value for time-out comparison
	beginMS_TIMER = (long) MS_TIMER;
	// now check the NAND flash device's internal busy status
	while (nf_isBusyStatus(dev)) {
		if ((long) MS_TIMER - beginMS_TIMER > 1L) {
			// device should not be busy for more than 0.5 millisecond after reset!
#ifdef NFLASH_VERBOSE
			printf("status = 0x%x\n", _nf_deviceStatus(dev));
#endif
			return -2;
		}
	}
#ifdef NFLASH_VERBOSE
	printf("status = 0x%x\n", _nf_deviceStatus(dev));
#endif

	nandID = _nf_deviceID(dev);
#ifdef NFLASH_VERBOSE
	printf("nandID = 0x%08lx\n", nandID);
#endif

	for (i = 0; i < NFLASH_DEVTABLE_SIZE; ++i) {
		if (nf_devtable[i].id_code == nandID) {
			dev->addressbytes = nf_devtable[i].addressbytes;
			dev->pagebitshift = nf_devtable[i].pagebitshift;
			dev->erasebitshift = nf_devtable[i].erasebitshift;
			dev->sparesize = (int) (nf_devtable[i].pagesize -
			                        (1L << dev->pagebitshift));
			bitShiftDiff = dev->erasebitshift - dev->pagebitshift;
			// calculate the number of program pages in an erase block
			dev->erasepages = 1 << bitShiftDiff;
#ifdef __NFLASH_FAT_LIB
// If FAT is used, its cache and journals are used to manage write recovery.

			// set up for programming an erase block size at a time
			dev->pages = nf_devtable[i].pages >> bitShiftDiff;
			dev->mainsize = (nf_devtable[i].pagesize << bitShiftDiff) &
			                ~((1L << dev->erasebitshift) - 1L);
			// Erase block size write doesn't need main or spare data backfill
			//  buffers, but does need a single program page spare data buffer.
			dev->mainbfbuf = dev->sparebfbuf = 0L;
			xramSize = (long) dev->sparesize;
			if (_nf_xallocBuffer[which] == 0L) {
				_nf_xallocBuffer[which] = _xalloc(&xramSize, 0, XALLOC_ANY);
         }
			dev->sparebuffer = _nf_xallocBuffer[which];

#else
// Otherwise, this driver attempts to recover an interrupted write.
	#if NFLASH_USEERASEBLOCKSIZE
			// set up for programming an erase block size at a time
			dev->pages = nf_devtable[i].pages >> bitShiftDiff;
			dev->mainsize = (nf_devtable[i].pagesize << bitShiftDiff) &
			                ~((1L << dev->erasebitshift) - 1L);
			// Erase block size write doesn't need a main data backfill buffer, but
			//  does need backfill and single program page spare data buffers.
			// All are stored in a single allocation from battery backed xmem RAM.
			dev->mainbfbuf = 0L;
			xramSize = ((long) dev->sparesize << bitShiftDiff) +
			           (long) dev->sparesize;
			if (_nf_xallocBuffer[which] == 0L) {
				_nf_xallocBuffer[which] = _xalloc(&xramSize, 0, _XALLOC_FOR_NFLASH);
			}
			dev->sparebfbuf = _nf_xallocBuffer[which];
	#else
			// set up for programming a program page size at a time
			dev->pages = nf_devtable[i].pages;
			dev->mainsize = nf_devtable[i].pagesize &
			                ~((1L << dev->pagebitshift) - 1L);
			// Program page size write needs a main data backfill buffer, plus
			//  backfill and single program page spare data buffers.
			// All are stored in a single allocation from battery backed xmem RAM.
			xramSize = (nf_devtable[i].pagesize << bitShiftDiff) +
			           (long) dev->sparesize;
			if (_nf_xallocBuffer[which] == 0L) {
				_nf_xallocBuffer[which] = _xalloc(&xramSize, 0, _XALLOC_FOR_NFLASH);
			}
			dev->mainbfbuf = _nf_xallocBuffer[which];
			dev->sparebfbuf = dev->mainbfbuf + (dev->mainsize << bitShiftDiff);
	#endif
			// physical address of the single program page spare data buffer
			dev->sparebuffer = dev->sparebfbuf +
			                   ((long) dev->sparesize << bitShiftDiff);
#endif

			// default to first page being "good"
			dev->startpage = 0L;

#ifndef NFLASH_CANERASEBADBLOCKS
			// skip over bad blocks at start of NAND flash device
	#if NFLASH_USEERASEBLOCKSIZE
			for (page = 0, pagemax = dev->pages; page < pagemax; page += 4L) {
	#else
			for (page = 0, pagemax = dev->pages; page < pagemax; page += 0x80L) {
	#endif
				if (_nf_deviceCheckBlock(dev, page * dev->mainsize)) {
					// Bad block found, see if good start page found yet
					if (dev->startpage == page) {
						// Move start page and set next test page to be the next page
	#if NFLASH_USEERASEBLOCKSIZE
						dev->startpage += 1L;
						page -= 3L;
	#else
						dev->startpage += 0x20L;
						page -= 0x60L;
	#endif
					}
	#if NFLASH_USEERASEBLOCKSIZE
					dev->pages -= 1L;
	#else
					dev->pages -= 0x20L;
	#endif
					if (dev->pages < (pagemax - (pagemax / 50))) {
						return -4;	// Too many bad blocks on the device
					}
				}
				else {
					if (!scan) {
						break;
					}
				}
			}
#endif

#ifdef __NFLASH_FAT_LIB
// If FAT is used, its cache and journals are used to manage write recovery.
			dev->write_state = 0;	// enforce initial write state 0
			dev->marker = 0L;			// neither the marker nor the crc are
			dev->crc = 0;				//  used with the FAT file system
#else
// Otherwise, this driver attempts to recover an interrupted write.

			// -2 in the following "if" is a magic number for the NFLASH.LIB
			//  nf_initDevice function; it is the minimum numbered (perform block
			//  erase) state in the nf_writePage function's state machine.
			if ((_NFLASH_MARKERVALUE == dev->marker) && (-2 <= dev->write_state) &&
			    (dev->erasepages >= dev->write_state) &&
			    (getcrc((char *) dev, (char) offsetof(nf_device, crc), 0) ==
			     dev->crc))
			{
				// All dev information seems to be OK after (presumed) power cycle,
				//  so must be battery backed; BB backfill data should then also be
				//  good.
				if (0 < dev->write_state) {
					// However, can't be sure that the NAND flash's block erase and
					//  program pages (re)write actually completed before power
					//  cycle, so back up and do over from the block erase again.
					dev->write_state = -2;
				}
			} else {
				// At least some dev information is changed, so prepare dev for
				//  possibility of power fail recovery next time.
				dev->write_state = 0;	// enforce initial write state 0
				dev->marker = _NFLASH_MARKERVALUE;
				// save CRC for nf_device struct up to, but not including its CRC
				dev->crc = getcrc((char *) dev, (char) offsetof(nf_device, crc), 0);
			}
#endif

#ifdef NFLASH_VERBOSE
			printf("NAND flash device handle initialization completed:\n");
			_nf_print_dev(dev);
#endif
			return 0;
		}	// end if nf_devtable[i].id_code == nandID
		else if (0 == nf_devtable[i].id_code) {
			break;	// end of valid device table entries
		}
	}	// end for
	return -3;	// unknown device
}


/*** BeginHeader nf_readPage */
int nf_readPage(nf_device *dev, long buffer, long page);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
nf_readPage                   <NFLASH.LIB>

SYNTAX: int nf_readPage(nf_device *dev, long buffer, long page);

DESCRIPTION: Reads data from the specified NAND flash device and page to
             the specified buffer in xmem.  Note that in the case of most
             error results at least some of the NAND flash page's content
             has been read into the specified buffer.  Although the buffer
             content must be considered unreliable, it can sometimes be
             useful for inspecting page content in "bad" blocks.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

PARAMETER2: buffer is the physical address of the xmem buffer to read data
            into.

PARAMETER2: page specifies the zero based number of the NAND flash page
            to be read, relative to the first "good" page's number.

RETURN VALUE: 0 if success, or the first error result encountered:
              -1 if NAND flash device is busy,
              -2 if block check time out error,
              -3 if page is in a bad block,
              -4 if page read time out error, or
              -5 if uncorrectable data or ECC error.
END DESCRIPTION *********************************************************/
// buffer length must be equal to page/block size!
_nflash_nodebug
int nf_readPage(nf_device *dev, long buffer, long page)
{
	auto int i, j, result, status;
	auto long newECC[2], oldECC[2];

	// first, check to see if the NAND flash device is ready
	if (nf_isBusyStatus(dev)) {
		// busy, report error immediately
		return -1;
	}

	// default to "success" result
	result = 0;

	// convert relative page number to the page's actual start address
#if NFLASH_USEERASEBLOCKSIZE
	page = (page + dev->startpage) << dev->erasebitshift;
#else
	page = (page + dev->startpage) << dev->pagebitshift;
#endif

	// check if this page is (or is in) a bad block
	status = _nf_deviceCheckBlock(dev, page);
	if (1 == status) {
		// block check time out error
		result = -2;
	}
	else if (2 == status) {
		// bad block marker error
		result = -3;
	}

#if NFLASH_USEERASEBLOCKSIZE
	j = dev->erasepages;	// iterate through all of the erase block's pages
	while (j--) {
#endif
		// read main data into caller's buffer, spare data into device's buffer
		status = _nf_deviceReadPage(dev, buffer, dev->sparebuffer, page);
		if (!result && status) {
			// page read time out error
			result = -4;
		}

		for (i = 0; i < 2; ++i) {
			// get previous ECC, stored in NAND flash page's "spare" data
			xmem2root(&oldECC[i], dev->sparebuffer + 13L - (5L * (long) i), 3u);

			// calculate new ECC based on the NAND flash page's main data just read
			newECC[i] = xCalculateECC256(buffer + (256L * (long) i));
#ifdef NFLASH_VERBOSE
			oldECC[i] &= 0x00FFFFFFL;
			if (newECC[i] != oldECC[i]) {
				printf("oldECC[%d] is %08lx, but newECC[%d] is %08lx.\n",
				       i, oldECC[i], i, newECC[i]);
				_nf_print_data("Driver's spare", page >> dev->pagebitshift,
				              dev->sparebuffer, dev->sparesize);
			}
#endif

			// check ECCs and correct data (or old ECC) if necessary
			status = xChkCorrectECC256(buffer + (256L * (long) i), &oldECC[i],
			                           &newECC[i]);
			if (!result && (3 == status)) {
				// uncorrectable data or ECC error
				result = -5;
			}
			if (2 == status) {
				// put the corrected ECC back into the "spare" data buffer
				root2xmem(dev->sparebuffer + 13L - (5L * (long) i), &oldECC[i], 3u);
#ifdef NFLASH_VERBOSE
				_nf_print_data("Driver's spare", page, dev->sparebuffer,
				              dev->sparesize);
#endif
			}
		}
#if NFLASH_USEERASEBLOCKSIZE
		buffer += 1L << dev->pagebitshift;
		page += 1L << dev->pagebitshift;
	}	// end while
#endif

	return result;
}


/*** BeginHeader nf_eraseBlock */
int nf_eraseBlock(nf_device *dev, long page);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
nf_eraseBlock                 <NFLASH.LIB>

SYNTAX: int nf_eraseBlock(nf_device *dev, long page);

DESCRIPTION: Erases the block which contains the specified page, on the
             specified NAND flash device.  Check for completion of the
             erase operation using either nf_isBusyRBHW or
             nf_isBusyStatus.

             Normally, this function will not allow a bad block to be
             erased.  However, when NFLASH_CANERASEBADBLOCKS is defined by
             the application, the bad block check is not performed, and
             the application is allowed to erase any block, regardless of
             whether it is marked good or bad.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

PARAMETER2: page specifies the zero based number of a NAND flash page in
            the block to be erased, relative to the first "good" page.

RETURN VALUE: 0 if success, or the first error result encountered:
              -1 if NAND flash device is busy,
              -2 if block check time out error, or
              -3 if page is in a bad block.
END DESCRIPTION *********************************************************/
_nflash_nodebug
int nf_eraseBlock(nf_device *dev, long page)
{
	auto int i, status;

	// first, check to see if the NAND flash device is ready
	if (nf_isBusyStatus(dev)) {
		// busy, report error immediately
		return -1;
	}

	// convert relative page number to the page's actual start address
#if NFLASH_USEERASEBLOCKSIZE
	page = (page + dev->startpage) << dev->erasebitshift;
#else
	page = (page + dev->startpage) << dev->pagebitshift;
#endif

// if the application has not defined NFLASH_CANERASEBADBLOCKS
#ifndef NFLASH_CANERASEBADBLOCKS
	// check if this page is (or is in) a bad block
	status = _nf_deviceCheckBlock(dev, page);
	if (1 == status) {
		// block check time out error
		return -2;
	}
	else if (2 == status) {
		// bad block marker error
		return -3;
	}
#endif

	// now initiate the block erase (non-blocking void function call)
	_nf_deviceEraseBlock(dev, page);

	return 0;
}

/*** BeginHeader nf_writePage */
int nf_writePage(nf_device *dev, long buffer, long page);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
nf_writePage                  <NFLASH.LIB>

SYNTAX: int nf_writePage(nf_device *dev, long buffer, long page);

DESCRIPTION: Writes data to the specified NAND flash device and page from
             the specified buffer in xmem.  Check for completion of the
             write operation using nf_isBusyRBHW or nf_isBusyStatus.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

PARAMETER2: buffer is the physical address of the xmem data to be written.

PARAMETER2: page specifies the zero based number of the NAND flash page
            to be written, relative to the first "good" page.

RETURN VALUE: 0 if success, or the first error result encountered:
              -1 if NAND flash device is busy,
              -2 if block check time out error,
              -3 if page is in a bad block,
              -4 if xmem/root memory transfer error, or
              -5 if erase block or program page operation error.
END DESCRIPTION *********************************************************/
// buffer length must be equal to page/block size!
_nflash_nodebug
int nf_writePage(nf_device *dev, long buffer, long page)
{
	auto int i, result;
	auto long myMainAddr, mySpareAddr, myWriteAddr, newECC, pageOffset;
	auto unsigned long oldTimer;

	// this "state machine" falls through each state into the next, to complete
	//  the entire erase block's program pages write providing that no individual
	//  state blocks for too long while waiting for the nand flash device
	switch (dev->write_state) {
	case 0:	// not currently writing (prepare NAND flash write's state machine)
		dev->write_buffer = buffer;

	// convert relative page number to the page's actual start address
#if NFLASH_USEERASEBLOCKSIZE
		dev->write_page = (page + dev->startpage) << dev->erasebitshift;
#else
		dev->write_page = (page + dev->startpage) << dev->pagebitshift;
#endif

		dev->write_state = -1;
		// no break here, fall through to next state!
	case -1:	// save erase block's backfill information
		result = _nf_saveBackFill(dev, dev->write_page);
		if (result) {
			dev->write_state = 0;	// error, abandon this write operation
			return result;	// one of -1, -2, or -3
		}
#if !NFLASH_USEERASEBLOCKSIZE
		// calculate page's offset into the main and spare backfill data buffers
		pageOffset = (dev->write_page & ((1L << dev->erasebitshift) - 1L));
		myMainAddr = dev->mainbfbuf + pageOffset;
		mySpareAddr = dev->sparebfbuf +
		              ((pageOffset >> dev->pagebitshift) * (long) dev->sparesize);

		// copy caller's buffer into the main backfill data buffer
		result = xmem2xmem(myMainAddr, dev->write_buffer,
		                   (unsigned) dev->mainsize);
		if (result) {
			dev->write_state = 0;	// error, abandon this write operation
			return -4;	// xmem2xmem() destination in flash!
		}

		// update this page's ECCs
		if (_nf_updateECCs(myMainAddr, mySpareAddr)) {
			dev->write_state = 0;	// error, abandon this write operation
			return -4;	// root2xmem() source or destination problem!
		}
#endif
		dev->write_state = -2;
		// no break here, fall through to next state!

	// -2 in the following "case" is a magic number for the NFLASH.LIB
	//  nf_initDevice function; it is the minimum numbered (perform block
	//  erase) state in the nf_writePage function's state machine.
	case -2:	// initiate erase block operation
		_nf_deviceEraseBlock(dev, dev->write_page);
#if NFLASH_USEERASEBLOCKSIZE
		// start erase block pages' ECC calculations while the erasure proceeds!
		//  must calculate all program pages' ECCs when using caller's buffer
		//  (start by advance-updating erase block's initial program page's ECCs)
		if (_nf_updateECCs(dev->write_buffer, dev->sparebfbuf)) {
			dev->write_state = 0;	// error, abandon this write operation
			return -4;	// root2xmem() source or destination problem!
		}
#else
		// switch to use the main backfill buffer, when it exists
		dev->write_buffer = dev->mainbfbuf;
#endif
		// wait at most 11 milliseconds for completion of erase block operation
		i = 11;
		oldTimer = MS_TIMER;
		while (i) {
			result = _nf_deviceStatus(dev);
			// check for not Busy status
			if (0x40 & result) {
				break;
			}
			// check for new millisecond
			if (oldTimer != MS_TIMER) {
				oldTimer = MS_TIMER;
				--i;
			}
		}

		// check for time out or Fail status of erase block operation
		if (!i || (0x01 & result)) {
			dev->write_state = 0;	// error, abandon this write operation
			return -5;	// erase block operation failed!
		}
		// calculate the address of the erase block's initial program page
		dev->write_page = dev->write_page & ~((1L << dev->erasebitshift) - 1L);
		dev->write_state = 1;
		// no break here, fall through to next state!
	default:	// perform program page operations
		// calculate state's page offset into main buffer, spare backfill buffer
		pageOffset = (long) (dev->write_state - 1) << dev->pagebitshift;
		myMainAddr = dev->write_buffer + pageOffset;
		mySpareAddr = dev->sparebfbuf +
		              ((pageOffset >> dev->pagebitshift) * (long) dev->sparesize);

		// calculate page's NAND flash address
		myWriteAddr = dev->write_page + pageOffset;

		// (re)write all program pages back into the erase block (state 0 is
		//  reserved for "not writing," so valid states are from 1 to the number
		//  of program pages in an erase block)
		while ((0 < dev->write_state) && (dev->erasepages >= dev->write_state)) {
#ifdef NFLASH_VERBOSE
/*
			_nf_print_data("Driver's main", myWriteAddr, myMainAddr,
			              1u << dev->pagebitshift);
			_nf_print_data("Driver's spare", myWriteAddr, mySpareAddr,
			              dev->sparesize);
			printf("\n");
*/
#endif
			_nf_deviceWritePage(dev, myMainAddr, mySpareAddr, myWriteAddr);

			// start set up for next program page operation
			//  (needed for possible advance-update of next page's ECCs)
			myMainAddr += 1L << dev->pagebitshift;
			mySpareAddr += (long) dev->sparesize;

#if NFLASH_USEERASEBLOCKSIZE
			if (dev->write_state < dev->erasepages) {
				// continue erase block pages' ECC calcs while writing proceeds!
				//  must calc all program pages' ECCs when using caller's buffer
				//  (continue by advance-updating the next program page's ECCs)
				if (_nf_updateECCs(myMainAddr, mySpareAddr)) {
					dev->write_state = 0;	// error, abandon this write operation
					return -4;	// root2xmem() source or destination problem!
				}
			}
#endif

			// wait at most 2 milliseconds for completion of program page operation
			i = 2;
			oldTimer = MS_TIMER;
			while (i) {
				result = _nf_deviceStatus(dev);
				// check for not Busy status
				if (0x40 & result) {
					break;
				}
				// check for new millisecond
				if (oldTimer != MS_TIMER) {
					oldTimer = MS_TIMER;
					--i;
				}
			}

			// check for time out or Fail status of program page operation
			if (!i || (0x01 & result)) {
				dev->write_state = 0;	// error, abandon this write operation
				return -6;	// program page operation failed!
			}

			// complete set up for next program page operation
			myWriteAddr += 1L << dev->pagebitshift;
			++(dev->write_state);
		}	// end while 0<dev->write_state && dev->erasepages>=dev->write_state
	}	// end switch

	dev->write_state = 0;	// completed this write operation
	return 0;
}


/*** BeginHeader nf_getPageCount */
long nf_getPageCount(nf_device *dev);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
nf_getPageCount               <NFLASH.LIB>

SYNTAX: long nf_getPageCount(nf_device *dev);

DESCRIPTION: Returns the number of program pages on the particular NAND
             flash device.

PARAMETER1: dev is a pointer to an nf_device struct for an initialized
            NAND flash device.

RETURN VALUE: The number of program pages on the NAND flash device.
END DESCRIPTION *********************************************************/
_nflash_nodebug
long nf_getPageCount(nf_device *dev)
{
	return dev->pages;
}


/*** BeginHeader nf_getPageSize */
long nf_getPageSize(nf_device *dev);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
nf_getPageSize                <NFLASH.LIB>

SYNTAX: long nf_getPageSize(nf_device *dev);

DESCRIPTION: Returns the size in bytes (excluding "spare" bytes) of each
             program page on the particular NAND flash device.

PARAMETER1: dev is a pointer to an nf_device struct for an initialized
            NAND flash device.

RETURN VALUE: The number of data bytes in the NAND flash's program page,
              excluding the "spare" bytes used for ECC storage, etc.
END DESCRIPTION *********************************************************/
_nflash_nodebug
long nf_getPageSize(nf_device *dev)
{
	return dev->mainsize;
}


/*** BeginHeader nf_isBusyRBHW */
xmem int nf_isBusyRBHW(nf_device *dev);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
nf_isBusyRBHW                 <NFLASH.LIB>

SYNTAX: int nf_isBusyRBHW(nf_device *dev);

DESCRIPTION: Returns 1 if the specified NAND flash device is busy.  Uses
             the hardware Ready/Busy check method, and can be used to
             determine the device's busy status even at the start of a
             read page command.  Note that this function briefly enforces
             the Ready/Busy input port bit, reads the pin status, and then
             restores the port bit to its previous input/output state.
             There should be little or no visible disturbance of the LED
             output which shares the NAND flash's Ready/Busy status line.

PARAMETER1: dev is a pointer to an initialized nf_device structure for the
            particular NAND flash chip.

RETURN VALUE: 1 if busy,
              0 if ready (not currently transferring a page to be read, or
                          erasing or writing a page), or
              -1 if error (unsupported Ready/Busy input port).
END DESCRIPTION *********************************************************/
_nflash_nodebug xmem
int nf_isBusyRBHW(nf_device *dev)
{
	auto int result;

	switch (dev->rbpin.port) {
	case PDDR:
		// briefly enforce I/O bit input mode while checking the NAND flash's
		//  Ready/Busy hardware status (no point in saving a copy of the shadow
		//  because if we're interrupted PDDDR may be changed at return anyway!)
		WrPortI(PDDDR, NULL, ~(dev->rbpin.mask) & PDDDRShadow);
		// set result 1 iff Ready/Busy is low
		result = (RdPortI(PDDR) & dev->rbpin.mask) != dev->rbpin.mask;
		// restore the I/O bit's previous I/O mode
		WrPortI(PDDDR, NULL, PDDDRShadow);
		break;
	default:
		result = -1;	// unknown NAND R/B status port, set error result!
	}
	return result;
}


/*** BeginHeader nf_isBusyStatus */
xmem int nf_isBusyStatus(nf_device *dev);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
nf_isBusyStatus               <NFLASH.LIB>

SYNTAX: int nf_isBusyStatus(nf_device *dev);

DESCRIPTION: Returns 1 if the specified NAND flash device is busy erasing
             or writing to a page.  Uses the software status check method,
             which can not (must not) be used to determine the device's
             busy status at the start of a read page command.

PARAMETER1: dev is a pointer to an initialized nf_device structure for the
            particular NAND flash chip.

RETURN VALUE: 1 if busy, or
              0 if ready (not currently erasing or writing a page).
END DESCRIPTION *********************************************************/
_nflash_nodebug xmem
int nf_isBusyStatus(nf_device *dev)
{
	return !(0x40 & _nf_deviceStatus(dev));
}


/*** BeginHeader _nf_saveBackFill */
xmem int _nf_saveBackFill(nf_device *dev, long pageAddress);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_saveBackFill              <NFLASH.LIB>

SYNTAX: int _nf_saveBackFill(nf_device *dev, long pageAddress);

DESCRIPTION: Saves an erase block's backfill information into the device's
             main (if it exists) and spare data backfill buffers.

PARAMETER1: dev is a pointer to an initialized nf_device structure for the
            particular NAND flash chip.

PARAMETER2: pageAddress specifies address bits 31:00 of a NAND flash
            program page in the erase block whose backfill information is
            to be saved.  In practice, the largest supported device only
            uses address bits 26:00; unused high address bits must be zero
            filled.

RETURN VALUE: 0 if success, or the first error result encountered:
              -1 if NAND flash device is busy,
              -2 if block check (page read) time out error, or
              -3 if page is in a bad block.
END DESCRIPTION *********************************************************/
_nflash_nodebug xmem
int _nf_saveBackFill(nf_device *dev, long pageAddress)
{
	auto char testByte;
	auto int i;
	auto long myMainAddr, mySpareAddr;

	// first, check to see if the NAND flash device is ready
	if (nf_isBusyStatus(dev)) {
		// busy, report error immediately
		return -1;
	}

	// use device's main (nonzero, if it exists) and spare backfill buffers
	myMainAddr = dev->mainbfbuf;
	mySpareAddr = dev->sparebfbuf;

	// convert pageAddress to the erase block's first program page start address
	pageAddress &= ~((1L << dev->erasebitshift) - 1L);

	i = dev->erasepages;	// iterate through all of the erase block's pages
	while (i--) {
		// read main data into device's main buffer (if one exists),
		//  spare data into device's spare buffer
		if (_nf_deviceReadPage(dev, myMainAddr, mySpareAddr, pageAddress)) {
			// block check (page read) time out error
			return -2;
		}

		// check factory standard block marker byte (page's 0 based byte 517)
		// Note:  The convention is that 0xFF is good, 0x00 indicates bad from
		//        the factory, and that 0xF0 indicates gone bad while in use.
		xmem2root(&testByte, mySpareAddr + 5L, sizeof(char));
		if (0xFF != testByte) {
			// bad block marker error
			return -3;
		}

		// update local main buffer pointer only if it exists (is nonzero)
		myMainAddr += (myMainAddr) ? 1L << dev->pagebitshift : 0L;
		mySpareAddr += (long) dev->sparesize;
		pageAddress += 1L << dev->pagebitshift;
	}	// end while

	return 0;
}


/*** BeginHeader _nf_updateECCs */
xmem int _nf_updateECCs(long mainAddress, long spareAddress);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_updateECCs                <NFLASH.LIB>

SYNTAX: int _nf_updateECCs(long mainAddress, long spareAddress);

DESCRIPTION: Calculates the ECCs for a program page's main data and stores
             the new ECCs into the spare data area.

PARAMETER1: mainAddress is the physical address of the program page's main
            data buffer.

PARAMETER2: spareAddress is the physical address of the program page's
            spare data buffer.

RETURN VALUE: 0 if success, or
              -1 if xmem/root memory transfer error.
END DESCRIPTION *********************************************************/
_nflash_nodebug xmem
int _nf_updateECCs(long mainAddress, long spareAddress)
{
	auto long newECC;

	// calculate main data buffer's ECCs, save them in the spare data buffer
	newECC = xCalculateECC256(mainAddress);
	if (root2xmem(spareAddress + 13L, &newECC, 3u)) {
		return -1;	// root2xmem() source or destination problem!
	}
	newECC = xCalculateECC256(mainAddress + 256L);
	if (root2xmem(spareAddress + 8L, &newECC, 3u)) {
		return -1;	// root2xmem() source or destination problem!
	}
	return 0;
}


/*** BeginHeader _nf_deviceCheckBlock */
xmem int _nf_deviceCheckBlock(nf_device *dev, long pageAddress);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_deviceCheckBlock          <NFLASH.LIB>

SYNTAX: int _nf_deviceCheckBlock(nf_device *dev, long pageAddress);

DESCRIPTION: Returns the specified NAND flash page's good vs. bad block
             marking.  Note that because bad pages must not be erased in
             order to retain their marking, if any program page within an
             erase block is marked bad, all of the pages in the block are
             then considered to be bad.

PARAMETER1: dev is a pointer to an initialized nf_device structure for the
            particular NAND flash chip.

PARAMETER2: pageAddress specifies address bits 31:00 of the NAND flash
            page (block) to be checked.  In practice, the largest
            supported device only uses address bits 26:00; unused high
            address bits must be zero filled.

RETURN VALUE: 0 if marked as a good block,
              1 if I/O (time out) error, or
              2 if marked as a bad block.
END DESCRIPTION *********************************************************/
_nflash_nodebug xmem
int _nf_deviceCheckBlock(nf_device *dev, long pageAddress)
{
	auto char testByte;
	auto int i;
	auto long checkAddress, mainDataSize;

	mainDataSize = 1L << (long) dev->pagebitshift;
	// calculate the address of the erase block's initial program page
	checkAddress = pageAddress & ~((1L << (long) dev->erasebitshift) - 1L);
	i = dev->erasepages;	// iterate through all of the erase block's pages
	// to be considered a good block, all of the pages must be marked good
	while (i--) {
		// read only the spare data (page's 0 based bytes 512 through 527)
		if (_nf_deviceReadPage(dev, 0L, dev->sparebuffer, checkAddress)) {
			return 1;
		}
		// check factory standard block marker byte (page's 0 based byte 517)
		// Note:  The convention is that 0xFF is good, 0x00 indicates bad from
		//        the factory, and that 0xF0 indicates gone bad while in use.
		xmem2root(&testByte, dev->sparebuffer + 5L, sizeof(char));
		if (0xFF != testByte) {
			// bad block marker error
			return 2;
		}
		checkAddress += mainDataSize;
	}
	return 0;
}


/*** BeginHeader _nf_deviceEraseBlock */
void _nf_deviceEraseBlock(nf_device *dev, long pageAddress);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_deviceEraseBlock          <NFLASH.LIB>

SYNTAX: void _nf_deviceEraseBlock(nf_device *dev, long pageAddress);

DESCRIPTION: Erases on the specified NAND flash device the specified
             block, consisting of multiple (typically 32) program pages.
             Note that this function ignores PageAddress bits 08:00.
             Check for completion of the erase operation using either
             nf_isBusyRBHW or nf_isBusyStatus.  Or, use _nf_deviceStatus
             to check for Ready/Busy, Pass/Fail and Write Protect status.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

PARAMETER2: pageAddress specifies address bits 31:00 of the NAND flash
            page to be erased.  In practice, the largest supported device
            only uses address bits 26:09 and bits 13:09 are ignored;
            unused high address bits must be zero filled.

RETURN VALUE: None.
END DESCRIPTION *********************************************************/
#asm xmem _nflash_nodebug
_nf_deviceEraseBlock::
		push	ix						; must not alter IX (for costates, cofuncs, etc.)
		ld		ix, (SP+_LCALL_RETBYTES+2+0)	; pointer to dev
		ld		hl, (SP+_LCALL_RETBYTES+2+3)	; get middle bytes of pageAddress
		ex		de, hl				; swap middle bytes of pageAddress into DE
		ld		hl, (SP+_LCALL_RETBYTES+2+4)	; get MSBs of pageAddress
		ld		c, h					; copy MSB of pageAddress into C (31:08 in CDE)
		srl	c						; shift 0 into C MSbit, C LSbit (24) into Carry
		rr		de						; rotate Carry into DE MSbit (now 32:09 in CDE)
#if _USER
		push	bc
      push	de
      push	ix

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	ix
      pop	de
      pop	bc
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; activate this NAND's /CE
#endif

		ld		hl, (IX+nf_device_st+baseaddress)
		inc	hl						; add CLE offset to base I/O address in HL
		ld		a, 0x60				; Auto Block Erase command's first byte
ioe	ld		(hl), a				; issue command's first byte
		inc	hl						; increment to ALE offset from base I/O address
		ld		a, (IX+nf_device_st+addressbytes)	; page read/program addr bytes
		dec	a						; Auto Block Erase cmd uses one less address byte
ioe	ld		(hl), e				; send Auto Block Erase command's 1st address byte
		dec	a						; one less address byte to send
		jr		z, .doneAddr_nf_dEB	; if done (Zero flag set), skip DC bytes

ioe	ld		(hl), d				; send Auto Block Erase command's 2nd address byte
		dec	a						; one less address byte to send
		jr		z, .doneAddr_nf_dEB	; if done (Zero flag set), skip C byte

ioe	ld		(hl), c				; send Auto Block Erase command's 3rd address byte
.doneAddr_nf_dEB:
		dec	hl						; decrement to CLE offset from base I/O address
		ld		a, 0xD0				; Auto Block Erase command's second byte
ioe	ld		(hl), a				; issue command's second byte
#if _USER
      push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; deactivate this NAND's /CE
#endif
		pop	ix						; must not alter IX (for costates, cofuncs, etc.)
		lret
#endasm


/*** BeginHeader _nf_deviceID */
long _nf_deviceID(nf_device *dev);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_deviceID                  <NFLASH.LIB>

SYNTAX: long _nf_deviceID(nf_device *dev);

DESCRIPTION: Reports the Manufacturer and Device ID codes of the specified
             NAND flash device.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

RETURN VALUE: The Manufacturer ID code is in the LSB of the result, the
              Device ID code is in the lower middle byte (bits 15:08) of
              the result.  The MSBs of the result are currently returned
              zero filled, but a long result is returned to facilitate
              expansion should there be a proliferation of compatible NAND
              flash manufacturers and/or devices in future.
END DESCRIPTION *********************************************************/
#asm xmem _nflash_nodebug
_nf_deviceID::
		push	ix						; must not alter IX (for costates, cofuncs, etc.)
		ld		ix, (SP+_LCALL_RETBYTES+2+0)	; pointer to dev
#if _USER
      push	ix

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; activate this NAND's /CE
#endif
		ld		hl, (IX+nf_device_st+baseaddress)
		inc	hl						; add CLE offset to base I/O address in HL
		ld		a, _NFLASH_IDREAD	; ID Read command byte
ioe	ld		(hl), a				; issue command
		inc	hl						; increment to ALE offset from base I/O address
		xor	a						; ID Read address byte (is zero)
ioe	ld		(hl), a				; send ID Read command's address
		dec	hl						; restore base I/O
		dec	hl						;  address
ioe	ld		e, (hl)				; manufacturer code into LSB of long (BCDE) result
ioe	ld		d, (hl)				; device code into least middle byte
		ld		bc, 0x0000			; for now, zero out MSBs of long (BCDE) result
#if _USER
      push	ix
      push	bc
      push	de
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	de
      pop	bc
      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; deactivate this NAND's /CE
#endif
		pop	ix						; must not alter IX (for costates, cofuncs, etc.)
		lret
#endasm


/*** BeginHeader _nf_deviceReadPage */
int _nf_deviceReadPage(nf_device *dev, long mainBuffer, long spareBuffer,
                       long pageAddress);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_deviceReadPage            <NFLASH.LIB>

SYNTAX: int _nf_deviceReadPage(nf_device *dev, long mainBuffer,
                              long spareBuffer, long pageAddress);

DESCRIPTION: Reads from the specified NAND flash page its main and/or
             spare data into the specified buffers at their respective
             nonzero physical addresses.  Note that this function ignores
             pageAddress bits 08:00.  Use _nf_deviceStatus to check for
             Pass/Fail status after completion of the read operation.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

PARAMETER2: mainBuffer, if nonzero, is the physical address of the page's
            main data destination buffer.  If mainBuffer is zero, the
            page's main data is ignored.

PARAMETER3: spareBuffer, if nonzero, is the physical address of the page's
            spare data destination buffer.  If spareBuffer is zero, the
            page's spare data is ignored.

PARAMETER4: pageAddress specifies address bits 31:00 of the NAND flash
            page to be read.  In practice, the largest supported device
            only uses address bits 26:00; unused high address bits must be
            zero filled.

RETURN VALUE: 0 if success, or
              1 if time out error.
END DESCRIPTION *********************************************************/
#asm xmem _nflash_nodebug
_nf_deviceReadPage::
		ld		a, _NFLASH_READMODE1	; default to Read Mode (1) command byte
		ld		hl, (SP+_LCALL_RETBYTES+0+2)	; get mainBuffer LSBs
		ex		de, hl				; copy mainBuffer LSBs for OR later
		ld		hl, (SP+_LCALL_RETBYTES+0+4)	; get mainBuffer MSBs
		or		hl, de				; nonzero mainBuffer physical address?
		jr		nz, .doRM1_nf_dRP	; if yes (Zero flag reset), go do Read Mode (1)

		ld		hl, (SP+_LCALL_RETBYTES+0+6)	; get spareBuffer LSBs
		ex		de, hl				; copy spareBuffer LSBs for OR later
		ld		hl, (SP+_LCALL_RETBYTES+0+8)	; get spareBuffer MSBs
		or		hl, de				; nonzero spareBuffer physical address?
		jr		nz, .doRM3_nf_dRP	; if yes (Zero flag reset), go do Read Mode (3)

		lret							; nothing to do, return "success" (HL is zero)

.doRM3_nf_dRP:
		ld		a, _NFLASH_READMODE3	; switch to use Read Mode (3) command byte
.doRM1_nf_dRP:
		push	ix						; must not alter IX (for costates, cofuncs, etc.)
		ld		ix, (SP+_LCALL_RETBYTES+2+0)	; pointer to dev
#if _USER
		push	af
		push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4
      pop	ix

      push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4

      pop	ix
      pop	af
      altd	ld		a, a					; copy Read Mode (1, 3) command byte for later
#else
altd	ld		a, a					; copy Read Mode (1, 3) command byte for later
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; activate this NAND's /CE
#endif
		ld		hl, (SP+_LCALL_RETBYTES+2+11)	; get middle bytes of pageAddress
		ex		de, hl				; swap pageAddress middle bytes into DE
		ld		hl, (SP+_LCALL_RETBYTES+2+12)	; get MSBs of pageAddress
		ld		b, h					; copy MSB of pageAddress into B (31:08 in BDE)
		srl	b						; shift 0 into B MSbit, B LSbit (24) into Carry
		rr		de						; rotate Carry into DE MSbit (now 32:09 in BDE)
		ld		c, d					; now move address 32:09 into
		ld		d, e					;  BCD and finally,
		ld		e, 0					;  make address 32:09|07:00 in BCDE
		ld		hl, (IX+nf_device_st+baseaddress)
		inc	hl						; add CLE offset to base I/O address in HL
		ex		af, af'				; recover the Read Mode (1, 3) command byte
ioe	ld		(hl), a				; issue Read Mode (1 or 3) command
		inc	hl						; increment to ALE offset from base I/O address
		ld		a, (IX+nf_device_st+addressbytes)	; page read/program addr bytes
ioe	ld		(hl), e				; send Read Mode (1, 3) command's 1st address byte
		dec	a						; one less address byte to send
		jr		z, .doneAddr_nf_dRP	; if done (Zero flag set), skip DCB bytes

ioe	ld		(hl), d				; send Read Mode (1, 3) command's 2nd address byte
		dec	a						; one less address byte to send
		jr		z, .doneAddr_nf_dRP	; if done (Zero flag set), skip CB bytes

ioe	ld		(hl), c				; send Read Mode (1, 3) command's 3rd address byte
		dec	a						; one less address byte to send
		jr		z, .doneAddr_nf_dRP	; if done (Zero flag set), skip B byte

ioe	ld		(hl), b				; send Read Mode (1, 3) command's 4th address byte
.doneAddr_nf_dRP:
		ld		b, 10					; busy wait time out loop count
.busyLoop_nf_dRP:
		push	bc						; save the time out count
		ld		hl, (SP+_LCALL_RETBYTES+4+0)
		push	hl						; stack up the dev parameter
		lcall	nf_isBusyRBHW
		add	sp, 2					; scrape HL residue off of the stack
		pop	bc						; recover the remaining time out count
		bool	hl						; HL now contains 1 iff device is busy
		jr		z, .notBusy_nf_dRP	; if not busy (Zero flag set), go read the page

		djnz	.busyLoop_nf_dRP	; if not timed out, loop back to check busy again

		pop	ix						; must not alter IX (for costates, cofuncs, etc.)
      lret							; device busy too long, return HL's time out error

.notBusy_nf_dRP:
		ld		hl, (SP+_LCALL_RETBYTES+2+4)	; get mainBuffer address bits 31:16
		ex		de, hl				; copy mainBuffer address bits 31:16 for later
		ld		hl, (SP+_LCALL_RETBYTES+2+2)	; get mainBuffer address bits 15:00
		or		hl, de				; zero mainBuffer physical address?
		jr		z, .spareXfer_nf_dRP	; if yes (Zero flag set), go get spare data

		push	af						; preserve Zero (may not be last transfer) flag
		ld		b, 0					; 512 bytes main data two-byte transfer loop count
		ld		ix, (SP+_LCALL_RETBYTES+4+0)	; pointer to dev
		ld		hl, (IX+nf_device_st+baseaddress)
		ex		de, hl				; swap mainBuffer MSBs, base external I/O address
		ld		ix, (SP+_LCALL_RETBYTES+4+2)	; get mainBuffer address bits 15:00
		jr		.copy1916_nf_dRP

.spareCheck_nf_dRP:
		ld		hl, (SP+_LCALL_RETBYTES+2+8)	; get spareBuffer address bits 31:16
		ex		de, hl				; copy spareBuffer address bits 31:16 for later
		ld		hl, (SP+_LCALL_RETBYTES+2+6)	; get spareBuffer address bits 15:00
		or		hl, de				; zero spareBuffer physical address?
		jr		z, .exit_nf_dRP	; if yes (Zero flag set), we're done, go exit

.spareXfer_nf_dRP:
		xor	a						; set Zero flag to mark last transfer to be done
		push	af						; preserve Zero (last transfer for sure) flag
		ld		b, 8					; 16 bytes spare data two-byte transfer loop count
		ld		ix, (SP+_LCALL_RETBYTES+4+0)	; pointer to dev
		ld		hl, (IX+nf_device_st+baseaddress)
		ex		de, hl				; swap base external I/O address into DE for later
		ld		ix, (SP+_LCALL_RETBYTES+4+6)	; get spareBuffer address bits 15:00
		ld		hl, (SP+_LCALL_RETBYTES+4+8)	; get spareBuffer address bits 31:16
.copy1916_nf_dRP:
		ld		a, L					; copy xxxxxBuffer physical address bits 19:16
altd	ld		a, a					; copy buffer start address bits 19:16 for later
		ld		hl, ix				; copy buffer start address bits 15:00
		bit	0, L					; does destination buffer start on odd address?
		jr		z, .evenBegin_nf_dRP	; no (Zero flag set), go skip "odd" start
		ex		af, af'				; save even/odd (set/reset) Zero flag for later
		ldp	hl, (ix)				; pre-read the MSB of data pair from main memory
		ex		de, hl				; swap base external I/O address into HL
ioe	ld		e, (hl)				; get only LSB of data pair from the NAND flash
		ex		de, hl				; swap NAND flash, main memory data pair into HL
		ldp	(ix), hl				; save the begin "odd" data pair into the buffer
		jr		.oddEntry_nf_dRP	; enter read loop at "odd" point (B count correct)

.evenBegin_nf_dRP:
		ex		af, af'				; save even/odd (set/reset) Zero flag for later
.readLoop_nf_dRP:
		ex		de, hl				; swap base external I/O data address into HL
ioe	ld		e, (hl)				; get LSB of data pair from the NAND flash
ioe	ld		d, (hl)				; get MSB of data pair from the NAND flash
		ex		de, hl				; swap NAND flash data pair into HL
		ldp	(ix), hl				; save this NAND flash data pair into the buffer
		inc	ix						; increment to the . . .
.oddEntry_nf_dRP:
		inc	ix						;  next data pair buffer address
		ld		hl, ix				; copy new buffer address bits 15:00
		bool	hl						; address bits 15:00 wrapped around to zero?
		jr		nz, .same1916_nf_dRP	; no wrap (Z flag reset), go skip A's increment

		inc	a						; increment physical address bits 19:16
.same1916_nf_dRP:
		djnz	.readLoop_nf_dRP	; if not done all data pair transfers, loop back

		ex		af, af'				; did destination buffer start on odd address?
		jr		z, .evenEnd_nf_dRP	; no (Zero flag set), go skip "odd" finish

		ex		af, af'				; swap physical address bits 19:16 back into A
		ldp	hl, (ix)				; pre-read the MSB of data pair from main memory
		ex		de, hl				; swap base external I/O data address into HL
ioe	ld		e, (hl)				; get only LSB of data pair from the NAND flash
		ex		de, hl				; swap NAND flash, main memory data pair into HL
		ldp	(ix), hl				; save the end "odd" data pair into the buffer
.evenEnd_nf_dRP:
		pop	af						; recover Zero (last transfer) flag (set == last)
		jr		nz, .spareCheck_nf_dRP	; if maybe not last transfer (Zero flag
												;  reset), go check spare data transfer
.exit_nf_dRP:
		ld		ix, (SP+_LCALL_RETBYTES+2+0)	; pointer to dev
#if _USER
		push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4

      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; deactivate this NAND's /CE
#endif
		pop	ix						; must not alter IX (for costates, cofuncs, etc.)
		bool	hl						; so far as can be told at this point,
		ld		L, h					;  everything went A-OK!
		lret							; return "success"
#endasm


/*** BeginHeader _nf_deviceReset */
void _nf_deviceReset(nf_device *dev);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_deviceReset               <NFLASH.LIB>

SYNTAX: void _nf_deviceReset(nf_device *dev);

DESCRIPTION: Resets the specified NAND flash device to a known state.
             Check for completion of the reset operation using either
             nf_isBusyRBHW or nf_isBusyStatus.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

RETURN VALUE: None.
END DESCRIPTION *********************************************************/
#asm xmem _nflash_nodebug
_nf_deviceReset::
		push	ix						; must not alter IX (for costates, cofuncs, etc.)
		ld		ix, (SP+_LCALL_RETBYTES+2+0)	; pointer to dev
#if _USER
		push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; activate this NAND's /CE
#endif
		ld		hl, (IX+nf_device_st+baseaddress)
		inc	hl						; add CLE offset to base I/O address in HL
		ld		a, _NFLASH_RESET	; Reset command byte
ioe	ld		(hl), a				; issue command
#if _USER
      push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; deactivate this NAND's /CE
#endif
		pop	ix						; must not alter IX (for costates, cofuncs, etc.)
		lret
#endasm


/*** BeginHeader _nf_deviceStatus */
int _nf_deviceStatus(nf_device *dev);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_deviceStatus              <NFLASH.LIB>

SYNTAX: int _nf_deviceStatus(nf_device *dev);

DESCRIPTION: Reports the internal status of the specified NAND flash
             device.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

RETURN VALUE: The NAND flash device's status in the LSB of the result:
                bit 0 is Pass (0) or Fail (1), and only valid when Ready;
                bits 1 through 5 are not used (forced to 0);
                bit 6 is Busy (0) or Ready (1);
                bit 7 is Write Protected (0) or Not Write Protected (1).
END DESCRIPTION *********************************************************/
#asm xmem _nflash_nodebug
_nf_deviceStatus::
		push	ix						; must not alter IX (for costates, cofuncs, etc.)
		ld		ix, (SP+_LCALL_RETBYTES+2+0)	; pointer to dev
#if _USER
		push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; activate this NAND's /CE
#endif
		ld		hl, (IX+nf_device_st+baseaddress)
		inc	hl						; add CLE offset to base I/O address in HL
		ld		a, _NFLASH_STATUSREAD	; Status Read command byte
ioe	ld		(hl), a				; issue command
		dec	hl						; restore base I/O address
ioe	ld		e, (hl)				; get status byte
#if _USER
		push	de
		push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
		pop	ix
      pop	de
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; deactivate this NAND's /CE
#endif
		bool	hl						; clear H (MSB of result)
		ld		a, e					; copy status byte into A
		and	0xC1					; ensure status bits 1:5 are all reset (clear)
		ld		L, a					; put status byte into L (LSB of result)
		pop	ix						; must not alter IX (for costates, cofuncs, etc.)
		lret
#endasm


/*** BeginHeader _nf_deviceWritePage */
void _nf_deviceWritePage(nf_device *dev, long mainBuffer, long spareBuffer,
                        long pageAddress);
/*** EndHeader */
/* START_FUNCTION DESCRIPTION ********************************************
_nf_deviceWritePage           <NFLASH.LIB>

SYNTAX: void _nf_deviceWritePage(nf_device *dev, long mainBuffer,
                                long spareBuffer, long pageAddress);

DESCRIPTION: Writes to the specified NAND flash page the main and spare
             data from the specified buffers.  Note that this function
             ignores pageAddress bits 08:00.  Use _nf_deviceStatus to
             check for Pass/Fail status after completion of the write
             operation.

PARAMETER1: dev is a pointer to an initialized nf_device structure.

PARAMETER2: pageAddress specifies address bits 31:00 of the NAND flash
            page to be written.  In practice, the largest supported device
            only uses address bits 26:00; unused high address bits must be
            zero filled.

PARAMETER3: mainBuffer is the physical address of the page's main data
            source buffer, which should never be zero.

PARAMETER4: spareBuffer is the physical address of the page's spare data
            source buffer, which should never be zero.

RETURN VALUE: None.
END DESCRIPTION *********************************************************/
#asm xmem _nflash_nodebug
_nf_deviceWritePage::
		push	ix						; must not alter IX (for costates, cofuncs, etc.)
		ld		ix, (SP+_LCALL_RETBYTES+2+0)	; pointer to dev
#if _USER
		push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		cpl							; complement the mask to reset the NAND's /CE bit
		and	(hl)					; AND together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; activate this NAND's /CE
#endif
		ld		hl, (SP+_LCALL_RETBYTES+2+11)	; get middle bytes of pageAddress
		ex		de, hl				; swap pageAddress middle bytes into DE
		ld		hl, (SP+_LCALL_RETBYTES+2+12)	; get MSBs of pageAddress
		ld		b, h					; copy MSB of pageAddress into B (31:08 in BDE)
		srl	b						; shift 0 into B MSbit, B LSbit (24) into Carry
		rr		de						; rotate Carry into DE MSbit (now 32:09 in BDE)
		ld		c, d					; now move address 32:09 into
		ld		d, e					;  BCD and finally,
		ld		e, 0					;  make address 32:09|07:00 in BCDE
		ld		hl, (IX+nf_device_st+baseaddress)
		inc	hl						; add CLE offset to base I/O address in HL
		xor	a						; Read Mode (1) command byte (is zero)
ioe	ld		(hl), a				; issue command (to reset Auto Program's pointer!)
		ld		a, _NFLASH_DATAINPUT	; Serial Data Input command byte
ioe	ld		(hl), a				; issue command
		inc	hl						; increment to ALE offset from base I/O address
		ld		a, (IX+nf_device_st+addressbytes)	; page read/program addr bytes
ioe	ld		(hl), e				; send Auto Program command's 1st address byte
		dec	a						; one less address byte to send
		jr		z, .doneAddr_nf_dWP	; if done (Zero flag set), skip DCB bytes

ioe	ld		(hl), d				; send Auto Program command's 2nd address byte
		dec	a						; one less address byte to send
		jr		z, .doneAddr_nf_dWP	; if done (Zero flag set), skip CB bytes

ioe	ld		(hl), c				; send Auto Program command's 3rd address byte
		dec	a						; one less address byte to send
		jr		z, .doneAddr_nf_dWP	; if done (Zero flag set), skip B byte

ioe	ld		(hl), b				; send Auto Program command's 4th address byte
.doneAddr_nf_dWP:
		dec	hl						; decrement to CLE offset from base I/O address
		dec	hl						; decrement to base external I/O address
		ex		de, hl				; swap base external I/O address into DE for later
		inc	a						; ensure nonzero A (A isn't 0xFF before the inc)
		or		a						; reset Zero flag to mark not last transfer
		push	af						; preserve Zero (is not last transfer) flag
		ld		b, 0					; 512 bytes main data two-byte transfer loop count
		ld		ix, (SP+_LCALL_RETBYTES+4+2)	; get mainBuffer address bits 15:00
		ld		hl, (SP+_LCALL_RETBYTES+4+4)	; get mainBuffer address bits 31:16
		jr		.copy1916_nf_dWP

.spareXfer_nf_dWP:
		xor	a						; set Zero flag to mark last transfer to be done
		push	af						; preserve Zero (last transfer for sure) flag
		ld		b, 8				; 16 bytes spare data two-byte transfer loop count
		ld		ix, (SP+_LCALL_RETBYTES+4+6)	; get spareBuffer address bits 15:00
		ld		hl, (SP+_LCALL_RETBYTES+4+8)	; get spareBuffer address bits 31:16
.copy1916_nf_dWP:
		ld		a, L					; copy xxxxxBuffer physical address bits 19:16
altd	ld		a, a					; copy buffer start address bits 19:16 for later
		ld		hl, ix				; copy buffer start address bits 15:00
		bit	0, L					; does destination buffer start on odd address?
		jr		z, .evenBegin_nf_dWP	; no (Zero flag set), go skip "odd" start
		ex		af, af'				; save even/odd (set/reset) Zero flag for later
		ldp	hl, (ix)				; read the LSB of data pair from main memory
		ex		de, hl				; swap data pair LSB, base external I/O address
ioe	ld		(hl), e				; write only LSB of data pair to the NAND flash
		ex		de, hl				; swap base external I/O data address back into DE
		jr		.oddEntry_nf_dWP	; enter write loop at odd point (B count correct)

.evenBegin_nf_dWP:
		ex		af, af'				; save even/odd (set/reset) Zero flag for later
.writeLoop_nf_dWP:
		ldp	hl, (ix)				; get NAND flash's data pair from the buffer
		ex		de, hl				; swap data pair, base external I/O data address
ioe	ld		(hl), e				; write LSB of data pair to the NAND flash
ioe	ld		(hl), d				; write MSB of data pair to the NAND flash
		ex		de, hl				; swap base external I/O data address back into DE
		inc	ix						; increment to the . . .
.oddEntry_nf_dWP:
		inc	ix						;  next data pair buffer address
		ld		hl, ix				; copy new buffer address bits 15:00
		bool	hl						; address bits 15:00 wrapped around to zero?
		jr		nz, .same1916_nf_dWP	; no wrap (Zero flag reset), go skip increment

		inc	a						; increment physical address bits 19:16
.same1916_nf_dWP:
		djnz	.writeLoop_nf_dWP	; if not done all data pair transfers, loop back

		ex		af, af'				; did destination buffer start on odd address?
		jr		z, .evenEnd_nf_dWP	; no (Zero flag set), go skip "odd" finish

		ex		af, af'				; swap physical address bits 19:16 back into A
		ldp	hl, (ix)				; read the LSB of data pair from main memory
		ex		de, hl				; swap data pair LSB, base external I/O address
ioe	ld		(hl), e				; write only LSB of data pair to the NAND flash
		ex		de, hl				; swap base external I/O data address back into DE
.evenEnd_nf_dWP:
		pop	af						; recover Zero (last transfer) flag (set == last)
		jr		nz, .spareXfer_nf_dWP	; if not last transfer (Zero flag reset),
												;  go do spare data transfer
		ex		de, hl				; swap base external I/O data address into HL
		inc	hl						; add CLE offset to base I/O address in HL
		ld		a, _NFLASH_AUTOPROGRAM	; Auto Program command byte
ioe	ld		(hl), a				; issue command
		ld		ix, (SP+_LCALL_RETBYTES+2+0)	; pointer to dev
#if _USER
		push	ix
      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
      push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_read
      add	sp,4

      ld		hl, ix
      ld		de, nf_device_st+shadow_value
      add	hl,de
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content

      bool	hl
      ld		L,a
		push	hl
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
      push	hl
		call	_sys_direct_write
      add	sp,4
      pop	ix
#else
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+shadow)
		ld		a, (IX+nf_device_st+cspin+sys_iopin_st+mask)
		or		(hl)					; OR together with NAND's /CE shadow content
		ld		(hl), a				; update NAND's /CE shadow
		ld		hl, (IX+nf_device_st+cspin+sys_iopin_st+port)
ioi	ld		(hl), a				; deactivate this NAND's /CE
#endif
		pop	ix						; must not alter IX (for costates, cofuncs, etc.)
		lret
#endasm


/*** BeginHeader */
#endif	// __NFLASH_LIB__
/*** EndHeader */