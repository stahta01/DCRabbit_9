/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*** BeginHeader  ********************************************/
#ifndef __ZCONSOLE_LIB
#define __ZCONSOLE_LIB
/*** EndHeader ***********************************************/

/*
 *    zconsole.lib
 *
 *    A command-oriented console library, mainly for TCP/IP
 *		functionality.
 *
 */

/*** BeginHeader */

#ifdef ZCONSOLE_DEBUG
	#define _zconsole_nodebug
#else
	#define _zconsole_nodebug nodebug
#endif

#ifndef CON_CMD_SIZE
	#define CON_CMD_SIZE 128
#endif

#ifndef CON_BUF_SIZE
	#define CON_BUF_SIZE 1024
#endif

#ifndef CON_CMD_DATA_SIZE
	#define CON_CMD_DATA_SIZE 16
#endif

#ifndef CON_VAR_BUF_SIZE
	#define CON_VAR_BUF_SIZE 1024
#endif

#ifndef CON_INIT_MESSAGE
	#define CON_INIT_MESSAGE "Console Ready\r\n"
#endif

#ifndef CON_TIMEOUT
	#define CON_TIMEOUT 60
#endif

#ifdef __FS2_LIB
	#ifndef CON_BACKUP_FILE1
		#define CON_BACKUP_FILE1 254
	#endif

	#ifndef CON_BACKUP_FILE2
		#define CON_BACKUP_FILE2 255
	#endif
#else
	#ifndef CON_BACKUP_FILE1
		#define CON_BACKUP_FILE1 128
	#endif

	#ifndef CON_BACKUP_FILE2
		#define CON_BACKUP_FILE2 129
	#endif
#endif

#ifndef CON_FS_NUM_BLOCKS
	#define CON_FS_NUM_BLOCKS 63
#endif

#ifndef CON_MAIL_FROM_SIZE
	#define CON_MAIL_FROM_SIZE 51
#endif

#ifndef CON_MAIL_SERV_SIZE
	#define CON_MAIL_SERV_SIZE 51
#endif

#ifndef CON_MAIL_BUF_SIZE
	#define CON_MAIL_BUF_SIZE 1024
#endif

#ifndef CON_HOSTNAME
	#define CON_HOSTNAME "rabbit"
#endif

#ifndef CON_SP_RDBUF_SIZE
	#define CON_SP_RDBUF_SIZE 255
#endif

#ifndef CON_SP_WRBUF_SIZE
	#define CON_SP_WRBUF_SIZE 255
#endif

#ifndef CON_MAX_PASSWORD
	#define CON_MAX_PASSWORD 10
#endif

#ifndef CON_MAX_NAME
	#define CON_MAX_NAME 10
#endif

#ifndef CON_DHCP_ACQUIRE_RETRY_TIMEOUT
	#define CON_DHCP_ACQUIRE_RETRY_TIMEOUT 120
#endif

#if CON_MAX_NAME>CON_CMD_DATA_SIZE
	#error "CON_CMD_DATA_SIZE must be >= CON_MAX_NAME"
#endif

#ifndef CON_NO_FS_SUPPORT
	#ifndef FS_FLASH
		#ifndef FS_RAM
			#ifndef FS_FLASH_SINGLE
				#ifndef __FS2_LIB
					#define CON_NO_FS_SUPPORT
				#endif
			#endif
		#endif
	#endif
#endif

// ConsoleCommand structure
typedef struct {
	char* command;
	int (*cmdfunc)();
	long helptext;
} ConsoleCommand;

// ConsoleError structure
typedef struct {
	unsigned int code;
	char* message;
} ConsoleError;

// ConsoleIO structure
typedef struct {
	long param;
	int (*open)();
	void (*close)();
	int (*tick)();
	int (*puts)();
	int (*rdUsed)();
	int (*wrUsed)();
	int (*wrFree)();
	int (*read)();
	int (*write)();
} ConsoleIO;

#ifndef SSPEC_MAXSPEC
	#define SSPEC_MAXSPEC 1
#endif

// ConsoleBackupInfo structure
typedef struct {
	char				top; // used to mark the top of the struct
	unsigned long	param[NUM_CONSOLES];
	char				echo[NUM_CONSOLES];
} ConsoleBackupInfo;

// ConsoleTCPBackupInfo structure
typedef struct {
	char				top;
	unsigned long	ip;
	unsigned long	netmask;
	unsigned long 	gateway;
	unsigned long	nameserver;
} ConsoleTCPBackupInfo;

#ifdef DCRTCP
typedef struct {
	char				top;
	NetConfSave		save;
} ConsoleTCPMultiBackupInfo;
#endif

// ConsoleHTTPBackupInfo structure
typedef struct {
	char				top;
	unsigned int	varstrlen[SSPEC_MAXSPEC];
	long				varbuflen;
} ConsoleHTTPBackupInfo;

// ConsoleSMTPBackupInfo structure
typedef struct {
	char				top;
	char				mail_from[CON_MAIL_FROM_SIZE];
	char				mail_serv[CON_MAIL_SERV_SIZE];
} ConsoleSMTPBackupInfo;

typedef struct {
	void* data;
	int len;
	void (*postload)();
	void (*presave)();
} ConsoleBackup;

// pre-defined console_io structs
#define CONSOLE_IO_SERA(param)	{ param, serAopen, conio_serA_close, NULL, conio_serA_puts, serArdUsed, serAwrUsed, serAwrFree, serAread, serAwrite }
#define CONSOLE_IO_SERB(param)	{ param, serBopen, conio_serB_close, NULL, conio_serB_puts, serBrdUsed, serBwrUsed, serBwrFree, serBread, serBwrite }
#define CONSOLE_IO_SERC(param)	{ param, serCopen, conio_serC_close, NULL, conio_serC_puts, serCrdUsed, serCwrUsed, serCwrFree, serCread, serCwrite }
#define CONSOLE_IO_SERD(param)	{ param, serDopen, conio_serD_close, NULL, conio_serD_puts, serDrdUsed, serDwrUsed, serDwrFree, serDread, serDwrite }
#define CONSOLE_IO_SERE(param)	{ param, serEopen, conio_serE_close, NULL, conio_serE_puts, serErdUsed, serEwrUsed, serEwrFree, serEread, serEwrite }
#define CONSOLE_IO_SERF(param)	{ param, serFopen, conio_serF_close, NULL, conio_serF_puts, serFrdUsed, serFwrUsed, serFwrFree, serFread, serFwrite }
#define CONSOLE_IO_TELNET(port)	{ port, conio_telnet_open, conio_telnet_close, conio_telnet_tick, conio_telnet_puts, conio_telnet_rdUsed, conio_telnet_wrUsed, conio_telnet_wrFree, conio_telnet_read, conio_telnet_write }
#define CONSOLE_IO_SP(channel)	{ (long)channel, conio_sp_open, conio_sp_close, conio_sp_tick, conio_sp_puts, conio_sp_rdUsed, conio_sp_wrUsed, conio_sp_wrFree, conio_sp_read, conio_sp_write }

// ConsoleState structure
typedef struct {
	int console_number;
	ConsoleIO* conio;
	int state;
	int laststate;

	char command[CON_CMD_SIZE];
	char* cmdptr;
	char buffer[CON_BUF_SIZE];
	char* bufferend;

	ConsoleCommand* cmdspec;
	int sawcr;
	int sawesc;
	int echo;
	int substate;
	unsigned int error;
	int numparams;
	int commandparams;
	char cmddata[CON_CMD_DATA_SIZE];
#ifndef CON_NO_FS_SUPPORT
	FileNumber filenum;
	File file;
#endif
	int spec;

	long timeout;
} ConsoleState;

typedef struct
{
	char 	name[CON_MAX_NAME];
	char	password[CON_MAX_PASSWORD];
} ConsoleLogin;

ConsoleState __constate[NUM_CONSOLES];
void (*__con_user_timeout)();
void (*__con_user_idle)();
ConsoleBackupInfo console_backup_info;
ConsoleTCPBackupInfo console_tcp_backup_info;
#ifdef DCRTCP
ConsoleTCPMultiBackupInfo console_tcp_multi_backup_info;
#endif
ConsoleHTTPBackupInfo console_http_backup_info;
ConsoleSMTPBackupInfo console_smtp_backup_info;
ConsoleLogin console_login;

#ifdef __FS2_LIB
FSLXnum __con_files_lx;
FSLXnum __con_backup_lx;
#endif

// Predefined ConsoleBackup strutures
#define CONSOLE_BASIC_BACKUP { &console_backup_info, \
                               sizeof(ConsoleBackupInfo), \
                               con_backup_info_postload, \
                               con_backup_info_presave }
#define CONSOLE_TCP_BACKUP { &console_tcp_backup_info, \
                             sizeof(ConsoleTCPBackupInfo), \
                             con_tcp_backup_info_postload, \
                             con_tcp_backup_info_presave }
#define CONSOLE_TCP_MULTI_BACKUP { &console_tcp_multi_backup_info, \
                                   sizeof(ConsoleTCPMultiBackupInfo),\
                                   con_tcp_multi_backup_info_postload,\
                                   con_tcp_multi_backup_info_presave }
#define CONSOLE_HTTP_BACKUP { &console_http_backup_info, \
                              sizeof(ConsoleHTTPBackupInfo), \
                              con_http_backup_info_postload, \
                              con_http_backup_info_presave }, \
                            { server_spec, \
                              sizeof(server_spec), \
                              NULL, \
                              NULL }
#define CONSOLE_SMTP_BACKUP { &console_smtp_backup_info, \
                              sizeof(ConsoleSMTPBackupInfo), \
                              con_smtp_backup_info_postload, \
                              con_smtp_backup_info_presave }
#define CONSOLE_LOGIN_BACKUP { &console_login, \
                               sizeof(ConsoleLogin), \
                               NULL, \
                               NULL }

long __con_varbuf;
long __con_varbuflen;
long __con_mailbuf;
int __con_mailbuf_lock;

#define CON_ERR_TIMEOUT				1
#define CON_ERR_BADCOMMAND			2
#define CON_ERR_BADPARAMETER		3
#define CON_ERR_NAMETOOLONG		4
#define CON_ERR_DUPLICATE			5
#define CON_ERR_BADFILESIZE		6
#define CON_ERR_SAVINGFILE			7
#define CON_ERR_READINGFILE		8
#define CON_ERR_FILENOTFOUND		9
#define CON_ERR_MSGTOOLONG			10
#define CON_ERR_SMTPERROR			11
#define CON_ERR_BADPASSPHRASE		12
#define CON_ERR_CANCELRESET		13
#define CON_ERR_BADVARTYPE			14
#define CON_ERR_BADVARVALUE		15
#define CON_ERR_NOVARSPACE			16
#define CON_ERR_VARNOTFOUND		17
#define CON_ERR_STRINGTOOLONG		18
#define CON_ERR_NOTAFILE			19
#define CON_ERR_NOTAVAR				20
#define CON_ERR_COMMANDTOOLONG	21
#define CON_ERR_BADIPADDRESS		22
#define CON_ERR_INVALIDPASSWORD	23
#define CON_ERR_BADIFACE			24
#define CON_ERR_BADNETWORKPARAM	25

#define CON_STANDARD_ERRORS \
	{ CON_ERR_TIMEOUT, "Timed out." },\
	{ CON_ERR_BADCOMMAND, "Unknown command." },\
	{ CON_ERR_BADPARAMETER, "Bad or missing parameter." },\
	{ CON_ERR_NAMETOOLONG, "Filename too long." },\
	{ CON_ERR_DUPLICATE, "Duplicate object found." },\
	{ CON_ERR_BADFILESIZE, "Bad file size." },\
	{ CON_ERR_SAVINGFILE, "Error saving file." },\
	{ CON_ERR_READINGFILE, "Error reading file." },\
	{ CON_ERR_FILENOTFOUND, "File not found." },\
	{ CON_ERR_MSGTOOLONG, "Mail message too long." },\
	{ CON_ERR_SMTPERROR, "SMTP server error." },\
	{ CON_ERR_BADPASSPHRASE, "Passphrases do not match!" },\
	{ CON_ERR_CANCELRESET, "Reset cancelled." },\
	{ CON_ERR_BADVARTYPE, "Bad variable type." },\
	{ CON_ERR_BADVARVALUE, "Bad variable value." },\
	{ CON_ERR_NOVARSPACE, "Out of variable space." },\
	{ CON_ERR_VARNOTFOUND, "Variable not found." },\
	{ CON_ERR_STRINGTOOLONG, "String too long." },\
	{ CON_ERR_NOTAFILE, "Not a file." },\
	{ CON_ERR_NOTAVAR, "Not a variable." },\
	{ CON_ERR_COMMANDTOOLONG, "Command too long." },\
	{ CON_ERR_BADIPADDRESS, "Bad IP address." },\
	{ CON_ERR_INVALIDPASSWORD, "Invalid Password.", },\
	{ CON_ERR_BADIFACE, "Bad interface name." },\
	{ CON_ERR_BADNETWORKPARAM, "Error setting network parameter." }


#define CON_DISABLED			(-1)
#define CON_INIT				0
#define CON_LOGIN				1
#define CON_READY				2
#define CON_GETCOMMAND		3
#define CON_PARSECOMMAND	4
#define CON_EXECCOMMAND		5

/*** EndHeader */

/*** BeginHeader console_init */

/* START FUNCTION DESCRIPTION ********************************************
console_init                           <ZCONSOLE.LIB>

SYNTAX: int console_init(void);

KEYWORDS:		tcpip

DESCRIPTION:	Initializes console data structures.  This function must
					be called before console_tick() is called for the first
					time.  This function also loads the configuration
					information from the file system.

RETURN VALUE:	0		successfully initialized console
					1		no configuration information found
					< 0	indicates an error loading the configuration
					      data.  -1 indicates an error reading the 1st
					      set of information, -2 the 2nd set, and so on.

SEE ALSO:		console_tick

END DESCRIPTION **********************************************************/

int console_init(void);
/*** EndHeader */

_zconsole_nodebug
int console_init(void)
{
	auto int i;
	auto int retval;

	#GLOBAL_INIT
	{
		__con_user_timeout = NULL;
		__con_user_idle = NULL;
		console_login.name[0]=console_login.password[0]='\0';
	}
	for (i = 0; i < NUM_CONSOLES; i++) {
		__constate[i].console_number = i;
		__constate[i].conio = &console_io[i];
		__constate[i].state = CON_INIT;
		console_backup_info.param[i] = console_io[i].param;
		__constate[i].echo = 1;
	}
#ifndef CON_BACKUP_USER_BLOCK
#ifndef CON_NO_FS_SUPPORT
	__con_backupversion = 1;
	__con_nextbackupfile = CON_BACKUP_FILE1;
#endif
#endif
	__con_varbuflen = 0;
#ifdef HTTP_MAXSERVERS
	__con_varbuf = xalloc(CON_VAR_BUF_SIZE);
#endif
#ifdef SMTP_SERVER
	__con_mailbuf = xalloc(CON_MAIL_BUF_SIZE);
	__con_mailbuf_lock = -1;
	smtp_setserver(SMTP_SERVER);
	strcpy(console_smtp_backup_info.mail_from, "user@somewhere.com");
#endif

	retval = con_load_backup();
	con_backup_reserve();

	return retval;
}

/*** BeginHeader console_tick */

/* START FUNCTION DESCRIPTION ********************************************
console_tick                           <ZCONSOLE.LIB>

SYNTAX: void console_tick(void);

KEYWORDS:		tcpip

DESCRIPTION:	Allows the console to process requests.  This function
					should be called periodically.

RETURN VALUE:	none

SEE ALSO:		console_init

END DESCRIPTION **********************************************************/

void console_tick(void);
/*** EndHeader */

_zconsole_nodebug
void console_tick(void)
{
	auto int i;

	for (i = 0; i < NUM_CONSOLES; i++) {
		__conexec(&__constate[i]);
	}
}

/*** BeginHeader console_enable */

/* START FUNCTION DESCRIPTION ********************************************
console_enable                   <ZCONSOLE.LIB>

SYNTAX: void console_enable(int which);

KEYWORDS:		tcpip

DESCRIPTION:	Enable processing for the which'th console in the
					console_io[] array.

PARAMETER1:		which console to enable.

RETURN VALUE:	none

SEE ALSO:		console_init, console_disable

END DESCRIPTION **********************************************************/

_zconsole_nodebug
void console_enable(int which);
/*** EndHeader */

void console_enable(int which)
{
	if(which>=0 && which<NUM_CONSOLES)
		__constate[which].state=CON_INIT;
}

/*** BeginHeader console_disable */
void console_disable(int which);

/* START FUNCTION DESCRIPTION ********************************************
console_disable                   <ZCONSOLE.LIB>

SYNTAX: void console_disable(int which);

KEYWORDS:		tcpip

DESCRIPTION:	Disable processing for the which'th console in the
					console_io[] array.

PARAMETER1:		which console to disable.

RETURN VALUE:	none

SEE ALSO:		console_init, console_enable

END DESCRIPTION **********************************************************/
/*** EndHeader */

_zconsole_nodebug
void console_disable(int which)
{
	if(which>=0 && which<NUM_CONSOLES) {
		if(__constate[which].state!=CON_INIT)
			__constate[which].conio->close(console_backup_info.param[which]);

		__constate[which].state=CON_DISABLED;
	}
}

/*** BeginHeader con_set_user_timeout */

/* START FUNCTION DESCRIPTION ********************************************
con_set_user_timeout                   <ZCONSOLE.LIB>

SYNTAX: void con_set_user_timeout(void (*funcptr)());

KEYWORDS:		tcpip

DESCRIPTION:	Sets a user-defined function that will be called when a
					timeout event has occured.  The user-defined function
					should take an argument of type ConsoleState* .

PARAMETER1:		pointer to user function

RETURN VALUE:	none

SEE ALSO:		con_set_user_idle

END DESCRIPTION **********************************************************/

void con_set_user_timeout(void (*funcptr)());
/*** EndHeader */

_zconsole_nodebug
void con_set_user_timeout(void (*funcptr)())
{
	__con_user_timeout = funcptr;
}

/*** BeginHeader con_set_user_idle */

/* START FUNCTION DESCRIPTION ********************************************
con_set_user_idle                      <ZCONSOLE.LIB>

SYNTAX: void con_set_user_idle(void (*funcptr)());

KEYWORDS:		tcpip

DESCRIPTION:	Sets a user-defined function that will be called when
					the console (for a particular I/O channel) is idle.  The
					user-defined function should take an argument of type
					ConsoleState* .

PARAMETER1:		pointer to user function

RETURN VALUE:	none

SEE ALSO:		con_set_user_timeout

END DESCRIPTION **********************************************************/

void con_set_user_idle(void (*funcptr)());
/*** EndHeader */

_zconsole_nodebug
void con_set_user_idle(void (*funcptr)())
{
	__con_user_idle = funcptr;
}

/*** BeginHeader con_reset_io */

/* START FUNCTION DESCRIPTION ********************************************
con_reset_io                           <ZCONSOLE.LIB>

SYNTAX: void con_reset_io(void);

KEYWORDS:		tcpip

DESCRIPTION:	Resets all I/O channels in the console.  This is useful,
					for instance, when a change has been made to the
					configuration that could affect the operation of one or
					more I/O channels.

RETURN VALUE:	none

SEE ALSO:

END DESCRIPTION **********************************************************/

void con_reset_io(void);
/*** EndHeader */

_zconsole_nodebug
void con_reset_io(void)
{
	auto int i;

	for (i = 0; i < NUM_CONSOLES; i++) {
		__constate[i].conio->close(console_backup_info.param[i]);
		__constate[i].conio->open(console_backup_info.param[i]);
	}
}

/*** BeginHeader __conexec */
void __conexec(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
void __conexec(ConsoleState* state)
{
	auto int retval;

	if(state->state==CON_DISABLED)
		return;

	if (state->state != state->laststate) {
		state->laststate = state->state;
		state->timeout = con_set_timeout(CON_TIMEOUT);
	}

	if (con_chk_timeout(state->timeout)) {
		if (state->state <= CON_GETCOMMAND) {
			// never mind--we're waiting for a command or initializing
			state->timeout = con_set_timeout(CON_TIMEOUT);
		} else {
			if (state->console_number == __con_mailbuf_lock) {
				__con_mailbuf_lock = -1;
			}
			if (__con_user_timeout != NULL) {
				__con_user_timeout(state);
			}
			__con_error(state, CON_ERR_TIMEOUT);
			state->state = CON_READY;
		}
	}

	/* run the driver, if necessary */
	if((NULL != state->conio->tick) && (state->state != CON_INIT)) {
		if(state->conio->tick()) {
			/* not connected - reset everything */
			state->state = CON_INIT;
		}
	}

	switch (state->state) {
	case CON_INIT:
		state->conio->open(console_backup_info.param[state->console_number]);
		state->conio->puts(CON_INIT_MESSAGE);
		state->substate=0;

		if(console_login.name[0])
			state->state = CON_LOGIN;
		else
			state->state = CON_READY;
		break;

	case CON_LOGIN:
		switch(__con_login(state)) {
			case -1:
				state->substate=0;
				break;
			case 1:
				state->state=CON_READY;
				break;
			case 0:
				break;
		}
		break;

	case CON_READY:
		state->command[0] = '\0';
		state->cmdptr = state->command;
		state->sawesc = 0;
		state->state = CON_GETCOMMAND;
		break;

	case CON_GETCOMMAND:
		switch(__con_inputstring(state)) {
			case -1:
				state->state=CON_READY;
				break;
			case 1:
				state->state=CON_PARSECOMMAND;
				break;
			case 0:
				break;
		}
		break;

	case CON_PARSECOMMAND:
		state->numparams = __con_nullify(state->command);
		if (state->numparams == 0) {
			state->state = CON_READY;
			break;
		}
		state->cmdspec = __con_parsecmd(state->command, state->numparams,
		                                &(state->commandparams));
		if ((state->cmdspec != NULL) && (state->cmdspec->cmdfunc != NULL)) {
			state->substate = 0;
			state->state = CON_EXECCOMMAND;
		} else {
			__con_error(state, CON_ERR_BADCOMMAND);
			state->state = CON_READY;
		}
		break;

	case CON_EXECCOMMAND:
		retval = state->cmdspec->cmdfunc(state);
		if (retval == 1) {
			state->conio->puts("OK\r\n");
			state->state = CON_READY;
		} else if (retval == -1) {
			__con_error(state, state->error);
			state->state = CON_READY;
		}
		break;

	default:
		/* ERROR! -- Should _never_ get here */
		state->state = CON_INIT;
		break;
	}
}

/*** BeginHeader __con_inputstring */
int __con_inputstring(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int __con_inputstring(ConsoleState* state)
{
	auto int retval;
	auto char data;

	if (__con_user_timeout != NULL) {
		__con_user_timeout(state);
	}
	if (state->conio->rdUsed() > 0) {
		retval = state->conio->read(&data, 1, 0uL);
		if(0 == retval)
			return 0;
		state->timeout = con_set_timeout(CON_TIMEOUT);
	} else {
		return 0;
	}

	if (state->sawesc > 0) {
		// Skip past escaped characters (starting with 1B, such as cursor
		// movement keys)
		state->sawesc--;
		return 0;
	} else if ((data == '\r') || ((data == '\n') && (state->sawcr == 0))) {
		if (data == '\r') {
			state->sawcr = 1;
		}
		if (state->echo) {
			state->conio->puts("\r\n");
		}
		if ((state->cmdptr - state->command) < CON_CMD_SIZE) {
			*(state->cmdptr) = '\0';
		} else {
			__con_error(state, CON_ERR_COMMANDTOOLONG);
			return -1;
		}

		// find the command
		return 1;
	} else if ((data == '\n') && (state->sawcr == 1)) {
		state->sawcr = 0;
		return 0;
	} else if (state->sawcr == 1) {
		state->sawcr = 0;
	}
	// Handle the character we just got
	if ((data == 0x08) || (data == 0x7f)) {
		// Backspace character
		if (state->cmdptr > state->command) {
			state->cmdptr--;
			if (state->echo) {
				state->conio->puts("\x08 \x08");
			}
		}
	} else if (data == 0x1B) {
		// Escape character--skip past the next two characters
		state->sawesc = 2;
	} else if (data == 0x15) {
		// CTRL-U -- linefeed and clear the command buffer
		if (state->echo) {
			state->conio->puts("\r\n");
		}
		state->cmdptr = state->command;
		state->command[0] = '\0';
	} else if (data >= 0x20) {
		if ((state->cmdptr - state->command) < CON_CMD_SIZE) {
			*(state->cmdptr) = data;
		}
		state->cmdptr++;
		if (state->echo) {
			state->conio->write(&data, 1);
		}
	}
	return 0;
}

/*** BeginHeader __con_error */
void __con_error(ConsoleState* state, unsigned int errcode);
/*** EndHeader */

_zconsole_nodebug
void __con_error(ConsoleState* state, unsigned int errcode)
{
	auto int i;
	auto char errstr[7];

	for (i = 0; i < (sizeof(console_errors) / sizeof(ConsoleError)); i++) {
		if (console_errors[i].code == errcode) {
			state->conio->puts("ERROR ");
			sprintf(errstr, "%04u  ", errcode);
			state->conio->puts(errstr);
			state->conio->puts(console_errors[i].message);
			state->conio->puts("\r\n");
			break;
		}
	}
	#ifdef CON_DEBUG
	if (i == (sizeof(console_errors) / sizeof(ConsoleError))) {
		printf("Nonexistent error code!\n");
	}
	#endif
}

/*** BeginHeader __con_nullify */
int __con_nullify(char* buffer);
/*** EndHeader */

_zconsole_nodebug
int __con_nullify(char* buffer) {
	auto int i;
	auto int looking;
	auto int quoted;
	auto int num;

	looking = 0;
	quoted = 0;
	num = 0;
	for (i = 0; buffer[i] != '\0'; i++) {
		if ((looking == 0) && (buffer[i] == ' ')) {
			buffer[i] = '\0';
		} else if ((looking == 0) && (buffer[i] != ' ')) {
			//
			// If we have an empty string fill it with
			// a 0xff.  This character will be ignored
			// when retrieving the parameter.
			//
			if (buffer[i] == '\"') {
				if (buffer[i+1] == '\"') {
					buffer[i++]=0xff;
					buffer[i]='\0';
				} else {
					quoted = 1;
					buffer[i] = '\0';
				}
			}
			looking = 1;
			num++;
		} else if ((looking == 1) && (quoted == 0) &&
		           ((buffer[i] == ' ') || (buffer[i] == '\"'))) {
		   if (buffer[i] == '\"') {
		   	// Quote in an unquoted param; start new param
		   	quoted = 1;
		   	looking = 1;
		   	num++;
		   } else {
		   	looking = 0;
		   }
			buffer[i] = '\0';
		} else if ((looking == 1) && (quoted == 1) && (buffer[i] == '\"')) {
			// Ending a quoted param
			looking = 0;
			quoted = 0;
			buffer[i] = '\0';
		}
		// Handle escaped characters
		if (buffer[i] == '\\') {
			strcpy(&buffer[i], &buffer[i+1]);
		}
	}
	return num;
}

/*** BeginHeader __con_login */
int __con_login(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int __con_login(ConsoleState* state)
{
	switch(state->substate) {
		case 0:		/* initialize... write login prompt */
			if(console_login.name[0]=='\0') // no password just return
				return 1;

			state->conio->puts("login:  ");
			state->substate=1;

			state->command[0] = '\0';
			state->cmdptr = state->command;
			state->sawesc = 0;
			break;

		case 1: // login
			switch(__con_inputstring(state)) {
				case -1:
					return -1;

				case 1:
					if(strcmp(console_login.name,state->command)==0) {
						if(console_login.password[0]=='\0') {
							return 1;

						} else {
							state->conio->puts("password:  ");

							state->command[0] = '\0';
							state->cmdptr = state->command;
							state->sawesc = 0;
							state->echo = 0;
							state->substate=2;
						}
					} else {
						state->conio->puts("password:  ");
						state->command[0] = '\0';
						state->cmdptr = state->command;
						state->sawesc = 0;
						state->echo = 0;
						state->substate=3;
					}
					break;

				case 0:
					break;
			}
			break;

		case 2: // password
			switch(__con_inputstring(state)) {
				case -1:
					state->echo = 1;
					return -1;

				case 1:
					state->echo = 1;

					if(strcmp(console_login.password,state->command)==0) {
						state->conio->puts("\r\nPassword Accepted\r\n");

						state->command[0] = '\0';
						state->cmdptr = state->command;
						state->sawesc = 0;
						return 1;
					} else {
						state->conio->puts("\r\nInvalid Password\r\n");
						*((long*)state->cmddata)=MS_TIMER+1000;
						state->substate=4;
					}
					break;

				case 0:
					break;
			}
			break;

		case 3: // invalid login get password
			switch(__con_inputstring(state)) {
				case -1:
					state->echo = 1;
					return -1;

				case 1:
					state->echo = 1;
					state->conio->puts("\r\nInvalid Password\r\n");
					*((long*)state->cmddata)=MS_TIMER+1000;
					state->substate=4;
					break;

				case 0:
					break;
			}
			break;

		case 4: // timeout bad password
			if((long)(*((long*)state->cmddata)-MS_TIMER)<=0) {
				state->substate=0;
			}
			break;
	}
	return 0;
}

/*** BeginHeader __con_parsecmd */
ConsoleCommand* __con_parsecmd(char* command, int numparams,
                               int* commandparams);
/*** EndHeader */

_zconsole_nodebug
ConsoleCommand* __con_parsecmd(char* command, int numparams,
                               int* commandparams)
{
	auto int i;
	auto int part;
	auto char* ptr;
	auto char* endptr;
	auto int n;
	auto int match;
	auto int match_parts;
	auto int still_matches;
	auto char* cmdptr;

	match = -1;
	match_parts = -1;
	for (i = 0; i < (sizeof(console_commands) / sizeof(ConsoleCommand)); i++) {
		part = 0;
		ptr = console_commands[i].command;
		still_matches = 1;
		do {
			endptr = memchr(ptr, ' ', strlen(ptr));
			if (endptr != NULL) {
				n = endptr - ptr;
			} else {
				n = strlen(ptr);
			}
			if (part < numparams) {
				cmdptr = con_getparam(command, part);
				if ((strlen(cmdptr) == n) &&
				    (strncmpi(ptr, cmdptr, strlen(cmdptr)) == 0)) {
					// It matches
					part++;
					ptr += n + 1;
				} else {
					// It doesn't match
					still_matches = 0;
				}
			} else {
				if (numparams == 0) {
					// Check for "" command (mainly for the help system)
					if ((*console_commands[i].command) != '\0') {
						still_matches = 0;
					}
				} else {
					// Trivially doesn't match, since the number of parameters on the
					// command line is less than the parts of the command we're testing
					still_matches = 0;
				}
			}
		} while ((endptr != NULL) && (still_matches == 1));
		if ((still_matches == 1) && (part > match_parts)) {
			match = i;
			match_parts = part;
		}
	}
	if (match != -1) {
		if (commandparams != NULL) {
			*commandparams = numparams - match_parts;
		}
		return (&console_commands[match]);
	} else {
		return NULL;
	}
}

/*** BeginHeader con_getparam */
char* con_getparam(char* buffer, int num);
/*** EndHeader */

_zconsole_nodebug
char* con_getparam(char* buffer, int num)
{
	auto int numnulls;
	auto int i;

	numnulls = 0;
	i = 0;
	// Skip past initial nulls
	while (buffer[i] == '\0') {
		i++;
	}
	// Skip to the right parameter
	while (numnulls < num) {
		if ((buffer[i] == '\0') && (buffer[i+1] != '\0')) {
			numnulls++;
		}
		i++;
	}

	//
	// Ignore the 0xff which is added when
	// we hit an empty string.
	//
	if(buffer[i]==0xff)
		i++;

	return (&buffer[i]);
}

/*** BeginHeader con_help */
int con_help(ConsoleState* state);
/*** EndHeader */

struct __con_help_data {
	ConsoleCommand* command;
	long total;
	long location;
	int offset;
};

_zconsole_nodebug
int con_help(ConsoleState* state)
{
	auto char* param;
	auto struct __con_help_data* helpdata;
	auto int temp;
	auto int numbytes;

	helpdata = (struct __con_help_data*)(state->cmddata);
	switch (state->substate) {
	case 0:
		if (state->commandparams > 0) {
			temp = state->numparams - state->commandparams;
			helpdata->command = __con_parsecmd(con_getparam(state->command, temp),
			                                   state->numparams - temp, NULL);
		} else {
			helpdata->command = __con_parsecmd("", 0, NULL);
		}
		if ((helpdata->command != NULL) && (helpdata->command->helptext != 0)) {
#ifdef CON_HELP_VERSION
			if (helpdata->command->command[0] == '\0') {
				state->conio->puts(CON_VERSION_MESSAGE);
			}
#endif
			xmem2root(&helpdata->total, helpdata->command->helptext, 4);
			helpdata->offset = 0;
			state->substate++;
			return 0;
		} else {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
	case 1:
		if (helpdata->offset < helpdata->total) {
			numbytes = ((helpdata->total - helpdata->offset) > CON_BUF_SIZE)?
			           CON_BUF_SIZE : (int)(helpdata->total - helpdata->offset);
			temp = state->conio->wrFree();
			if(numbytes > temp)
				numbytes = temp;
			if (numbytes > 0) {
				xmem2root(state->buffer,
				          helpdata->command->helptext+4 + helpdata->offset,
				          numbytes);
				helpdata->offset += state->conio->write(state->buffer, numbytes);
			}
		} else {
			state->substate++;
		}
		return 0;
	case 2:
		if (state->conio->wrUsed() == 0) {
			return 1;
		} else {
			return 0;
		}
	}
}

/*** BeginHeader con_echo */
int con_echo(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_echo(ConsoleState* state)
{
	auto int temp;
	temp = state->numparams - state->commandparams;
	if ((state->commandparams == 1) &&
	    (strcmpi(con_getparam(state->command, temp), "on") == 0)) {
		state->echo = 1;
		con_backup();
		return 1;
	} else if ((state->commandparams == 1) &&
	           (strcmpi(con_getparam(state->command, temp), "off") == 0)) {
		state->echo = 0;
		con_backup();
		return 1;
	} else {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
}

/*** BeginHeader con_set_param */
int con_set_param(ConsoleState* state);
/*** EndHeader */

struct __con_set_param_data {
	long param;
};

_zconsole_nodebug
int con_set_param(ConsoleState* state)
{
	auto struct __con_set_param_data* setparamdata;
	auto char* tailptr;

	setparamdata = (struct __con_set_param_data*)(state->cmddata);

	switch (state->substate) {
	case 0:
		if (state->commandparams != 1) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		setparamdata->param = strtol(con_getparam(state->command,
		                                          state->numparams - state->commandparams),
		                             &tailptr, 10);
		if (*tailptr != NULL) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		state->conio->puts("I/O parameter set to: ");
		sprintf(state->buffer, "%ld\r\n", setparamdata->param);
		state->conio->puts(state->buffer);
		state->substate++;
		return 0;
	case 1:
		if (state->conio->wrUsed() == 0) {
			state->conio->close(console_backup_info.param[state->console_number]);
			console_backup_info.param[state->console_number] = setparamdata->param;
			state->conio->open(console_backup_info.param[state->console_number]);
			con_backup();
			return 1;
		}
		return 0;
	}
}

/*** BeginHeader __con_convert_iface_to_num */
int __con_convert_iface_to_num(char* iface);
/*** EndHeader */

int __con_convert_iface_to_num(char* name)
{
	auto int number;
	auto int iface;

	// Get the sub-interface number (for example, the 1 in ETH1)
	number = name[strlen(name)-1] - '0';
	if (number < 0 || number > 9) {
		return -1;
	}

	// Calculate the interface number
	if (strncmpi(name, "ETH", 3) == 0 && strlen(name) == 4) {
		if (number < 2) {
			iface = number;
		}
		else {
			return -1;
		}
	}
	else if (strncmpi(name, "PPPOE", 5) == 0 && strlen(name) == 6) {
		if (number < 2) {
			iface = number + 2;
		}
		else {
			return -1;
		}
	}
	else if (strncmpi(name, "PPP", 3) == 0 && strlen(name) == 4) {
		if (number < 4) {
			iface = number + 4;
		}
		else {
			return -1;
		}
	}
	else {
		return -1;
	}

	// Check if this interface number is valid
	if (!is_valid_iface(iface)) {
		return -1;
	}

	return iface;
}

/*** BeginHeader __con_convert_num_to_iface */
char* __con_convert_num_to_iface(int iface);
/*** EndHeader */

char* __con_convert_num_to_iface(int iface)
{
	switch (iface) {
	case 0:
		return "ETH0";
	case 1:
		return "ETH1";
	case 2:
		return "PPPOE0";
	case 3:
		return "PPPOE1";
	case 4:
		return "PPP0";
	case 5:
		return "PPP1";
	case 6:
		return "PPP2";
	case 7:
		return "PPP3";
	}
	return NULL;
}

/*** BeginHeader __con_set_ip_misc */
int __con_set_ip_misc(ConsoleState* state, int set, char* msg, int use_iface,
                      int reset_io);
/*** EndHeader */

_zconsole_nodebug
int __con_set_ip_misc(ConsoleState* state, int set, char* msg, int use_iface,
                      int reset_io)
{
	auto int iface;
	auto longword ip;
	auto int temp;

	if (state->commandparams < 1 || ((use_iface && state->commandparams > 2) ||
	                                 (!use_iface && state->commandparams > 1))) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;
	ip = resolve(con_getparam(state->command, temp));
	if (ip == 0) {
		state->error = CON_ERR_BADIPADDRESS;
		return -1;
	}
	if (use_iface && state->commandparams == 2) {
		iface = __con_convert_iface_to_num(con_getparam(state->command, temp + 1));
		if (iface < 0) {
			state->error = CON_ERR_BADIFACE;
			return -1;
		}
	}
	else if (use_iface) {
		iface = IF_DEFAULT;
	}
	else {
		iface = IF_ANY;
	}

	if (ifconfig(iface, set, ip, IFS_END)) {
		state->error = CON_ERR_BADNETWORKPARAM;
		return -1;
	}
	state->conio->puts(msg);
	state->conio->puts(inet_ntoa(state->buffer, ip));
	state->conio->puts("\r\n");
	con_backup();
	if (reset_io) {
		_abort_socks(NETERR_IFDOWN, iface);
	}
	return 1;
}

/*** BeginHeader con_set_ip */
int con_set_ip(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ip(ConsoleState* state)
{
	return __con_set_ip_misc(state, IFS_IPADDR, "IP address set to: ", 1, 1);
}

/*** BeginHeader con_set_netmask */
int con_set_netmask(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_netmask(ConsoleState* state)
{
	return __con_set_ip_misc(state, IFS_NETMASK, "Netmask set to: ", 1, 0);
}

/*** BeginHeader con_set_gateway */
int con_set_gateway(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_gateway(ConsoleState* state)
{
	return __con_set_ip_misc(state, IFS_ROUTER_SET, "Gateway set to: ", 0, 0);
}

/*** BeginHeader con_set_nameserver */
int con_set_nameserver(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_nameserver(ConsoleState* state)
{
	return __con_set_ip_misc(state, IFS_NAMESERVER_SET, "Name server set to: ", 0, 0);
}

/*** BeginHeader con_add_nameserver */
int con_add_nameserver(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_add_nameserver(ConsoleState* state)
{
	return __con_set_ip_misc(state, IFS_NAMESERVER_ADD, "Name server added: ", 0, 0);
}

/*** BeginHeader con_set_tcpip_debug */
int con_set_tcpip_debug(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_tcpip_debug(ConsoleState* state)
{
	auto char* tailptr;
	auto int level;

	if (state->commandparams != 1) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	level = (int)strtol(con_getparam(state->command,
	                                 state->numparams - state->commandparams),
	               &tailptr, 10);
	if (*tailptr != NULL) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	if (ifconfig(IF_ANY, IFS_DEBUG, level, IFS_END)) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	state->conio->puts("TCP/IP Debugging Level set to: ");
	sprintf(state->buffer, "%d\r\n", level);
	state->conio->puts(state->buffer);

	return 1;
}

/*** BeginHeader con_set_mail_server */
int con_set_mail_server(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_mail_server(ConsoleState* state)
{
	auto int temp;

	if (state->commandparams != 1) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;
	if (resolve(con_getparam(state->command, temp)) == 0) {
		state->error = CON_ERR_BADIPADDRESS;
		return -1;
	}
	if ((strlen(con_getparam(state->command, temp)) >= CON_MAIL_SERV_SIZE) ||
	    (smtp_setserver(con_getparam(state->command, temp)) != SMTP_OK)) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	strcpy(console_smtp_backup_info.mail_serv,
	       con_getparam(state->command, temp));
	state->conio->puts("Mail Server set to: ");
	state->conio->puts(smtp_state.server);
	state->conio->puts("\r\n");
	con_backup();
	return 1;
}

/*** BeginHeader con_set_mail_from */
int con_set_mail_from(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_mail_from(ConsoleState* state)
{
	auto int temp;

	temp = state->numparams - state->commandparams;
	if ((state->commandparams != 1) ||
	    (strlen(con_getparam(state->command, temp)) >= CON_MAIL_SERV_SIZE)) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	strcpy(console_smtp_backup_info.mail_from,
	       con_getparam(state->command, temp));
	state->conio->puts("Mail From set to: ");
	state->conio->puts(console_smtp_backup_info.mail_from);
	state->conio->puts("\r\n");
	con_backup();
	return 1;
}

/*** BeginHeader __con_set_net_misc */
int __con_set_net_misc(ConsoleState* state, int set, char* msg, int param,
                       int is_long, int reset_io);
/*** EndHeader */

_zconsole_nodebug
int __con_set_net_misc(ConsoleState* state, int set, char* msg, int param,
                       int is_long, int reset_io)
{
	auto int iface;
	auto longword setting;
	auto int temp;

	if ((param && (state->commandparams < 1 || state->commandparams > 2)) ||
	    (!param && (state->commandparams > 1))) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;
	if (param) {
		setting = strtol(con_getparam(state->command, temp), NULL, 10);
	}
	if ((param && state->commandparams == 2) ||
	    (!param && state->commandparams == 1)) {
		iface = __con_convert_iface_to_num(con_getparam(state->command, temp + param));
		if (iface < 0) {
			state->error = CON_ERR_BADIFACE;
			return -1;
		}
	}
	else {
		iface = IF_DEFAULT;
	}

	if ((param && ((is_long && ifconfig(iface, set, setting, IFS_END)) ||
	               (!is_long && ifconfig(iface, set, (word)setting, IFS_END)))) ||
	    (!param && ifconfig(iface, set, IFS_END))) {
		state->error = CON_ERR_BADNETWORKPARAM;
		return -1;
	}
	state->conio->puts(msg);
	if (param) {
		sprintf(state->buffer, "%lu\r\n", setting);
		state->conio->puts(state->buffer);
	}
	con_backup();
	if (reset_io) {
		_abort_socks(NETERR_IFDOWN, iface);
	}
	return 1;
}

/*** BeginHeader con_set_mtu */
int con_set_mtu(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_mtu(ConsoleState* state)
{
	return __con_set_net_misc(state, IFS_MTU, "Interface MTU set to: ", 1, 0, 0);
}

/*** BeginHeader con_set_icmp_config_reset */
int con_set_icmp_config_reset(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_icmp_config_reset(ConsoleState* state)
{
	return __con_set_net_misc(state, IFS_ICMP_CONFIG_RESET,
	                          "Further configuration via ping is now allowed.\r\n",
	                          0, 0, 0);
}

/*** BeginHeader __con_set_net_misc_onoff */
int __con_set_net_misc_onoff(ConsoleState* state, int set, char* msg,
                             char* on, char* off, int reset_io);
/*** EndHeader */

_zconsole_nodebug
int __con_set_net_misc_onoff(ConsoleState* state, int set, char* msg,
                             char* on, char* off, int reset_io)
{
	auto int iface;
	auto char* onoff;
	auto int setting;
	auto int temp;

	if (state->commandparams < 1 || state->commandparams > 2) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;

	onoff = con_getparam(state->command, temp);
	if (strcmpi(onoff, on) == 0) {
		setting = 1;
	}
	else if (strcmpi(onoff, off) == 0) {
		setting = 0;
	}
	else {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}

	if (state->commandparams == 2) {
		iface = __con_convert_iface_to_num(con_getparam(state->command, temp + 1));
		if (iface < 0) {
			state->error = CON_ERR_BADIFACE;
			return -1;
		}
	}
	else {
		iface = IF_DEFAULT;
	}

	if (ifconfig(iface, set, setting, IFS_END)) {
		state->error = CON_ERR_BADNETWORKPARAM;
		return -1;
	}
	state->conio->puts(msg);
	if (setting) {
		state->conio->puts(on);
	}
	else {
		state->conio->puts(off);
	}
	state->conio->puts("\r\n");
	con_backup();
	if (reset_io) {
		_abort_socks(NETERR_IFDOWN, iface);
	}
	return 1;
}

/*** BeginHeader con_set_dhcp */
int con_set_dhcp(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_dhcp(ConsoleState* state)
{
	auto int iface;
	auto char* onoff;
	auto int setting;
	auto int temp;
	auto int retval;
	auto long ip;

	if (state->commandparams < 1 || state->commandparams > 2) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;

	onoff = con_getparam(state->command, temp);
	if (strcmpi(onoff, "on") == 0) {
		setting = 1;
	}
	else if (strcmpi(onoff, "off") == 0) {
		setting = 0;
	}
	else {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}

	if (state->commandparams == 2) {
		iface = __con_convert_iface_to_num(con_getparam(state->command, temp + 1));
		if (iface < 0) {
			state->error = CON_ERR_BADIFACE;
			return -1;
		}
	}
	else {
		iface = IF_DEFAULT;
	}

	if (ifconfig(iface, IFS_DOWN, IFS_DHCP, setting, IFS_UP, IFS_END)) {
		state->error = CON_ERR_BADNETWORKPARAM;
		return -1;
	}
	state->conio->puts("DHCP set to: ");
	if (setting) {
		state->conio->puts("on");
	}
	else {
		state->conio->puts("off");
	}
	state->conio->puts("\r\n");

	if (!setting) {
		ifconfig(iface, IFG_DHCP_FB_IPADDR, &ip, IFS_END);
		ifconfig(iface, IFS_IPADDR, ip, IFS_UP, IFS_END);
	}
	con_backup();

	return 1;
}

/*** BeginHeader con_set_icmp_config */
int con_set_icmp_config(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_icmp_config(ConsoleState* state)
{
	return __con_set_net_misc_onoff(state, IFS_ICMP_CONFIG, "Ping config set to: ", "on", "off", 0);
}

/*** BeginHeader con_set_ppp_speed */
int con_set_ppp_speed(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_speed(ConsoleState* state)
{
	return __con_set_net_misc(state, IFS_PPP_SPEED, "PPP speed set to: ", 1, 1, 1);
}

/*** BeginHeader con_set_ppp_acceptip */
int con_set_ppp_acceptip(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_acceptip(ConsoleState* state)
{
	return __con_set_net_misc_onoff(state, IFS_PPP_ACCEPTIP, "PPP accept IP set to: ", "on", "off", 0);
}

/*** BeginHeader con_set_ppp_remoteip */
int con_set_ppp_remoteip(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_remoteip(ConsoleState* state)
{
	return __con_set_ip_misc(state, IFS_PPP_REMOTEIP, "PPP remote IP set to: ", 1, 0);
}

/*** BeginHeader con_set_ppp_acceptdns */
int con_set_ppp_acceptdns(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_acceptdns(ConsoleState* state)
{
	return __con_set_net_misc_onoff(state, IFS_PPP_ACCEPTDNS, "PPP accept DNS set to: ", "on", "off", 0);
}

/*** BeginHeader con_set_ppp_flowcontrol */
int con_set_ppp_flowcontrol(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_flowcontrol(ConsoleState* state)
{
	return __con_set_net_misc_onoff(state, IFS_PPP_FLOWCONTROL, "PPP hardware flow control set to: ", "on", "off", 0);
}

/*** BeginHeader con_set_ppp_usemodem */
int con_set_ppp_usemodem(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_usemodem(ConsoleState* state)
{
	return __con_set_net_misc_onoff(state, IFS_PPP_USEMODEM, "PPP modem dialout string set to: ", "on", "off", 0);
}

/*** BeginHeader __con_set_ppp_auth */
int __con_set_ppp_auth(ConsoleState* state, int set, char* msg);
/*** EndHeader */

_zconsole_nodebug
int __con_set_ppp_auth(ConsoleState* state, int set, char* msg)
{
	auto int iface;
	auto int temp;
	auto char* username;
	auto char* password;

	if (state->commandparams < 2 || state->commandparams > 3) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;
	username = con_getparam(state->command, temp);
	password = con_getparam(state->command, temp + 1);
	if (state->commandparams == 3) {
		iface = __con_convert_iface_to_num(con_getparam(state->command, temp + 2));
		if (iface < 0) {
			state->error = CON_ERR_BADIFACE;
			return -1;
		}
	}
	else {
		iface = IF_DEFAULT;
	}

	if (ifconfig(iface, set, username, password, IFS_END)) {
		state->error = CON_ERR_BADNETWORKPARAM;
		return -1;
	}
	state->conio->puts(msg);
	state->conio->puts("\r\nUsername: ");
	state->conio->puts(username);
	state->conio->puts("\r\nPassword: ");
	state->conio->puts(password);
	state->conio->puts("\r\n");
	con_backup();
	return 1;
}

/*** BeginHeader con_set_ppp_remoteauth */
int con_set_ppp_remoteauth(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_remoteauth(ConsoleState* state)
{
	return __con_set_ppp_auth(state, IFS_PPP_REMOTEAUTH, "PPP remote authentication parameters set to:");
}

/*** BeginHeader con_set_ppp_localauth */
int con_set_ppp_localauth(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_localauth(ConsoleState* state)
{
	return __con_set_ppp_auth(state, IFS_PPP_LOCALAUTH, "PPP local authentication parameters set to:");
}

/*** BeginHeader con_set_ppp_remotedns */
int con_set_ppp_remotedns(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_remotedns(ConsoleState* state)
{
	auto int iface;
	auto int temp;
	auto longword dns1;
	auto longword dns2;
	auto int have_iface;
	auto int have_dns2;

	if (state->commandparams < 1 || state->commandparams > 3) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;
	have_iface = 0;
	have_dns2 = 0;
	dns2 = 0;
	iface = __con_convert_iface_to_num(con_getparam(state->command,
	                                                temp + state->commandparams - 1));
	if (iface < 0 && state->commandparams == 3) {
		state->error = CON_ERR_BADIFACE;
		return -1;
	}
	else if (iface >= 0) {
		have_iface = 1;
	}
	else {
		iface = IF_DEFAULT;
	}
	if (have_iface && state->commandparams == 1) {
		state->error = CON_ERR_BADIPADDRESS;
		return -1;
	}
	dns1 = inet_addr(con_getparam(state->command, temp));
	if ((have_iface && state->commandparams == 3) ||
	    (!have_iface && state->commandparams == 2)) {
		dns2 = inet_addr(con_getparam(state->command, temp + 1));
		have_dns2 = 1;
	}
	if (dns1 == 0 || (have_dns2 && dns2 == 0)) {
		state->error = CON_ERR_BADIPADDRESS;
		return -1;
	}
	if (ifconfig(iface, IFS_PPP_REMOTEDNS, dns1, dns2, IFS_END)) {
		state->error = CON_ERR_BADNETWORKPARAM;
		return -1;
	}
	state->conio->puts("PPP remote DNS servers set to: ");
	state->conio->puts(inet_ntoa(state->buffer, dns1));
	state->conio->puts(", ");
	if (have_dns2) {
		state->conio->puts(inet_ntoa(state->buffer, dns2));
	}
	else {
		state->conio->puts("none");
	}
	state->conio->puts("\r\n");
	con_backup();
	return 1;
}

/*** BeginHeader __con_set_ppp_string */
int __con_set_ppp_string(ConsoleState* state, int set, char* msg);
/*** EndHeader */

_zconsole_nodebug
int __con_set_ppp_string(ConsoleState* state, int set, char* msg)
{
	auto int iface;
	auto int temp;

	if (state->commandparams < 1 || state->commandparams > 2) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;
	if (state->commandparams == 2) {
		iface = __con_convert_iface_to_num(con_getparam(state->command, temp + 1));
		if (iface < 0) {
			state->error = CON_ERR_BADIFACE;
			return -1;
		}
	}
	else {
		iface = IF_DEFAULT;
	}

	if (ifconfig(iface, set, con_getparam(state->command, temp), IFS_END)) {
		state->error = CON_ERR_BADNETWORKPARAM;
		return -1;
	}
	state->conio->puts(msg);
	con_backup();

	return 1;
}

/*** BeginHeader con_set_ppp_sendexpect */
int con_set_ppp_sendexpect(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_sendexpect(ConsoleState* state)
{
	return __con_set_ppp_string(state, IFS_PPP_SENDEXPECT,
	                            "Modem send expect script changed.\r\n");
}

/*** BeginHeader con_set_ppp_hangup */
int con_set_ppp_hangup(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_hangup(ConsoleState* state)
{
	return __con_set_ppp_string(state, IFS_PPP_HANGUP,
	                            "Modem hangup string changed.\r\n");
}

/*** BeginHeader con_set_ppp_modemescape */
int con_set_ppp_modemescape(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_ppp_modemescape(ConsoleState* state)
{
	return __con_set_net_misc_onoff(state, IFS_PPP_MODEMESCAPE, "PPP modem escape sequence set to: ", "on", "off", 0);
}

/*** BeginHeader con_set_iface */
int con_set_iface(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_set_iface(ConsoleState* state)
{
	auto int iface;
	auto int temp;
	auto char* commandstr;
	auto int command;
	auto int retval;
	auto int up;

	if (state->commandparams < 1 || state->commandparams > 2) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	temp = state->numparams - state->commandparams;
	commandstr = con_getparam(state->command, temp);
	if (state->commandparams == 2) {
		iface = __con_convert_iface_to_num(con_getparam(state->command, temp + 1));
		if (iface < 0) {
			state->error = CON_ERR_BADIFACE;
			return -1;
		}
	}
	else {
		iface = IF_DEFAULT;
	}

	if (strcmpi(commandstr, "up") == 0) {
		command = IFS_UP;
	}
	else if (strcmpi(commandstr, "down") == 0) {
		command = IFS_DOWN;
	}
	else {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	if (ifconfig(iface, command, IFS_END)) {
		state->error = CON_ERR_BADNETWORKPARAM;
		return -1;
	}
	state->conio->puts(__con_convert_num_to_iface(iface));
	state->conio->puts(" is being brought ");
	state->conio->puts((command == IFS_UP)?"up\r\n":"down\r\n");
	return 1;
}

/*** BeginHeader con_show */
int con_show(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_show(ConsoleState* state)
{
	auto int i;
	auto ATHandle ath;
	auto longword ip;

	if (state->conio->wrUsed() != 0) {
		return 0;
	}
	switch (state->substate) {
	case 0:
		state->conio->puts("Current configuration:");
		state->conio->puts("\r\n\tI/O Parameter:\t");
		sprintf(state->buffer, "%ld", console_backup_info.param[state->console_number]);
		state->conio->puts(state->buffer);
		break;
	case 1:
		state->conio->puts("\r\n\tIP Address:\t");
		ifconfig(IF_DEFAULT, IFG_IPADDR, &ip, IFS_END);
		state->conio->puts(inet_ntoa(state->buffer, ip));
		break;
	case 2:
		state->conio->puts("\r\n\tNetmask:\t");
		ifconfig(IF_DEFAULT, IFG_NETMASK, &ip, IFS_END);
		state->conio->puts(inet_ntoa(state->buffer, ip));
		break;
	case 3:
		state->conio->puts("\r\n\tGateway:\t");
		ifconfig(IF_DEFAULT, IFG_ROUTER_DEFAULT, &ip, IFS_END);
		state->conio->puts(inet_ntoa(state->buffer, ip));
		break;
	case 4:
		state->conio->puts("\r\n\tName Server:\t");
		state->conio->puts(inet_ntoa(state->buffer, servlist_first(&_dns_server_table,0,NULL)));
		break;
	case 5:
		state->conio->puts("\r\n\tMail Server:\t");
		state->conio->puts(smtp_state.server);
		break;
	case 6:
		state->conio->puts("\r\n\tMail From:\t");
		state->conio->puts(console_smtp_backup_info.mail_from);
		state->conio->puts("\r\n");
		return 1;
	}
	state->substate++;
	return 0;
}

/*** BeginHeader con_show_multi */
int con_show_multi(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_show_multi(ConsoleState* state)
{
	auto int i;
	auto ATHandle ath;
	auto longword ip;
	auto longword ip2;
	auto int iface;
	auto word setting;
	auto longword longsetting;
	auto char* string1;
	auto char* string2;

	if (state->conio->wrUsed() != 0) {
		return 0;
	}
	if (state->commandparams == 0) {
		switch (state->substate) {
		case 0:
			state->conio->puts("Current Configuration:");
			state->conio->puts("\r\n\tI/O Parameter:\t");
			sprintf(state->buffer, "%ld", console_backup_info.param[state->console_number]);
			state->conio->puts(state->buffer);
			break;
		case 1:
			state->conio->puts("\r\n\tGateway:\t");
			ifconfig(IF_ANY, IFG_ROUTER_DEFAULT, &ip, IFS_END);
			state->conio->puts(inet_ntoa(state->buffer, ip));
			break;
		case 2:
			state->conio->puts("\r\n\tName Servers:");
         ip = servlist_first(&_dns_server_table,0,NULL);
         for (i = 0; i < _dns_server_table.num; ++i) {
				state->conio->puts("\r\n\t\t");
				state->conio->puts(inet_ntoa(state->buffer, ip));
            ip = servlist_next(&_dns_server_table, ip, 0, NULL);
			}

			break;
		case 3:
			state->conio->puts("\r\n\tMail Server:\t");
			state->conio->puts(smtp_state.server);
			break;
		case 4:
			state->conio->puts("\r\n\tMail From:\t");
			state->conio->puts(console_smtp_backup_info.mail_from);
			break;
		case 5:
			state->conio->puts("\r\n\tInterfaces:\t");
			for (i = 0; i < IF_MAX; i++) {
				if (is_valid_iface(i)) {
					state->conio->puts(__con_convert_num_to_iface(i));
					state->conio->puts(" ");
				}
			}
			state->conio->puts("\r\n");
			return 1;
		}
		state->substate++;
		return 0;
	}
	else if (state->commandparams == 1) {
		iface = __con_convert_iface_to_num(con_getparam(state->command,
		                                                state->numparams - state->commandparams));
		if (iface < 0) {
			state->error = CON_ERR_BADIFACE;
			return -1;
		}
		switch (state->substate) {
		case 0:
			state->conio->puts("Current ");
			state->conio->puts(__con_convert_num_to_iface(iface));
			state->conio->puts(" Configuration:");
			state->conio->puts("\r\n\tStatus:\t\t\t");
			if (ifstatus(iface)) {
				state->conio->puts("up");
			}
			else {
				state->conio->puts("down");
			}
			break;
		case 1:
			state->conio->puts("\r\n\tIP Address:\t\t");
			ifconfig(iface, IFG_IPADDR, &ip, IFS_END);
			state->conio->puts(inet_ntoa(state->buffer, ip));
			break;
		case 2:
			state->conio->puts("\r\n\tNetmask:\t\t");
			ifconfig(iface, IFG_NETMASK, &ip, IFS_END);
			state->conio->puts(inet_ntoa(state->buffer, ip));
			break;
		case 3:
			state->conio->puts("\r\n\tMTU:\t\t\t");
			ifconfig(iface, IFG_MTU, &setting, IFS_END);
			sprintf(state->buffer, "%u", setting);
			state->conio->puts(state->buffer);
			break;
		case 4:
			state->conio->puts("\r\n\tPing Config:\t\t");
			ifconfig(iface, IFG_ICMP_CONFIG, &setting, IFS_END);
			if (setting) {
				state->conio->puts("on");
			}
			else {
				state->conio->puts("off");
			}
			break;
		case 5:
			state->conio->puts("\r\n\tPing Config Done:\t");
			ifconfig(iface, IFG_ICMP_CONFIG_OK, &setting, IFS_END);
			if (setting) {
				state->conio->puts("yes");
			}
			else {
				state->conio->puts("no");
			}
#ifndef USE_DHCP
			state->substate += 2;
			break;
#else
			break;
		case 6:
			if (iface != IF_DEFAULT) {
				state->substate += 2;
				break;
			}
			state->conio->puts("\r\n\tDHCP:\t\t\t");
			ifconfig(iface, IFG_DHCP, &setting, IFS_END);
			if (setting) {
				state->conio->puts("on");
			}
			else {
				state->conio->puts("off");
			}
			break;
		case 7:
			state->conio->puts("\r\n\tDHCP Config Done:\t");
			ifconfig(iface, IFG_DHCP_OK, &setting, IFS_END);
			if (setting) {
				state->conio->puts("yes");
			}
			else {
				state->conio->puts("no");
			}
			break;
#endif
#ifndef USING_PPP
		case 8:
			state->conio->puts("\r\n");
			return 1;
#else
		case 8:
			if (!IF_P2P(iface)) {
				state->conio->puts("\r\n");
				return 1;
			}
			state->conio->puts("\r\n\tPPP Speed:\t\t");
			ifconfig(iface, IFG_PPP_SPEED, &longsetting, IFS_END);
			sprintf(state->buffer, "%lu", longsetting);
			state->conio->puts(state->buffer);
			break;
		case 9:
			state->conio->puts("\r\n\tPPP Accept IP:\t\t");
			ifconfig(iface, IFG_PPP_ACCEPTIP, &setting, IFS_END);
			if (setting) {
				state->conio->puts("on");
			}
			else {
				state->conio->puts("off");
			}
			break;
		case 10:
			state->conio->puts("\r\n\tPPP Remote IP:\t\t");
			ifconfig(iface, IFG_PPP_REMOTEIP, &ip, IFS_END);
			state->conio->puts(inet_ntoa(state->buffer, ip));
			break;
		case 11:
			state->conio->puts("\r\n\tPPP Accept DNS:\t\t");
			ifconfig(iface, IFG_PPP_ACCEPTDNS, &setting, IFS_END);
			if (setting) {
				state->conio->puts("on");
			}
			else {
				state->conio->puts("off");
			}
			break;
		case 12:
			state->conio->puts("\r\n\tPPP Remote DNS:\t\t");
			ifconfig(iface, IFG_PPP_REMOTEDNS, &ip, &ip2, IFS_END);
			if (ip) {
				state->conio->puts(inet_ntoa(state->buffer, ip));
				state->conio->puts(", ");
			}
			else {
				state->conio->puts("none, ");
			}
			if (ip2) {
				state->conio->puts(inet_ntoa(state->buffer, ip2));
			}
			else {
				state->conio->puts("none");
			}
			break;
		case 13:
			state->conio->puts("\r\n\tRemote username:\t");
			ifconfig(iface, IFG_PPP_REMOTEAUTH, &string1, &string2, IFS_END);
			state->conio->puts(string1);
			break;
		case 14:
			state->conio->puts("\r\n\tLocal username:\t\t");
			ifconfig(iface, IFG_PPP_LOCALAUTH, &string1, &string2, IFS_END);
			state->conio->puts(string1);
			break;
		case 15:
			state->conio->puts("\r\n\tPPP Flow Control:\t");
			ifconfig(iface, IFG_PPP_FLOWCONTROL, &setting, IFS_END);
			if (setting) {
				state->conio->puts("on");
			}
			else {
				state->conio->puts("off");
			}
			break;
		case 16:
			state->conio->puts("\r\n\tPPP Send Expect Script:\t");
			ifconfig(iface, IFG_PPP_SENDEXPECT, &string1, IFS_END);
			state->conio->puts(string1);
			break;
		case 17:
			state->conio->puts("\r\n\tPPP Modem Dialout String:\t");
			ifconfig(iface, IFG_PPP_USEMODEM, &setting, IFS_END);
			if (setting) {
				state->conio->puts("on");
			}
			else {
				state->conio->puts("off");
			}
			break;
		case 18:
			state->conio->puts("\r\n\tPPP Modem Escape Sequence:\t");
			ifconfig(iface, IFG_PPP_MODEMESCAPE, &setting, IFS_END);
			if (setting) {
				state->conio->puts("on");
			}
			else {
				state->conio->puts("off");
			}
			break;
		case 19:
			state->conio->puts("\r\n\tPPP Hangup string:\t");
			ifconfig(iface, IFG_PPP_HANGUP, &string1, IFS_END);
			state->conio->puts(string1);
			state->conio->puts("\r\n");
			return 1;
#endif
		}
		state->substate++;
		return 0;
	}
	else {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
}

/*** BeginHeader __con_reset_answer */
int __con_reset_answer(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int __con_reset_answer(ConsoleState* state)
{
	auto char data;

	if (state->conio->rdUsed() > 0) {
		if (state->conio->read(&data, 1, 0uL) == 0) {
			return 0;
		}
		state->timeout = con_set_timeout(CON_TIMEOUT);
	} else {
		return 0;
	}
	if(state->sawcr == 1) {
		state->sawcr = 0;

		if ('\n' == data) {
			/* nothing - drop it */
			data = '\0';
		} else {
			/* character is ok */
		}
	}
	if('\0' == data) {
		/* empty char - drop it */
		return 0;
	} else if(('\r' == data) || ('\n' == data)) {
		/* end of line reached */
		if('\r' == data) {
			state->sawcr = 1;
		}
		if((state->bufferend - state->buffer) < CON_BUF_SIZE) {
			*state->bufferend = '\0';
		}
		state->buffer[CON_BUF_SIZE - 1] = '\0'; /* make sure we end in null */

		return 1;
	} else {
		/* normal character - store it */
		if ((state->bufferend - state->buffer) < CON_BUF_SIZE) {
			state->conio->write(&data, 1);
			*state->bufferend = data;
		}
		state->bufferend++;
	}
	return 0;
}

/*** BeginHeader __con_reset_check */
int __con_reset_check(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int __con_reset_check(ConsoleState* state)
{
	state->conio->puts("\r\n");
	if(1 != strlen(state->buffer)) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	if(('y' != state->buffer[0]) && ('Y' != state->buffer[0])) {
		state->error = CON_ERR_CANCELRESET;
		return -1;
	}
	state->conio->puts("reset!\r\n");
	return 1;
}

/*** BeginHeader con_reset_files */
int con_reset_files(ConsoleState* state);
/*** EndHeader */

#define __CON_RESET_FILES_PROMPT		0
#define __CON_RESET_FILES_ANSWER		1
#define __CON_RESET_FILES_CHECK		2

_zconsole_nodebug
int con_reset_files(ConsoleState* state)
{
	auto int sspec;
	auto long location;

	switch (state->substate) {
	case __CON_RESET_FILES_PROMPT:
		if (state->commandparams != 0) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		state->conio->puts("Are you sure you want to reset the files? (y/n): ");
		state->bufferend = state->buffer;
		state->substate = __CON_RESET_FILES_ANSWER;
		return 0;

	case __CON_RESET_FILES_ANSWER:
		if (__con_reset_answer(state) == 1) {
			state->substate = __CON_RESET_FILES_CHECK;
		}
		return 0;

	case __CON_RESET_FILES_CHECK:
		if (__con_reset_check(state) == -1) {
			return -1;
		}
		sspec = 0;
		while ((sspec = sspec_findnextfile(sspec, SERVER_HTTP)) != -1) {
			if (sspec_gettype(sspec) == SSPEC_FILE) {
				location = sspec_getfileloc(sspec);
				fdelete((FileNumber)location);
				sspec_remove(sspec);
			}
			sspec++;
		}
		con_backup();
		return 1;
	}
}

/*** BeginHeader con_reset_variables */
int con_reset_variables(ConsoleState* state);
/*** EndHeader */

#define __CON_RESET_VARIABLES_PROMPT	0
#define __CON_RESET_VARIABLES_ANSWER	1
#define __CON_RESET_VARIABLES_CHECK		2

_zconsole_nodebug
int con_reset_variables(ConsoleState* state)
{
	auto int sspec;

	switch (state->substate) {
	case __CON_RESET_VARIABLES_PROMPT:
		if (state->commandparams != 0) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		state->conio->puts("Are you sure you want to reset the variables? (y/n): ");
		state->bufferend = state->buffer;
		state->substate = __CON_RESET_VARIABLES_ANSWER;
		return 0;

	case __CON_RESET_VARIABLES_ANSWER:
		if (__con_reset_answer(state) == 1) {
			state->substate = __CON_RESET_VARIABLES_CHECK;
		}
		return 0;

	case __CON_RESET_VARIABLES_CHECK:
		if (__con_reset_check(state) == -1) {
			return -1;
		}
		__con_varbuflen = 0;
		sspec = 0;
		while ((sspec = sspec_findnextfile(sspec, SERVER_HTTP)) != -1) {
			if (sspec_gettype(sspec) == SSPEC_VARIABLE) {
				sspec_remove(sspec);
			}
			sspec++;
		}
		con_backup();
		return 1;
	}
}

/*** BeginHeader con_put */
int con_put(ConsoleState* state);
/*** EndHeader con_put */

#define __CON_PUT_BEGIN		0
#define __CON_PUT_READING1 1
#define __CON_PUT_READING2	2
#define __CON_PUT_BIN1		3
#define __CON_PUT_BIN2		4

struct __con_put_data {
	long total;
	long filesize;
};

_zconsole_nodebug
int con_put(ConsoleState* state)
{
	auto struct __con_put_data* putdata;
	auto char* name;
	auto char data;
	auto char* ptr;
	auto char* num;
	auto int len;
	auto int numread;
	auto int temp;
#ifdef __FS2_LIB
	auto FSLXnum meta_lx;
	auto FSLXnum data_lx;
#endif

	putdata = (struct __con_put_data*)(state->cmddata);
	temp = state->numparams - state->commandparams;

	switch (state->substate) {
	case __CON_PUT_BEGIN:
		if ((state->commandparams == 1) || (state->commandparams == 2)) {
			name = con_getparam(state->command, temp);
			if (strlen(name) >= SSPEC_MAXNAME) {
				// Not enough room to put the page name
				state->error = CON_ERR_NAMETOOLONG;
				return -1;
			}
			if (sspec_findname(name, SERVER_HTTP) != -1) {
				state->error = CON_ERR_DUPLICATE;
				return -1;
			}
			state->bufferend = state->buffer;
#ifdef __FS2_LIB
			meta_lx = fs_get_lx(1);
			data_lx = fs_get_lx(0);
#endif
			if (state->commandparams == 1) {
#ifdef __FS2_LIB
				fs_set_lx(__con_files_lx, __con_files_lx);
#endif
				if ((state->filenum = fcreate_unused(&state->file)) == 0) {
#ifdef __FS2_LIB
					fs_set_lx(meta_lx, data_lx);
#endif
					state->error = CON_ERR_SAVINGFILE;
					return -1;
				}
#ifdef __FS2_LIB
					fs_set_lx(meta_lx, data_lx);
#endif
				state->substate = __CON_PUT_READING1;
			} else {
				putdata->filesize = strtol(con_getparam(state->command, temp + 1),
				                           &ptr, 10);
				if ((*ptr == '\0') && (putdata->filesize < LONG_MAX) &&
				    (putdata->filesize > LONG_MIN)) {
#ifdef __FS2_LIB
					fs_set_lx(__con_files_lx, __con_files_lx);
#endif
					if ((state->filenum = fcreate_unused(&state->file)) == 0) {
#ifdef __FS2_LIB
						fs_set_lx(meta_lx, data_lx);
#endif
						state->error = CON_ERR_SAVINGFILE;
						return -1;
					}
#ifdef __FS2_LIB
					fs_set_lx(meta_lx, data_lx);
#endif
					putdata->total = 0;
					// Special timeout here?
					state->substate = __CON_PUT_BIN1;
				} else {
					state->error = CON_ERR_BADFILESIZE;
					return -1;
				}
			}
		} else {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		return 0;

	case __CON_PUT_READING1:
		if (state->conio->read(&data, 1, 0uL) == 1) {
			state->timeout = con_set_timeout(CON_TIMEOUT);
			if (!((state->sawcr == 1) && (data == '\n'))) {
				*(state->bufferend) = data;
				state->bufferend++;
				if (state->echo) {
					state->conio->write(&data, 1);
				}
            state->sawcr = 0;
            if (data == '\r') {
            	state->sawcr = 1;
            }
			}
         else {
         	state->sawcr = 0;
         }
			state->substate = __CON_PUT_READING2;
		}
		return 0;

	case __CON_PUT_READING2:
		if (state->conio->read(&data, 1, 0uL) == 1) {
			state->timeout = con_set_timeout(CON_TIMEOUT);
		} else {
			return 0;
		}
		if ((data == 0x04) || (data == 0x1A)) {
			// Done getting the page (CTRL-D or CTRL-Z)
			if ((state->bufferend - state->buffer) > 0) {
				if (fwrite(&state->file, state->buffer, state->bufferend - state->buffer) <
				    (state->bufferend - state->buffer)) {
					fclose(&state->file);
					fdelete(state->filenum);
					state->error = CON_ERR_SAVINGFILE;
					return -1;
				}
			}
			fclose(&state->file);
			name = con_getparam(state->command, temp);
			if (sspec_addfsfile(name, state->filenum, SERVER_HTTP) >= 0) {
				state->filenum = 0;
				con_backup();
				return 1;
			} else {
				fdelete(state->filenum);
				state->filenum = 0;
				state->error = CON_ERR_SAVINGFILE;
				return -1;
			}
		} else if (data == 0x03) {
			// Bail out (CTRL-C)
			fclose(&state->file);
			fdelete(state->filenum);
			state->filenum = 0;
			return 1;
		} else if ((data == '\r') || ((data == '\n') && (state->sawcr == 0))) {
			*(state->bufferend) = data;
			state->bufferend++;
			if (data == '\r') {
				state->sawcr = 1;
			}
			if (state->echo) {
				state->conio->puts("\r\n");
			}
		} else if ((data == '\n') && (state->sawcr == 1)) {
			*(state->bufferend) = data;
			state->bufferend++;
			state->sawcr = 0;
		} else {
			*(state->bufferend) = data;
			state->bufferend++;
			if (state->echo) {
				state->conio->write(&data, 1);
			}
         state->sawcr = 0;
		}
		if ((state->bufferend - state->buffer) == CON_BUF_SIZE) {
			if (fwrite(&state->file, state->buffer, CON_BUF_SIZE) < CON_BUF_SIZE) {
				fclose(&state->file);
				fdelete(state->filenum);
				state->error = CON_ERR_SAVINGFILE;
				return -1;
			}
			state->bufferend = state->buffer;
		}
		return 0;

	case __CON_PUT_BIN1:
		if (state->conio->read(&data, 1, 0uL) == 1) {
			state->timeout = con_set_timeout(CON_TIMEOUT);
			if (!((state->sawcr == 1) && (data == '\n'))) {
				*state->bufferend = data;
				state->bufferend++;
				putdata->total++;
			}
         state->sawcr = 0;
			state->substate = __CON_PUT_BIN2;
		}
		return 0;

	case __CON_PUT_BIN2:
		if (state->conio->rdUsed > 0) {
			state->timeout = con_set_timeout(CON_TIMEOUT);
			len = state->bufferend - state->buffer;
			numread = ((CON_BUF_SIZE - (int)len) <
			           (putdata->filesize - putdata->total))?
			          (CON_BUF_SIZE - (int)len):
			          (int)(putdata->filesize - putdata->total);
			numread = state->conio->read(state->bufferend, numread, 0uL);
			if ((len + numread) == CON_BUF_SIZE) {
				if (fwrite(&state->file, state->buffer, CON_BUF_SIZE) < CON_BUF_SIZE) {
					fclose(&state->file);
					fdelete(state->filenum);
					state->error = CON_ERR_SAVINGFILE;
					return -1;
				}
				state->bufferend = state->buffer;
			} else {
				state->bufferend += numread;
			}
			putdata->total += numread;

			if (putdata->total >= putdata->filesize) {
				if (state->bufferend > state->buffer) {
					if (fwrite(&state->file, state->buffer, state->bufferend - state->buffer) !=
					    (state->bufferend - state->buffer)) {
						fclose(&state->file);
						fdelete(state->filenum);
						state->error = CON_ERR_SAVINGFILE;
						return -1;
					}
				}
				fclose(&state->file);
				if (sspec_addfsfile(con_getparam(state->command, temp),
				                    state->filenum, SERVER_HTTP) >= 0) {
					state->filenum = 0;
					con_backup();
					return 1;
				} else {
					fdelete(state->filenum);
					state->filenum = 0;
					state->error = CON_ERR_SAVINGFILE;
					return -1;
				}
			}
		}
		return 0;
	}
}

/*** BeginHeader con_get */
int con_get(ConsoleState* state);
/*** EndHeader con_get */

#define __CON_GET_BEGIN		0
#define __CON_GET_WRITING	1
#define __CON_GET_BIN		2

struct __con_get_data {
	long total;
	long filesize;
	int getsawcr;
};

_zconsole_nodebug
int con_get(ConsoleState* state)
{
	auto struct __con_get_data* getdata;
	auto char* name;
	auto int bytes;
	auto char data;
	auto char* ptr;
	auto int temp;

	getdata = (struct __con_get_data*)(state->cmddata);
	temp = state->numparams - state->commandparams;

	switch (state->substate) {
	case __CON_GET_BEGIN:
		if ((state->commandparams == 1) || (state->commandparams == 2)) {
			name = con_getparam(state->command, temp);
			if (strlen(name) >= SSPEC_MAXNAME) {
				// Not enough room to put the page name
				state->error = CON_ERR_NAMETOOLONG;
				return -1;
			}
			if ((state->spec = sspec_findname(name, SERVER_HTTP)) == -1) {
				// Didn't find the file
				state->error = CON_ERR_READINGFILE;
				return -1;
			}
			if (sspec_gettype(state->spec) != SSPEC_FILE) {
				// Not a file
				state->error = CON_ERR_NOTAFILE;
				return -1;
			}
			getdata->total = 0;
			getdata->getsawcr = 0;
			if (state->commandparams == 1) {
				state->substate = __CON_GET_WRITING;
			} else {
				getdata->filesize = strtol(con_getparam(state->command, temp + 1),
				                           &ptr, 10);
				if ((*ptr == '\0') && (getdata->filesize < LONG_MAX) &&
				    (getdata->filesize > LONG_MIN)) {
					getdata->total = 0;
					sprintf(state->buffer, "%ld\r\n", sspec_getlength(state->spec));
					state->conio->puts("LENGTH ");
					state->conio->puts(state->buffer);
					state->substate = __CON_GET_BIN;
				} else {
					state->error = CON_ERR_BADFILESIZE;
					return -1;
				}
			}
		} else {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		return 0;

	case __CON_GET_WRITING:
		if (!state->echo) {
			bytes = sspec_readfile(state->spec, state->buffer, getdata->total,
			                       CON_BUF_SIZE);
			if (bytes <= 0) {
				state->error = CON_ERR_READINGFILE;
				return -1;
			}
			bytes = state->conio->write(state->buffer, bytes);
			getdata->total += bytes;
			if (bytes > 0) {
				state->timeout = con_set_timeout(CON_TIMEOUT);
			}
			if (getdata->total >= sspec_getlength(state->spec)) {
				return 1;
			}
		} else {
			if (sspec_readfile(state->spec, &data, getdata->total, 1) == 1) {
				if ((data == '\r') || ((data == '\n') && (getdata->getsawcr == 0))) {
					state->conio->puts("\r\n");
					if (data == '\r') {
						getdata->getsawcr = 1;
					}
				} else if ((data == '\n') && (getdata->getsawcr == 1)) {
					getdata->getsawcr = 0;
				} else {
					state->conio->write(&data, 1);
				}
				getdata->total++;
			} else {
				state->error = CON_ERR_READINGFILE;
				return -1;
			}
			if (getdata->total == sspec_getlength(state->spec)) {
				return 1;
			}
		}
		return 0;

	case __CON_GET_BIN:
		bytes = sspec_readfile(state->spec, state->buffer, getdata->total,
		                       CON_BUF_SIZE);
		if (bytes <= 0) {
			state->error = CON_ERR_READINGFILE;
			return -1;
		}
		if ((getdata->total + bytes) <= getdata->filesize) {
			bytes = state->conio->write(state->buffer, bytes);
		} else if (getdata->total < getdata->filesize) {
			bytes = state->conio->write(state->buffer,
			         (int)(getdata->filesize - getdata->total));
		} else {
			return 1;
		}
		getdata->total += bytes;
		if (getdata->total >= sspec_getlength(state->spec)) {
			return 1;
		}
		return 0;
	}
}

/*** BeginHeader con_delete */
int con_delete(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_delete(ConsoleState* state)
{
	auto int spec;
	auto long location;

	if (state->commandparams != 1) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	spec = sspec_findname(con_getparam(state->command,
	                                   state->numparams - state->commandparams),
	                      SERVER_HTTP);
	if (spec >= 0) {
		if (sspec_getfiletype(spec) == SSPEC_FSFILE) {
			location = sspec_getfileloc(spec);
			if (location == -1) {
				state->error = CON_ERR_FILENOTFOUND;
				return -1;
			}
			fdelete((FileNumber)location);
			sspec_remove(spec);
		} else {
			// Not a flash file
			state->error = CON_ERR_FILENOTFOUND;
			return -1;
		}
	} else {
		// File not found
		state->error = CON_ERR_FILENOTFOUND;
		return -1;
	}
	con_backup();
	return 1;
}

/*** BeginHeader con_list_files */
int con_list_files(ConsoleState* state);
/*** EndHeader */

struct __con_list_files_data {
	char* ptr;
	int bytes;
};

_zconsole_nodebug
int con_list_files(ConsoleState* state)
{
	auto struct __con_list_files_data* listfilesdata;
	auto char* name;
	auto long filesize;
	auto int byteswritten;

	listfilesdata = (struct __con_list_files_data*)(state->cmddata);

	switch (state->substate) {
	case 0:
		if (state->commandparams != 0) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		listfilesdata->ptr = state->buffer;
		listfilesdata->bytes = 0;
		state->spec = 0;
		state->substate++;
		return 0;

	case 1:
		if (listfilesdata->bytes == 0) {
			if ((state->spec = sspec_findnextfile(state->spec,
		   	                                   SERVER_HTTP)) != -1) {
				name = sspec_getname(state->spec);
				if ((name != NULL) && (sspec_gettype(state->spec) == SSPEC_FILE)) {
					filesize = sspec_getlength(state->spec);
					sprintf(state->buffer, "%8d  ", filesize);
					strcat(state->buffer, name);
					strcat(state->buffer, "\r\n");
					listfilesdata->bytes = strlen(state->buffer);
					listfilesdata->ptr = state->buffer;
				}
				state->spec++;
			} else {
				return 1;
			}
		} else {
			// Have some data to flush
			byteswritten = state->conio->write(listfilesdata->ptr,
			                                   listfilesdata->bytes);
			listfilesdata->bytes -= byteswritten;
			listfilesdata->ptr += byteswritten;
			return 0;
		}
		return 0;
	}
}

/*** BeginHeader con_list_variables */
int con_list_variables(ConsoleState* state);
/*** EndHeader */

struct __con_list_vars_data {
	char* ptr;
	int bytes;
};

_zconsole_nodebug
int con_list_variables(ConsoleState* state)
{
	auto struct __con_list_vars_data* listvarsdata;
	auto char* name;
	auto word varkind;
	auto int byteswritten;

	listvarsdata = (struct __con_list_vars_data*)(state->cmddata);

	switch (state->substate) {
	case 0:
		if (state->commandparams != 0) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		listvarsdata->ptr = state->buffer;
		listvarsdata->bytes = 0;
		state->spec = 0;
		state->substate++;
		return 0;

	case 1:
		if (listvarsdata->bytes == 0) {
			if ((state->spec = sspec_findnextfile(state->spec,
		   	                                   SERVER_HTTP)) != -1) {
				name = sspec_getname(state->spec);
				if ((name != NULL) && (sspec_gettype(state->spec) == SSPEC_VARIABLE)) {
					strcpy(state->buffer, name);
					varkind = sspec_getvarkind((int)state->spec);
					switch (varkind) {
					case INT8:
						strcat(state->buffer, " INT8");
						break;
					case INT16:
						strcat(state->buffer, " INT16");
						break;
					case INT32:
						strcat(state->buffer, " INT32");
						break;
					case FLOAT32:
						strcat(state->buffer, " FLOAT32");
						break;
					case PTR16:
						strcat(state->buffer, " STRING ");
						sprintf(&state->buffer[strlen(state->buffer)], "%d",
						        console_http_backup_info.varstrlen[(int)state->spec] - 1);
						break;
					}
					strcat(state->buffer, "\r\n");
					listvarsdata->bytes = strlen(state->buffer);
					listvarsdata->ptr = state->buffer;
				}
				state->spec++;
			} else {
				return 1;
			}
		} else {
			// Have some data to flush
			byteswritten = state->conio->write(listvarsdata->ptr,
			                                   listvarsdata->bytes);
			listvarsdata->bytes -= byteswritten;
			listvarsdata->ptr += byteswritten;
			return 0;
		}
		return 0;
	}
}

/*** BeginHeader con_createv */
int con_createv(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_createv(ConsoleState* state)
{
	auto char* ptr;
	auto long templong;
	auto int tempint;
	auto int tempchar;
	auto float tempfloat;
	auto char* tailptr;
	auto int retval;
	auto int temp;

	temp = state->numparams - state->commandparams;

	if ((state->commandparams != 4) && (state->commandparams != 5)) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	if (sspec_findname(con_getparam(state->command, temp), SERVER_HTTP) != -1) {
		state->error = CON_ERR_DUPLICATE;
		return -1;
	}
	// Get the type of variable
	ptr = con_getparam(state->command, temp + 1);
	if (strcmpi(ptr, "INT16") == 0) {
		// Check number of parameters
		if (state->commandparams != 4) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		// Check for space in our variable buffer
		if ((__con_varbuflen + 2) > CON_VAR_BUF_SIZE) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		}
		templong = strtol(con_getparam(state->command, temp + 3), &tailptr, 10);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		if ((templong > INT_MAX) || (templong < INT_MIN)) {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		} else {
			tempint = (int)templong;
		}
		root2xmem(__con_varbuf + __con_varbuflen, &tempint, 2);
		retval = sspec_addxmemvar(con_getparam(state->command, temp),
		                          __con_varbuf + __con_varbuflen, INT16,
		                          con_getparam(state->command, temp + 2),
		                          SERVER_HTTP);
		if (retval == -1) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		} else {
			__con_varbuflen += 2;
		}
	} else if (strcmpi(ptr, "INT8") == 0) {
		// Check number of parameters
		if (state->commandparams != 4) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		// Check for space in our variable buffer
		if ((__con_varbuflen + 1) > CON_VAR_BUF_SIZE) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		}
		templong = strtol(con_getparam(state->command, temp + 3), &tailptr, 10);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		if ((templong > CHAR_MAX) || (templong < 0)) {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		} else {
			tempchar = (char)templong;
		}
		root2xmem(__con_varbuf + __con_varbuflen, &tempchar, 1);
		retval = sspec_addxmemvar(con_getparam(state->command, temp),
		                          __con_varbuf + __con_varbuflen, INT8,
		                          con_getparam(state->command, temp + 2),
		                          SERVER_HTTP);
		if (retval == -1) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		} else {
			__con_varbuflen += 1;
		}
	} else if (strcmpi(ptr, "INT32") == 0) {
		// Check number of parameters
		if (state->commandparams != 4) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		// Check for space in our variable buffer
		if ((__con_varbuflen + 4) > CON_VAR_BUF_SIZE) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		}
		templong = strtol(con_getparam(state->command, temp + 3), &tailptr, 10);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		if ((templong >= LONG_MAX) || (templong <= LONG_MIN)) {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		root2xmem(__con_varbuf + __con_varbuflen, &templong, 4);
		retval = sspec_addxmemvar(con_getparam(state->command, temp),
		                          __con_varbuf + __con_varbuflen, INT32,
		                          con_getparam(state->command, temp + 2),
		                          SERVER_HTTP);
		if (retval == -1) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		} else {
			__con_varbuflen += 4;
		}
	} else if (strcmpi(ptr, "FLOAT32") == 0) {
		// Check number of parameters
		if (state->commandparams != 4){
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		// Check for space in our variable buffer
		if ((__con_varbuflen + 4) > CON_VAR_BUF_SIZE) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		}
		tempfloat = strtod(con_getparam(state->command, temp + 3), &tailptr);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		root2xmem(__con_varbuf + __con_varbuflen, &tempfloat, 4);
		retval = sspec_addxmemvar(con_getparam(state->command, temp),
		                          __con_varbuf + __con_varbuflen, FLOAT32,
		                          con_getparam(state->command, temp + 2),
		                          SERVER_HTTP);
		if (retval == -1) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		} else {
			__con_varbuflen += 4;
		}
	} else if (strcmpi(ptr, "STRING") == 0) {
		// Check number of parameters
		if (state->commandparams != 5) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		templong = strtol(con_getparam(state->command, temp + 4), &tailptr, 10);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		if ((templong >= (LONG_MAX - 1)) || (templong <= 0)) {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		templong += 1;		// Add 1 for the null terminator
		if ((__con_varbuflen + templong) > CON_VAR_BUF_SIZE) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		}
		if (strlen(con_getparam(state->command, temp + 3)) > templong) {
			state->error = CON_ERR_STRINGTOOLONG;
			return -1;
		}
		root2xmem(__con_varbuf + __con_varbuflen,
		          con_getparam(state->command, temp + 3),
		          strlen(con_getparam(state->command, temp + 3)) + 1);
		retval = sspec_addxmemvar(con_getparam(state->command, temp),
		                          __con_varbuf + __con_varbuflen,
		                          PTR16,
		                          con_getparam(state->command, temp + 2),
		                          SERVER_HTTP);
		if (retval == -1) {
			state->error = CON_ERR_NOVARSPACE;
			return -1;
		}
		console_http_backup_info.varstrlen[retval] = (unsigned int)templong;
		__con_varbuflen += templong;
	} else {
		state->error = CON_ERR_BADVARTYPE;
		return -1;
	}
	con_backup();
	return 1;
}

/*** BeginHeader con_getv */
int con_getv(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_getv(ConsoleState* state)
{
	int retval;

	if (state->commandparams != 1) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	retval = sspec_findname(con_getparam(state->command,
	                                     state->numparams - state->commandparams),
	                        SERVER_HTTP);
	if (retval == -1) {
		state->error = CON_ERR_VARNOTFOUND;
		return -1;
	}
	if (sspec_gettype(retval) != SSPEC_VARIABLE) {
		state->error = CON_ERR_NOTAVAR;
		return -1;
	}
	sspec_readvariable(retval, state->buffer);
	state->conio->puts(state->buffer);
	state->conio->puts("\r\n");
	return 1;
}

/*** BeginHeader con_putv */
int con_putv(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_putv(ConsoleState* state)
{
	auto int spec;
	auto word varkind;
	auto long templong;
	auto int tempint;
	auto char tempchar;
	auto float tempfloat;
	auto char* tailptr;
	auto int temp;

	temp = state->numparams - state->commandparams;

	if (state->commandparams != 2) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}
	spec = sspec_findname(con_getparam(state->command, temp), SERVER_HTTP);
	if (spec == -1) {
		state->error = CON_ERR_VARNOTFOUND;
		return -1;
	}
	if (sspec_gettype(spec) != SSPEC_VARIABLE) {
		state->error = CON_ERR_NOTAVAR;
		return -1;
	}
	varkind = sspec_getvarkind(spec);
	if (varkind == INT8) {
		templong = strtol(con_getparam(state->command, temp + 1), &tailptr, 10);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		if ((templong > CHAR_MAX) || (templong < 0)) {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		} else {
			tempchar = (char)templong;
		}
		root2xmem(sspec_getxvaraddr(spec), &tempchar, 1);
	} else if (varkind == INT16) {
		templong = strtol(con_getparam(state->command, temp + 1), &tailptr, 10);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		if ((templong > INT_MAX) || (templong < INT_MIN)) {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		} else {
			tempint = (int)templong;
		}
		root2xmem(sspec_getxvaraddr(spec), &tempint, 2);
	} else if (varkind == INT32) {
		templong = strtol(con_getparam(state->command, temp + 1), &tailptr, 10);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		if ((templong >= LONG_MAX) || (templong <= LONG_MIN)) {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		root2xmem(sspec_getxvaraddr(spec), &templong, 4);
	} else if (varkind == FLOAT32) {
		tempfloat = strtod(con_getparam(state->command, temp + 1), &tailptr);
		if (*tailptr != '\0') {
			state->error = CON_ERR_BADVARVALUE;
			return -1;
		}
		root2xmem(sspec_getxvaraddr(spec), &tempfloat, 4);
	} else if (varkind == PTR16) {
		if ((strlen(con_getparam(state->command, temp + 1)) + 1) >
		       console_http_backup_info.varstrlen[spec]) {
			state->error = CON_ERR_STRINGTOOLONG;
			return -1;
		}
		root2xmem(sspec_getxvaraddr(spec),
		          con_getparam(state->command, temp + 1),
		          strlen(con_getparam(state->command, temp + 1)) + 1);
	} else {
		state->error = CON_ERR_BADVARTYPE;
		return -1;
	}
	return 1;
}

/*** BeginHeader con_mail */
int con_mail(ConsoleState* state);
/*** EndHeader */

#define __CON_MAIL_BEGIN				0
#define __CON_MAIL_READING_SUBJECT	1
#define __CON_MAIL_READING_BODY		2
#define __CON_MAIL_SENDING				3

struct __con_mail_data {
	long bufptr;
};

_zconsole_nodebug
int con_mail(ConsoleState* state)
{
	auto struct __con_mail_data* maildata;
	auto char data;

	maildata = (struct __con_mail_data*)(state->cmddata);
	switch (state->substate) {
	case __CON_MAIL_BEGIN:
		if (state->commandparams != 1) {
			state->error = CON_ERR_BADPARAMETER;
			return -1;
		}
		if (__con_mailbuf_lock == -1) {
			__con_mailbuf_lock = state->console_number;
			maildata->bufptr = __con_mailbuf;
			state->bufferend = state->buffer;
			state->substate = __CON_MAIL_READING_SUBJECT;
		}
		return 0;

	case __CON_MAIL_READING_SUBJECT:
		if (state->conio->rdUsed() > 0) {
			if (state->conio->read(&data, 1, 0uL) == 0) {
				return 0;
			}
			state->timeout = con_set_timeout(CON_TIMEOUT);
		} else {
			return 0;
		}
		if ((data == 0x04) || (data == 0x1A)) {
			// Subject only--body not submitted
			if ((state->bufferend - state->buffer) >= (CON_BUF_SIZE - 1)) {
				__con_mailbuf_lock = -1;
				state->error = CON_ERR_MSGTOOLONG;
				return -1;
			}
			*state->bufferend = '\0';
			state->substate = __CON_MAIL_SENDING;
			return 0;
		} else if (data == 0x03) {
			// Bail out (CTRL-C)
			__con_mailbuf_lock = -1;
			return 1;
		}
		if ((data == '\r') || ((data == '\n') && (state->sawcr == 0))) {
			if (data == '\r') {
				state->sawcr = 1;
			}
			*state->bufferend = '\0';
			if (state->echo) {
				state->conio->puts("\r\n");
			}
			state->substate = __CON_MAIL_READING_BODY;
			return 0;
		} else if ((data == '\n') && (state->sawcr == 1)) {
			state->sawcr = 0;
			return 0;
		} else {
			if (state->echo) {
				state->conio->write(&data, 1);
			}
		}
		if ((state->bufferend - state->buffer) < CON_BUF_SIZE) {
			*state->bufferend = data;
		}
		state->bufferend++;
		return 0;

	case __CON_MAIL_READING_BODY:
		if (state->conio->rdUsed() > 0) {
			if (state->conio->read(&data, 1, 0uL) == 0) {
				return 0;
			}
			state->timeout = con_set_timeout(CON_TIMEOUT);
		} else {
			return 0;
		}
		if ((data == 0x04) || (data == 0x1A)) {
			if ((maildata->bufptr - __con_mailbuf) >= (CON_MAIL_BUF_SIZE - 1)) {
				__con_mailbuf_lock = -1;
				state->error = CON_ERR_MSGTOOLONG;
				return -1;
			}
			smtp_sendmailxmem(con_getparam(state->command,
			                               state->numparams - state->commandparams),
			                  console_smtp_backup_info.mail_from,
			                  state->buffer,
			                  __con_mailbuf,
			                  (int)(maildata->bufptr - __con_mailbuf));
			state->substate = __CON_MAIL_SENDING;
			return 0;
		} else if (data == 0x03) {
			// Bail out (CTRL-C)
			__con_mailbuf_lock = -1;
			return 1;
		}
		if ((data == '\r') || ((data == '\n') && (state->sawcr == 0))) {
			if (data == '\r') {
				state->sawcr = 1;
				// Put \r\n into the message
				if ((maildata->bufptr - __con_mailbuf) < CON_MAIL_BUF_SIZE) {
					root2xmem(maildata->bufptr, &data, 1);
				}
				maildata->bufptr++;
				data = '\n';
			}
			if (state->echo) {
				state->conio->puts("\r\n");
			}
		} else if ((data == '\n') && (state->sawcr == 1)) {
			state->sawcr = 0;
			return 0;
		} else {
			if (state->sawcr == 1) {
				state->sawcr = 0;
			}
			if (state->echo) {
				state->conio->write(&data, 1);
			}
		}
		if ((maildata->bufptr - __con_mailbuf) < CON_MAIL_BUF_SIZE) {
			root2xmem(maildata->bufptr, &data, 1);
		}
		maildata->bufptr++;
		return 0;

	case __CON_MAIL_SENDING:
		if (smtp_mailtick() == SMTP_PENDING) {
			return 0;
		} else if (smtp_status() == SMTP_SUCCESS) {
			__con_mailbuf_lock = -1;
			return 1;
		} else {
			__con_mailbuf_lock = -1;
			state->error = CON_ERR_SMTPERROR;
			return -1;
		}
	}
}

/*** BeginHeader con_loginname */
int con_loginname(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_loginname(ConsoleState* state)
{
	if(state->commandparams != 1) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}

	strncpy(console_login.name,
	        con_getparam(state->command,
	                     state->numparams - state->commandparams),
	        sizeof(console_login.name));
	state->conio->puts("NAME: \"");
	state->conio->puts(console_login.name);
	state->conio->puts("\"\r\n");
	con_backup();
	return 1;
}

/*** BeginHeader con_loginpassword */
int con_loginpassword(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_loginpassword(ConsoleState* state)
{
	if(state->commandparams != 0) {
		state->error = CON_ERR_BADPARAMETER;
		return -1;
	}

	switch(state->substate) {
		case 0:
			state->conio->puts("old password:  ");
			state->command[0] = '\0';
			state->cmdptr = state->command;
			state->sawesc = 0;
			state->echo = 0;
			state->substate = 1;


			// intentionally drop through.

		case 1:
			switch(__con_inputstring(state)) {
				case -1:
					state->error = CON_ERR_INVALIDPASSWORD;
					return -1;

				case 1:
					state->echo = 1;

					state->conio->puts("\r\n");
					if(strcmp(console_login.password, state->command) == 0) {
						state->conio->puts("\r\nNew Password: ");

						state->command[0] = '\0';
						state->cmdptr = state->command;
						state->sawesc = 0;
						state->substate = 2;
						state->echo = 0;
					} else {
						state->error = CON_ERR_INVALIDPASSWORD;
						return -1;
					}
					break;


				case 0:
					break;
			}
			break;

		case 2:
			switch(__con_inputstring(state)) {
				case -1:
					state->error = CON_ERR_INVALIDPASSWORD;
					return -1;

				case 1:
					state->echo = 1;
					strncpy(state->cmddata, state->command, sizeof(state->cmddata));
					state->conio->puts("\r\nRetype new Password: ");

					state->command[0] = '\0';
					state->cmdptr = state->command;
					state->sawesc = 0;
					state->substate = 3;
					state->echo = 0;
					break;

				case 0:
					break;
			}
			break;

		case 3:
			switch(__con_inputstring(state)) {
				case -1:
					state->error = CON_ERR_INVALIDPASSWORD;
					return -1;

				case 1:
					state->echo = 1;

					state->conio->puts("\r\n");
					if(strcmp(state->command, state->cmddata) == 0) {
						strncpy(console_login.password, state->command,
						        sizeof(console_login.password));
						state->conio->puts("Password Accepted\r\n");
						con_backup();
						return 1;
					} else {
						state->conio->puts("Passwords did not match.\r\n");
						*((long*)state->cmddata) = MS_TIMER+1000;
						state->substate = 4;
					}

				case 0:
					break;
			}
			break;

		case 4: // timeout bad password
			if((long)(*((long*)state->cmddata) - MS_TIMER) <= 0) {
				state->substate = 0;
			}
			break;
	}

	return 0;
}

/*** BeginHeader con_logout */
int con_logout(ConsoleState* state);
/*** EndHeader */

_zconsole_nodebug
int con_logout(ConsoleState* state)
{
	state->conio->close();
	state->state=CON_INIT;
}

/*** BeginHeader conio_serA_close ****************************/
void conio_serA_close(long baud);
/*** EndHeader ***********************************************/

_zconsole_nodebug
void conio_serA_close(long baud)
{
	serAclose();
}

/*** BeginHeader conio_serA_puts *****************************/
int conio_serA_puts(char *s);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_serA_puts(char *s)
{
	int freebytes;

	freebytes = serAwrFree();
	if (freebytes >= strlen(s)) {
		return serAwrite(s, strlen(s));
	} else {
		return serAwrite(s, freebytes);
	}
}

/*** BeginHeader conio_serB_close ****************************/
void conio_serB_close(long baud);
/*** EndHeader ***********************************************/

_zconsole_nodebug
void conio_serB_close(long baud)
{
	serBclose();
}

/*** BeginHeader conio_serB_puts *****************************/
int conio_serB_puts(char *s);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_serB_puts(char *s)
{
	int freebytes;

	freebytes = serBwrFree();
	if (freebytes >= strlen(s)) {
		return serBwrite(s, strlen(s));
	} else {
		return serBwrite(s, freebytes);
	}
}

/*** BeginHeader conio_serC_close ****************************/
void conio_serC_close(long baud);
/*** EndHeader ***********************************************/

_zconsole_nodebug
void conio_serC_close(long baud)
{
	serCclose();
}

/*** BeginHeader conio_serC_puts *****************************/
int conio_serC_puts(char *s);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_serC_puts(char *s)
{
	int freebytes;

	freebytes = serCwrFree();
	if (freebytes >= strlen(s)) {
		return serCwrite(s, strlen(s));
	} else {
		return serCwrite(s, freebytes);
	}
}

/*** BeginHeader conio_serD_close ****************************/
void conio_serD_close(long baud);
/*** EndHeader ***********************************************/

_zconsole_nodebug
void conio_serD_close(long baud)
{
	serDclose();
}

/*** BeginHeader conio_serD_puts *****************************/
int conio_serD_puts(char *s);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_serD_puts(char *s)
{
	int freebytes;

	freebytes = serDwrFree();
	if (freebytes >= strlen(s)) {
		return serDwrite(s, strlen(s));
	} else {
		return serDwrite(s, freebytes);
	}
}

/*** BeginHeader conio_serE_close ****************************/
void conio_serE_close(long baud);
/*** EndHeader ***********************************************/

_zconsole_nodebug
void conio_serE_close(long baud)
{
	serEclose();
}

/*** BeginHeader conio_serE_puts *****************************/
int conio_serE_puts(char *s);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_serE_puts(char *s)
{
	int freebytes;

	freebytes = serEwrFree();
	if (freebytes >= strlen(s)) {
		return serEwrite(s, strlen(s));
	} else {
		return serEwrite(s, freebytes);
	}
}

/*** BeginHeader conio_serF_close ****************************/
void conio_serF_close(long baud);
/*** EndHeader ***********************************************/

_zconsole_nodebug
void conio_serF_close(long baud)
{
	serFclose();
}

/*** BeginHeader conio_serF_puts *****************************/
int conio_serF_puts(char *s);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_serF_puts(char *s)
{
	int freebytes;

	freebytes = serFwrFree();
	if (freebytes >= strlen(s)) {
		return serFwrite(s, strlen(s));
	} else {
		return serFwrite(s, freebytes);
	}
}

/*** BeginHeader conio_sp_open *******************************/
int conio_sp_open(long channel);

extern char __con_sp_rdbuffer[];
extern char __con_sp_wrbuffer[];
extern void* __con_sp_spstream;
/*** EndHeader ***********************************************/

char __con_sp_rdbuffer[CON_SP_RDBUF_SIZE + 9];
char __con_sp_wrbuffer[CON_SP_WRBUF_SIZE + 9];
void* __con_sp_spstream;
SPStream __con_sp_spstream_data;

_zconsole_nodebug
int conio_sp_open(long channel)
{
	__con_sp_spstream = &__con_sp_spstream_data;
	__con_sp_spstream_data.inbuf = __con_sp_rdbuffer;
	__con_sp_spstream_data.outbuf = __con_sp_wrbuffer;
	cbuf_init(__con_sp_rdbuffer, CON_SP_RDBUF_SIZE);
	cbuf_init(__con_sp_wrbuffer, CON_SP_WRBUF_SIZE);

	SPsetHandler((char)channel, SPShandler, __con_sp_spstream);
	return 1;
}

/*** BeginHeader conio_sp_close ******************************/
void conio_sp_close(long channel);
/*** EndHeader ***********************************************/

_zconsole_nodebug
void conio_sp_close(long channel)
{
	SPsetHandler((char)channel, NULL, NULL);
}

/*** BeginHeader conio_sp_tick *******************************/
int conio_sp_tick(void);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_sp_tick(void)
{
	SPtick();
	return 0;
}

/*** BeginHeader conio_sp_puts *******************************/
int conio_sp_puts(char *s);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_sp_puts(char *s)
{
	int freebytes;

	freebytes = SPSwrFree(__con_sp_spstream);
	if (freebytes >= strlen(s)) {
		return SPSwrite(__con_sp_spstream, s, strlen(s));
	} else {
		return SPSwrite(__con_sp_spstream, s, freebytes);
	}
}

/*** BeginHeader conio_sp_rdUsed *****************************/
int conio_sp_rdUsed(void);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_sp_rdUsed(void)
{
	return SPSrdUsed(__con_sp_spstream);
}

/*** BeginHeader conio_sp_wrUsed *****************************/
int conio_sp_wrUsed(void);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_sp_wrUsed(void)
{
	return SPSwrUsed(__con_sp_spstream);
}

/*** BeginHeader conio_sp_wrFree *****************************/
int conio_sp_wrFree(void);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_sp_wrFree(void)
{
	return SPSwrFree(__con_sp_spstream);
}

/*** BeginHeader conio_sp_read *******************************/
int conio_sp_read(void* data, int length, unsigned long tmout);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_sp_read(void* data, int length, unsigned long tmout)
{
	return SPSread(__con_sp_spstream, data, length, tmout);
}

/*** BeginHeader conio_sp_write ******************************/
int conio_sp_write(void* data, int length);
/*** EndHeader ***********************************************/

_zconsole_nodebug
int conio_sp_write(void* data, int length)
{
	return SPSwrite(__con_sp_spstream, data, length);
}

/*** BeginHeader conio_telnet_open ***************************/
int conio_telnet_open(long port);

extern int conio_telnet_port;
extern int __code_bytes_needed;
/*** EndHeader ***********************************************/

/* the port we listen on */
int conio_telnet_port;
int __code_bytes_needed;

_zconsole_nodebug
int conio_telnet_open(long port)
{
	conio_telnet_port = (int)port;
	__code_bytes_needed = 0;
	return 1;
}

/*** BeginHeader conio_telnet_close **************************/
void conio_telnet_close(long port);
/*** EndHeader ***********************************************/

_zconsole_nodebug
void conio_telnet_close(long port)
{
	conio_telnet_state = CONIO_TELNET_RESET;
}

/*** BeginHeader conio_telnet_tick ***************************/
int conio_telnet_tick(void);

#ifdef DCRTCP
extern tcp_Socket conio_telnet_sock;
extern int conio_telnet_state;
#endif

/* states for the telnet console */
#define CONIO_TELNET_INIT		0
#define CONIO_TELNET_LISTEN	1
#define CONIO_TELNET_WAIT		2
#define CONIO_TELNET_RUNNING	3
#define CONIO_TELNET_RESET		4
/*** EndHeader ***********************************************/

#use "vserial.lib"

_TelnetCooker	conio_telnet_cooker;
tcp_Socket conio_telnet_sock;
int conio_telnet_state;

_zconsole_nodebug
int conio_telnet_tick(void)
{
#GLOBAL_INIT {
	conio_telnet_state = CONIO_TELNET_INIT;
}

	tcp_tick(NULL);

	switch(conio_telnet_state) {
	case CONIO_TELNET_INIT:
		if(conio_telnet_port != 0)
			conio_telnet_state = CONIO_TELNET_LISTEN;
		break;

	case CONIO_TELNET_LISTEN:
		tcp_extlisten(&conio_telnet_sock, IF_ANY, conio_telnet_port, 0, 0, NULL, 0, 0, 0);
		conio_telnet_state = CONIO_TELNET_WAIT;
		break;

	case CONIO_TELNET_WAIT:
		if (sock_established(&conio_telnet_sock) ||
		    sock_bytesready(&conio_telnet_sock) > -1) {
			telnet_init(&conio_telnet_cooker, &conio_telnet_sock, TELNET_OPTION_GA|TELNET_OPTION_ECHO);
			conio_telnet_state = CONIO_TELNET_RUNNING;
		}
		else if (tcp_tick(&conio_telnet_sock) == 0) {
			conio_telnet_state = CONIO_TELNET_RESET;
		}
		break;

	case CONIO_TELNET_RUNNING:
		if(!sock_established(&conio_telnet_sock) &&
		   sock_bytesready(&conio_telnet_sock) == -1) {
			conio_telnet_state = CONIO_TELNET_RESET;
		}
		return 0; /* running - return success */

	case CONIO_TELNET_RESET:
		sock_close(&conio_telnet_sock);
		__code_bytes_needed = 0;
		conio_telnet_state = CONIO_TELNET_LISTEN;
		break;

	default:
		__code_bytes_needed = 0;
		conio_telnet_state = CONIO_TELNET_RESET;
		break;
	}

	return 1; /* return 'not connected' */
}

/*** BeginHeader conio_telnet_puts ***************************/
int conio_telnet_puts(char *s);
/*** EndHeader ***********************************************/

#use "vserial.lib"
extern _TelnetCooker	conio_telnet_cooker;

_zconsole_nodebug
int conio_telnet_puts(char *s)
{
	auto int len, offset, retval;

	if(conio_telnet_state != CONIO_TELNET_RUNNING) {
		return strlen(s);
	}

	offset = 0;
	len = strlen(s);

	while(offset < len) {
		retval = telnet_fastwrite(&conio_telnet_cooker, s + offset, len - offset);
		if(-1 == retval) {
			/* error */
			conio_telnet_state = CONIO_TELNET_RESET;
			return len;
		}
		offset += retval;
		if(!sock_established(&conio_telnet_sock)) {
			conio_telnet_state = CONIO_TELNET_RESET;
			return len;
		}
		tcp_tick(&conio_telnet_sock);
	}

	return len;
}

/*** BeginHeader conio_telnet_rdUsed *************************/
int conio_telnet_rdUsed(void);
/*** EndHeader ***********************************************/

#use "vserial.lib"
extern _TelnetCooker	conio_telnet_cooker;

_zconsole_nodebug
int conio_telnet_rdUsed(void)
{
	if(conio_telnet_state != CONIO_TELNET_RUNNING) {
		return 0;
	}

	return telnet_rdUsed(&conio_telnet_cooker);
}

/*** BeginHeader conio_telnet_wrUsed *************************/
int conio_telnet_wrUsed(void);
/*** EndHeader ***********************************************/

#use "vserial.lib"
extern _TelnetCooker	conio_telnet_cooker;

_zconsole_nodebug
int conio_telnet_wrUsed(void)
{
	if(conio_telnet_state != CONIO_TELNET_RUNNING) {
		return 0;
	}

	return telnet_wrUsed(&conio_telnet_cooker);
}

/*** BeginHeader conio_telnet_wrFree *************************/
int conio_telnet_wrFree(void);
/*** EndHeader ***********************************************/

#use "vserial.lib"
extern _TelnetCooker	conio_telnet_cooker;

_zconsole_nodebug
int conio_telnet_wrFree(void)
{
	if(conio_telnet_state != CONIO_TELNET_RUNNING) {
		return (sock_tbsize(&conio_telnet_sock));
	}

	return telnet_wrFree(&conio_telnet_cooker);
}

/*** BeginHeader conio_telnet_read ***************************/
int conio_telnet_read(void *data, int length, unsigned long tmout);
/*** EndHeader ***********************************************/

#use "vserial.lib"
extern _TelnetCooker	conio_telnet_cooker;

_zconsole_nodebug
int conio_telnet_read(void *d, int length, unsigned long tmout)
{
	auto long timer;
	auto int retval, len;
	auto char *p;

	if(conio_telnet_state != CONIO_TELNET_RUNNING) {
		return length;
	}

	timer = MS_TIMER + tmout;
	len = length;
	p = d;
	do {
		retval = telnet_fastread(&conio_telnet_cooker,p,length);
		if(-1 == retval)
			return -1;
		p += retval;
		len -= retval;
		if(!sock_established(&conio_telnet_sock)) {
			conio_telnet_state = CONIO_TELNET_RESET;
			return length;
		}
		tcp_tick(&conio_telnet_sock);
	} while((len > 0) && (timer>MS_TIMER));

	return (length-len);
}

/*** BeginHeader conio_telnet_write **************************/
int conio_telnet_write(void *data, int length);
/*** EndHeader ***********************************************/

#use "vserial.lib"
extern _TelnetCooker conio_telnet_cooker;

_zconsole_nodebug
int conio_telnet_write(void *data, int length)
{
	auto int offset, retval;

	if(conio_telnet_state != CONIO_TELNET_RUNNING) {
		return length;
	}

	offset = 0;
	while(offset < length) {
		retval = telnet_fastwrite(&conio_telnet_cooker, (char *)data + offset, length - offset);
		if(-1 == retval) {
			/* error */
			conio_telnet_state = CONIO_TELNET_RESET;
			return length;
		}
		offset += retval;
		if(!sock_established(&conio_telnet_sock)) {
			conio_telnet_state = CONIO_TELNET_RESET;
			return length;
		}
	}

	return length;
}

/*** BeginHeader __con_load_backup_file */
#ifndef CON_NO_FS_SUPPORT
int __con_load_backup_file(File *F);
#endif
/*** EndHeader */

_zconsole_nodebug
int __con_load_backup_file(File *F)
{
	auto unsigned long config_len, spec_len;
	auto unsigned long offset;
	auto int retval;
	auto int i;

#ifdef DBG_BACKUP
	printf("Reading old config table...\n");
#endif
	/* read out the version number */
	if(4 != fread(F, (char *)&__con_backupversion, 4)) {
		/* error */
		return -1;
	}
#ifdef DBG_BACKUP
	printf("\t__con_backupversion == %ld\n",__con_backupversion);
#endif

	for (i = 0; i < (sizeof(console_backup) / sizeof(ConsoleBackup)); i++) {
		/* read out the length of the main config region */
		if(4 != fread(F, (char *)&config_len, 4)) {
			/* error */
			return -(i+1);
		}
#ifdef DBG_BACKUP
		printf("\tLength of console_backup[%d] == %ld\n",i,config_len);
#endif
		if(config_len != (unsigned long)console_backup[i].len) {
#ifdef DBG_BACKUP
			printf("ERROR: Filesystem contains config struct of incorrect version!\n");
			printf("\tLength of console_backup[%d] == 0x%08lx\tconfig_len == 0x%08lx\n",i,(unsigned long)console_backup[i].len,config_len);
#endif
			return -(i+1);
		}

		/* read out the main configuration */
		offset = 0;
		while(offset < config_len) {
			retval = fread(F, (char *)(console_backup[i].data) + (int)offset, (int)(config_len - offset));
			if(retval < 1) {
				/* not enough data in file! */
				return -(i+1);
			}
			offset += retval;
		}

		if (console_backup[i].postload != NULL) {
			console_backup[i].postload(console_backup[i].data);
		}
	}

	return 0;
}

/*** BeginHeader con_load_backup */

/* START FUNCTION DESCRIPTION ********************************************
con_load_backup                        <ZCONSOLE.LIB>

SYNTAX: int con_load_backup(void);

KEYWORDS:		tcpip

DESCRIPTION:	Loads the console configuration from the backup area.

RETURN VALUE:	0		successfully loaded configuration
					1		no configuration information found
					< 0	indicates an error loading the configuration
					      data.  -1 indicates an error reading the 1st
					      set of information, -2 the 2nd set, and so on.

SEE ALSO:		con_backup, con_backup_reserve

END DESCRIPTION **********************************************************/

int con_load_backup(void);
/*** EndHeader */

_zconsole_nodebug
int con_load_backup(void)
{
#ifdef CON_BACKUP_USER_BLOCK
	return __con_load_backup_userblock();
#else
	#ifndef CON_NO_FS_SUPPORT
		return __con_load_backup_fs();
	#else
		return 1;
	#endif
#endif
}

/*** BeginHeader __con_load_backup_userblock */
int __con_load_backup_userblock(void);
/*** EndHeader */

_zconsole_nodebug
int __con_load_backup_userblock(void)
{
	auto int i;
	auto int offset;
	auto int config_len;
	auto int retval;

	offset = 0;
	for (i = 0; i < (sizeof(console_backup) / sizeof(ConsoleBackup)); i++) {
		/* Read out the length of this config region */
		retval = readUserBlock(&config_len, offset, sizeof(int));
		if (retval == 0) {
			if (config_len != console_backup[i].len) {
#ifdef DBG_BACKUP
				printf("ERROR: User block contains struct of incorrect version!\n");
				printf("\tLength of console_backup[%d] == 0x%04x\tconfig_len == 0x%04x\n",
				       i, console_backup[i].len, config_len);
#endif
				return -(i+1);
			}
			offset += sizeof(int);
			retval = readUserBlock(console_backup[i].data, offset, config_len);
		}
		if (retval != 0) {
#ifdef DBG_BACKUP
			switch (retval) {
			case -1:
				printf("ERROR: Invalid address or range!\n");
				break;
			case -2:
				printf("ERROR: No valid ID block found (block version 3 or later)!\n");
				break;
			}
#endif
			return -(i+1);
		}
		if (console_backup[i].postload != NULL) {
			console_backup[i].postload(console_backup[i].data);
		}
		offset += config_len;
	}
	return 0;
}

/*** BeginHeader __con_load_backup_fs */
int __con_load_backup_fs(void);

extern char __con_nextbackupfile;
extern unsigned long __con_backupversion;
/*** EndHeader */

char __con_nextbackupfile;
unsigned long __con_backupversion;

_zconsole_nodebug
int __con_load_backup_fs(void)
{
	auto FileNumber fname1, fname2;
	auto File *F1, *F2;
	auto File f1, f2;
	auto unsigned long v1, v2;
	auto int errcode;

	errcode = 0;
	F1 = &f1;
	F2 = &f2;
	fname1 = CON_BACKUP_FILE1;
	fname2 = CON_BACKUP_FILE2;

	if(fopen_rd(F1, fname1)) {
		/* no file 1 */
		if(fopen_rd(F2, fname2)) {
			/* we have neither file! Error! format the fs! */
			return 1;
		} else {
			if(errcode = __con_load_backup_file(F2)) {
				goto __zconsole_load_error;
			}
			__con_nextbackupfile = CON_BACKUP_FILE1;
			fclose(F2);
		}
	} else {
		if(fopen_rd(F2, fname2)) {
			/* have file 1, but no file 2 */
			if(errcode = __con_load_backup_file(F1)) {
				goto __zconsole_load_error;
			}
			__con_nextbackupfile = CON_BACKUP_FILE2;
			fclose(F1);
		} else {
			/* both exist! check the version numbers */
			if(4 != fread(F1, (char *)&v1, 4)) {
				/* error in read! try the other one */
				if(errcode = __con_load_backup_file(F2)) {
					/* error in send file as well - format everything! */
					goto __zconsole_load_error;
				}
				fclose(F1);
				fclose(F2);
				fdelete(fname1); /* kill the first file - it was incorrect */
				__con_nextbackupfile = CON_BACKUP_FILE1;
				return 0;
			}
			if(4 != fread(F2, (char *)&v2, 4)) {
				/* error in read! try the other one */
				if(errcode = __con_load_backup_file(F1)) {
					/* error in send file as well - format everything! */
					goto __zconsole_load_error;
				}
				fclose(F1);
				fclose(F2);
				fdelete(fname2); /* kill the first file - it was incorrect */
				__con_nextbackupfile = CON_BACKUP_FILE2;
				return 0;
			}

			/* got two version numbers - compare them */
			if(v1 < v2) {
				/* v1 is older - keep it */
				fseek(F1,0,SEEK_SET);
				if(errcode = __con_load_backup_file(F1)) {
					goto __zconsole_load_error;
				}
				fclose(F1);
				__con_nextbackupfile = CON_BACKUP_FILE2;

				/* delete the incorrect one */
				fclose(F2);
				fdelete(fname2);
			} else {
				/* v2 is older - keep it */
				fseek(F2,0,SEEK_SET);
				if(errcode = __con_load_backup_file(F2)) {
					goto __zconsole_load_error;
				}
				fclose(F2);
				__con_nextbackupfile = CON_BACKUP_FILE1;

				/* delete the incorrect one */
				fclose(F1);
				fdelete(fname1);
			}
		}
	}
	/* all done */
	return 0;

__zconsole_load_error:
	fclose(F1); /* make sure the files are closed */
	fclose(F2);
	//fs_format(0, CON_FS_NUM_BLOCKS, 1);
	return errcode;
}

/*** BeginHeader con_backup_reserve */

/* START FUNCTION DESCRIPTION ********************************************
con_backup_reserve                     <ZCONSOLE.LIB>

SYNTAX: void con_backup_reserve(void);

KEYWORDS:		tcpip

DESCRIPTION:	Reserves the correct number of filesystem blocks to
					save the console configuration data.  This function
					must be called after the file system is initialized
					or formatted.  Note that console_init() also calls
					this function.

RETURN VALUE:	none

SEE ALSO:		con_backup, con_load_backup, con_backup_bytes

END DESCRIPTION **********************************************************/

void con_backup_reserve(void);
/*** EndHeader */

_zconsole_nodebug
void con_backup_reserve(void)
{
#ifndef __FS2_LIB
#ifndef CON_BACKUP_USER_BLOCK
#ifndef CON_NO_FS_SUPPORT
	auto int i;
	auto int total;

	total = 4;	// To handle version number
	for (i = 0; i < (sizeof(console_backup) / sizeof(ConsoleBackup)); i++) {
		total += 4 + console_backup[i].len;
	}
	fs_reserve_blocks((total / ((int)FS_BLOCK_SIZE - FS_HEADER) + 1) * 2);
#endif
#endif
#endif
}

/*** BeginHeader con_backup_bytes */

/* START FUNCTION DESCRIPTION ********************************************
con_backup_bytes                       <ZCONSOLE.LIB>

SYNTAX: long con_backup_bytes(void);

KEYWORDS:		tcpip

DESCRIPTION:	Returns the number of bytes necessary for each
					backup configuration file.  Note that enough space
					for 2 of these files needs to be reserved.  This
					function is most useful when ZCONSOLE.LIB is being
					used with FS2.LIB.

RETURN VALUE:	Number of bytes needed for a backup configuration file

SEE ALSO:		con_backup_reserve

END DESCRIPTION **********************************************************/

long con_backup_bytes(void);
/*** EndHeader */

_zconsole_nodebug
long con_backup_bytes(void)
{
	auto int i;
	auto long total;

	total = 4;	// To handle version number
	for (i = 0; i < (sizeof(console_backup) / sizeof(ConsoleBackup)); i++) {
		total += 4 + console_backup[i].len;
	}
	return (total);
}

/*** BeginHeader con_set_files_lx */

/* START FUNCTION DESCRIPTION ********************************************
con_set_files_lx                       <ZCONSOLE.LIB>

SYNTAX: void con_set_files_lx(FSLXnum fileslx);

KEYWORDS:		tcpip

DESCRIPTION:	Sets the LX which will be used to store files.  This is
					only useful in conjunction with FS2.LIB.  This should be
					called once before console_init().

PARAMETER1:    LX number to use for files

SEE ALSO:		con_set_backup_lx

END DESCRIPTION **********************************************************/

#ifdef __FS2_LIB
void con_set_files_lx(FSLXnum fileslx);
#endif
/*** EndHeader */

#ifdef __FS2_LIB
_zconsole_nodebug
void con_set_files_lx(FSLXnum fileslx)
{
	__con_files_lx = fileslx;
}
#endif

/*** BeginHeader con_set_backup_lx */

/* START FUNCTION DESCRIPTION ********************************************
con_set_backup_lx                      <ZCONSOLE.LIB>

SYNTAX: void con_set_backup_lx(FSLXnum backuplx);

KEYWORDS:		tcpip

DESCRIPTION:	Sets the LX which will be used to store the backup
					configuration data.  This is only useful in conjunction
					with FS2.LIB.  This should be called once before
					console_init().  Care should be taken that enough space
					is available in this logical extent for the configuration
					files.  See con_backup_bytes() for more information.

PARAMETER1:    LX number to use for backup

SEE ALSO:		con_set_files_lx, con_backup_bytes

END DESCRIPTION **********************************************************/

#ifdef __FS2_LIB
void con_set_backup_lx(FSLXnum backuplx);
#endif
/*** EndHeader */

#ifdef __FS2_LIB
_zconsole_nodebug
void con_set_backup_lx(FSLXnum backuplx)
{
	__con_backup_lx = backuplx;
}
#endif

/*** BeginHeader con_backup */

/* START FUNCTION DESCRIPTION ********************************************
con_backup                             <ZCONSOLE.LIB>

SYNTAX: int con_backup(void);

KEYWORDS:		tcpip

DESCRIPTION:	Saves the console configuration to the backup area.

RETURN VALUE:	0 - success
					1 - failure backing up

SEE ALSO:		con_backup_reserve, con_load_backup

END DESCRIPTION **********************************************************/

int con_backup(void);
/*** EndHeader */

_zconsole_nodebug
int con_backup(void)
{
#ifdef CON_BACKUP_USER_BLOCK
	return __con_backup_userblock();
#else
	#ifndef CON_NO_FS_SUPPORT
		return __con_backup_fs();
	#else
		return 1;
	#endif
#endif
}

/*** BeginHeader __con_backup_userblock */
int __con_backup_userblock(void);
/*** EndHeader */

_zconsole_nodebug
int __con_backup_userblock(void)
{
	auto int i;
	auto int offset;
	auto int retval;
	auto char* ptrs[2 * (sizeof(console_backup) / sizeof(ConsoleBackup))];
	auto unsigned int lens[2 * (sizeof(console_backup) / sizeof(ConsoleBackup))];

	/* Construct the list of information to save */
	for (i = 0; i < (sizeof(console_backup) / sizeof(ConsoleBackup)); i++) {
		if (console_backup[i].presave != NULL) {
			console_backup[i].presave(console_backup[i].data);
		}
		ptrs[i*2] = (char *)&console_backup[i].len;
		lens[i*2] = sizeof(int);
		ptrs[i*2+1] = console_backup[i].data;
		lens[i*2+1] = console_backup[i].len;
	}

	/* Write out the data */
	retval = writeUserBlockArray(0, ptrs, lens, 2 * (sizeof(console_backup) /
	                                                 sizeof(ConsoleBackup)));
	if (retval != 0) {
#ifdef DBG_BACKUP
		switch (retval) {
		case -1:
			printf("ERROR: Invalid address or range!\n");
			break;
		case -2:
			printf("ERROR: No valid user block found (block version 3 or later)!\n");
			break;
		case -3:
			printf("ERROR: Flash writing error!\n");
			break;
		}
#endif
		return 1;
	}
	return 0;
}

/*** BeginHeader __con_backup_fs */
int __con_backup_fs(void);
/*** EndHeader */

_zconsole_nodebug
int __con_backup_fs(void)
{
	auto int offset, len, retval;
	auto unsigned long temp;
	auto int i;
	auto File f, *F;
#ifdef __FS2_LIB
	auto FSLXnum meta_lx;
	auto FSLXnum data_lx;
#endif
	F = &f;

#ifdef __FS2_LIB
	meta_lx = fs_get_lx(1);
	data_lx = fs_get_lx(0);
	fs_set_lx(__con_backup_lx, __con_backup_lx);
#endif
	/* backup: main_id */
#ifdef DBG_BACKUP
	printf("con_backup()...\n");
#endif
	if(fcreate(F, __con_nextbackupfile)) {
		/* Error! File allready exists? */
#ifdef __FS2_LIB
		fs_set_lx(meta_lx, data_lx);
#endif
		goto __zconsole_backup_error;
	}
#ifdef __FS2_LIB
	fs_set_lx(meta_lx, data_lx);
#endif

	/* write out the new version number */
	__con_backupversion++;
#ifdef DBG_BACKUP
	printf("\t__con_backupversion == %ld\n",__con_backupversion);
#endif
	if(4 != fwrite(F, (char *)&__con_backupversion, 4)) {
		goto __zconsole_backup_error;
	}

	/* Loop through the backup data */
	for (i = 0; i < (sizeof(console_backup) / sizeof(ConsoleBackup)); i++) {
		if (console_backup[i].presave != NULL) {
			console_backup[i].presave(console_backup[i].data);
		}

		/* write out the length of the config table */
		temp = console_backup[i].len;
#ifdef DBG_BACKUP
		printf("\tLength of console_backup[%d]) == %ld\n",i,temp);
#endif
		if(4 != fwrite(F, (char *)&temp, 4)) {
			goto __zconsole_backup_error;
		}

		/* write out the actual config table */
		offset = 0;
		len = console_backup[i].len;
		while(offset < len) {
			retval = fwrite(F, (char *)console_backup[i].data + offset, len - offset);
			if(retval < 1) {
				/* error - no room */
				goto __zconsole_backup_error;
			}
			offset += retval;
		}
	}

	fclose(F);
	/* remove the old file, if it exists */
	if(CON_BACKUP_FILE1 == __con_nextbackupfile) {
		fdelete(CON_BACKUP_FILE2);
		__con_nextbackupfile = CON_BACKUP_FILE2;
	} else {
		fdelete(CON_BACKUP_FILE1);
		__con_nextbackupfile = CON_BACKUP_FILE1;
	}

	return 0;

__zconsole_backup_error:
	fclose(F);

	/* should we format the fs here? */
#ifdef DBG_BACKUP
	printf("ERROR: No room to backup config table in flash FS!\n");
#endif
	return 1;
}

/*** BeginHeader con_backup_info_postload */
void con_backup_info_postload(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_backup_info_postload(void* dataptr)
{
	auto int i;
	auto ConsoleBackupInfo* info;

	info = (ConsoleBackupInfo *)dataptr;

	for (i = 0; i < NUM_CONSOLES; i++) {
		__constate[i].echo = info->echo[i];
	}
}

/*** BeginHeader con_backup_info_presave */
void con_backup_info_presave(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_backup_info_presave(void* dataptr)
{
	auto int i;
	auto ConsoleBackupInfo* info;

	info = (ConsoleBackupInfo *)dataptr;

	info->top = 0xa5;
	for (i = 0; i < NUM_CONSOLES; i++) {
		info->echo[i] = __constate[i].echo;
	}
}

/*** BeginHeader con_tcp_backup_info_postload */
void con_tcp_backup_info_postload(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_tcp_backup_info_postload(void* dataptr)
{
	auto ConsoleTCPBackupInfo* info;

	info = (ConsoleTCPBackupInfo *)dataptr;

	ifconfig(IF_DEFAULT, IFS_IPADDR, info->ip, IFS_END);
	ifconfig(IF_DEFAULT, IFS_NETMASK, info->netmask, IFS_END);
	ifconfig(IF_DEFAULT, IFS_ROUTER_SET, info->gateway, IFS_END);
	ifconfig(IF_DEFAULT, IFS_NAMESERVER_SET, info->nameserver, IFS_END);
}

/*** BeginHeader con_tcp_backup_info_presave */
void con_tcp_backup_info_presave(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_tcp_backup_info_presave(void* dataptr)
{
	auto ConsoleTCPBackupInfo* info;
	auto ATHandle ath;

	info = (ConsoleTCPBackupInfo *)dataptr;

	info->top = 0xa5;
	ifconfig(IF_DEFAULT, IFG_IPADDR, &info->ip, IFS_END);
	ifconfig(IF_DEFAULT, IFG_NETMASK, &info->netmask, IFS_END);
   ath = router_for_iface(0x01010101, NULL, NULL, IF_ANY);
	if (ath > 0 && ATH2INDEX(ath) < ARP_TABLE_SIZE)
		info->gateway = _arp_data[ATH2INDEX(ath)].ip;
	info->nameserver = servlist_first(&_dns_server_table,0,NULL);
}

/*** BeginHeader con_tcp_multi_backup_info_postload */
void con_tcp_multi_backup_info_postload(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_tcp_multi_backup_info_postload(void* dataptr)
{
	auto ConsoleTCPMultiBackupInfo* info;
	auto int i;

	info = (ConsoleTCPMultiBackupInfo *)dataptr;
	ifs_restore(&(info->save));
	for (i = 0; i < IF_MAX; i++) {
		if (!IF_PKT_SER(i)) {
			ifconfig(i, IFS_UP, IFS_END);
		}
	}
}

/*** BeginHeader con_tcp_multi_backup_info_presave */
void con_tcp_multi_backup_info_presave(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_tcp_multi_backup_info_presave(void* dataptr)
{
	auto ConsoleTCPMultiBackupInfo* info;

	info = (ConsoleTCPMultiBackupInfo *)dataptr;

	info->top = 0xa5;
	repl_getCurrentNetworkConfig(&(info->save));
}

/*** BeginHeader con_http_backup_info_postload */
void con_http_backup_info_postload(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_http_backup_info_postload(void* dataptr)
{
	auto ConsoleHTTPBackupInfo* info;

	info = (ConsoleHTTPBackupInfo *)dataptr;

	__con_varbuflen = info->varbuflen;
}

/*** BeginHeader con_http_backup_info_presave */
void con_http_backup_info_presave(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_http_backup_info_presave(void* dataptr)
{
	auto ConsoleHTTPBackupInfo* info;

	info = (ConsoleHTTPBackupInfo *)dataptr;

	info->top = 0xa5;
	info->varbuflen = __con_varbuflen;
}

/*** BeginHeader con_smtp_backup_info_postload */
void con_smtp_backup_info_postload(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_smtp_backup_info_postload(void* dataptr)
{
	auto ConsoleSMTPBackupInfo* info;

	info = (ConsoleSMTPBackupInfo *)dataptr;

	smtp_setserver(info->mail_serv);
}

/*** BeginHeader con_smtp_backup_info_presave */
void con_smtp_backup_info_presave(void* dataptr);
/*** EndHeader */

_zconsole_nodebug
void con_smtp_backup_info_presave(void* dataptr)
{
	auto ConsoleSMTPBackupInfo* info;

	info = (ConsoleSMTPBackupInfo *)dataptr;

	info->top = 0xa5;
	strcpy(info->mail_serv, smtp_state.server);
}

/*** BeginHeader con_set_timeout */

/* START FUNCTION DESCRIPTION ********************************************
con_set_timeout                        <ZCONSOLE.LIB>

SYNTAX: unsigned long con_set_timeout(unsigned int seconds);

KEYWORDS:		tcpip

DESCRIPTION:	Returns the value that MS_TIMER should have when the
					number of seconds given have elapse.

RETURN VALUE:	future value of MS_TIMER

SEE ALSO:		con_chk_timeout

END DESCRIPTION **********************************************************/

unsigned long con_set_timeout(unsigned int seconds);
/*** EndHeader */

_zconsole_nodebug
unsigned long con_set_timeout(unsigned int seconds)
{
	return (MS_TIMER + seconds*1000);
}

/*** BeginHeader con_chk_timeout */

/* START FUNCTION DESCRIPTION ********************************************
con_chk_timeout                        <ZCONSOLE.LIB>

SYNTAX: int con_chk_timeout(unsigned long timeout);

KEYWORDS:		tcpip

DESCRIPTION:	Checks whether the given timeout value has passed.

RETURN VALUE:	0  -- Timeout has not passed
					!0 -- Timeout has passed

SEE ALSO:		con_set_timeout

END DESCRIPTION **********************************************************/

int con_chk_timeout(unsigned long timeout);
/*** EndHeader */

_zconsole_nodebug
int con_chk_timeout(unsigned long timeout)
{
	return (MS_TIMER >= timeout);
}

/*** BeginHeader  ********************************************/
#endif
/*** EndHeader ***********************************************/

