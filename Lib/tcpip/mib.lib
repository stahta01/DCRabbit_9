/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* SNMP Module version 2.02
 *
 *    mib.lib
 *
 * Management Information Base, for SNMP or standalone use.
 * This library is automatically included if USE_SNMP is defined
 * prior to inclusion of dcrtcp.lib, or may be explicitly included
 * if dcrtcp/snmp is not in use.
 *
 * naming convention:
 *  _mib_*			Internal MIB functions
 *  snmp_*			Documented API.  The snmp prefix is used because
 *						of the close relationship between SNMP and MIB.
 *                Unless otherwise noted, all snmp_* functions herein
 *						can be used with or without snmp.lib.
 *
 * Assigned enterprise numbers (under 1.3.6.1.4.1) are
 *   12807 - Rabbit Semiconductor
 *   12817 - Z-World Inc.
 * Contact IANA for your own enterprise number if you develop
 * a product which requires a product-specific MIB.  You can also
 * temporarily place a MIB tree under 12807.3 or 12817.3, which is
 * reserved for customer experimentation and is used by the
 * supplied demo code.
 */
/*** BeginHeader _mib */
#ifndef MIB_H
#define MIB_H

#ifdef MIB_DEBUG
	#define _mib_nodebug debug
#else
	#define _mib_nodebug nodebug
#endif

/*
 * Configuration definitions
 */

#ifndef USE_MIB
	#define USE_MIB
#endif

// Size of the xmem database tree structure.  Determines the maximum number
// of objects which may be managed.  The default allows for about 100 objects.
#ifndef SNMP_MIB_SIZE
	#define SNMP_MIB_SIZE	4096L
#endif

// Maximum size of an encoded object identifier.
#ifndef SNMP_MAX_NAME
	#define SNMP_MAX_NAME	32
#endif

#ifndef SNMP_DFLT_READMASK
	#define SNMP_DFLT_READMASK		0x03
#endif

#ifndef SNMP_DFLT_WRITEMASK
	#define SNMP_DFLT_WRITEMASK	0x02
#endif

#ifndef SNMP_sysObjectID
	#define SNMP_sysObjectID	_BOARD_TYPE_
#endif

#ifndef SNMP_MAX_PSTACK
	#define SNMP_MAX_PSTACK		3
#endif

typedef unsigned long oidlevel;

#ifndef offsetof
	#define offsetof(s, f) ((unsigned int)((char*)(&((s*)0)->f) - ((char*)0)))
#endif

/*
 * Macros for constructing MIB tree initialization lists (MIBTIL).
 * NB: These macros DO NOT YET WORK; waiting for enhancement to
 * Dynamic C to support arithmetic operations on address constants.
 * For now, equivalent functionality is available via function calls.
 */

#define SNMP_I_NOP	0		// No-op
#define SNMP_I_APP1	1		// Append level (0.255)  +1 byte
#define SNMP_I_APP2	2		// Append level (256..65535) +2 bytes
#define SNMP_I_APP4	3		// Append level (>=65536) +4 bytes
#define SNMP_I_UP		4		// Up one level
#define SNMP_I_PUSH	5		// Push current state
#define SNMP_I_POP	6		// Restore most recent pushed state LIFO
#define SNMP_I_RD		7		// Set read access mask  +1 byte
#define SNMP_I_WR		8		// Set write access mask  +1 byte
#define SNMP_I_CB		9		// Set callback function address  +2 bytes
#define SNMP_I_NCB	10		// Cancel callback
#define SNMP_I_ADD	11		// Add root entry  +1 type, +2 addr, [+2 maxlen]
#define SNMP_I_XADD	12		// Add xmem entry  +1 type, +2 offset, [+2 maxlen]
#define SNMP_I_STIX	13		// Store result MIB tree index  +2 addr of word
#define SNMP_I_SAV	14		// Set saveable flag
#define SNMP_I_NSAV	15		// Clear saveable flag
#define SNMP_I_ADDI	16		// As for ADD, and autoincrement last level
#define SNMP_I_XADDI	17		// As for XADD, and autoincrement last level
#define SNMP_I_MAGIC	213	// Identifies start of MIBTIL
#define SNMP_I_END	255	// Identifies end of MIBTIL

#define SNMP_BEGIN(label) const char label[] = { SNMP_I_MAGIC
#define SNMP_END  , SNMP_I_END };

#define SNMP_APPEND(level) , SNMP_I_APP1, (char)(level)
#define SNMP_APPENDW(level) , SNMP_I_APP2, (char)(level), (char)((level)>>8)
#define SNMP_APPENDL(level) , SNMP_I_APP4, (char)(level), (char)((level)>>8), \
										(char)((level)>>16), (char)((level)>>24)
#define SNMP_UP				, SNMP_I_UP
#define SNMP_PUSH				, SNMP_I_PUSH
#define SNMP_POP				, SNMP_I_POP
#define SNMP_RD(rd)			, SNMP_I_RD, (char)(rd)
#define SNMP_WR(wr)			, SNMP_I_WR, (char)(wr)
#define SNMP_CB(func)		, SNMP_I_CB, (char)(func), (char)((word)(func) >> 8)
#define SNMP_NCB				, SNMP_I_NCB
#define SNMP_ADD(type, addr)	, SNMP_I_ADD, (char)(type), (char)(addr), (char)((word)(addr) >> 8)
#define SNMP_XADD(type, offs)	, SNMP_I_XADD, (char)(type), (char)(offs), (char)((offs) >> 8)
#define SNMP_ADDL(type, addr, maxlen)	, SNMP_I_ADD, (char)(type), (char)(addr), \
							(char)((word)(addr) >> 8), (char)(maxlen), (char)((maxlen) >> 8)
#define SNMP_XADDL(type, offs, maxlen)	, SNMP_I_XADD, (char)(type), (char)(offs), \
							(char)((offs) >> 8), (char)(maxlen), (char)((maxlen) >> 8)
#define SNMP_STIX(addr)		, SNMP_I_STIX, (char)(addr), (char)((word)(addr) >> 8)
#define SNMP_SAV				, SNMP_I_SAV
#define SNMP_NSAV				, SNMP_I_NSAV
#define SNMP_ADDI(type, addr)	, SNMP_I_ADDI, (char)(type), (char)(addr), (char)((word)(addr) >> 8)
#define SNMP_XADDI(type, offs)	, SNMP_I_XADDI, (char)(type), (char)(offs), (char)((offs) >> 8)
#define SNMP_ADDLI(type, addr, maxlen)	, SNMP_I_ADDI, (char)(type), (char)(addr), \
							(char)((word)(addr) >> 8), (char)(maxlen), (char)((maxlen) >> 8)
#define SNMP_XADDLI(type, offs, maxlen)	, SNMP_I_XADDI, (char)(type), (char)(offs), \
							(char)((offs) >> 8), (char)(maxlen), (char)((maxlen) >> 8)


/*
 * Object identifier ("variable name") type
 */
typedef struct _snmp_oid
{
	int	len;
	char	oid[SNMP_MAX_NAME];
} snmp_oid;

/*
 * Object type representations
 */
#ifndef POST_720
typedef word snmp_type;
#define SNMP_SHORT 0
#define SNMP_LONG 1
#define SNMP_STR 2
#define SNMP_OCT 3
#define SNMP_FOCT 4
#define SNMP_OID 5

#else
typedef enum {
	SNMP_SHORT			// 2-byte signed integer
  ,SNMP_LONG			// 4-byte signed integer
  ,SNMP_STR				// Null-terminated ascii string
  ,SNMP_OCT				// Variable-length binary octet string
  ,SNMP_FOCT			// Fixed-length binary octet string
  ,SNMP_OID				// ISO object identifier
} snmp_type;
#endif

/*
 * These definitions really belong in SNMP.LIB, however we bring them
 * in here just in case MIB.LIB is being used stand-alone.  If so, then
 * the SNMP_P_* values are basically meaningless.
 */

// SNMP primitive data types
#define SNMP_P_INTEGER 		0x02
#define SNMP_P_OCTETSTR		0x04
#define SNMP_P_NULL			0x05
#define SNMP_P_OID			0x06
#define SNMP_P_SEQ			0x30

// SNMP abstract (derived) data types
#define SNMP_P_IPADDR		0x40
#define SNMP_P_COUNTER		0x41
#define SNMP_P_GAUGE			0x42
#define SNMP_P_TIMETICKS	0x43

// These values combine SNMP data type and internal type used by MIB.LIB, and
// are used as one of the parameters of the general snmp_add/snmp_xadd functions.
// There may be more than one way of internally storing a particular data type
// e.g. IP addresses can be stored as 4-byte fixed-length octet, or as a
// longword integer.
#define SNMP_INTEGER_AS_SHORT		(SNMP_P_INTEGER<<4 | SNMP_SHORT)
#define SNMP_INTEGER_AS_LONG		(SNMP_P_INTEGER<<4 | SNMP_LONG)
#define SNMP_INTEGER					SNMP_INTEGER_AS_LONG
#define SNMP_OCTETSTR_VARIABLE	(SNMP_P_OCTETSTR<<4 | SNMP_OCT)
#define SNMP_OCTETSTR_NULLTERM	(SNMP_P_OCTETSTR<<4 | SNMP_STR)
#define SNMP_ASCIISTR				SNMP_OCTETSTR_NULLTERM
#define SNMP_OCTETSTR_FIXED		(SNMP_P_OCTETSTR<<4 | SNMP_FOCT)
#define SNMP_OBJECT_ID				(SNMP_P_OID<<4 | SNMP_OID)
#define SNMP_IPADDR_AS_OCT			(SNMP_P_IPADDR<<4 | SNMP_FOCT)
#define SNMP_IPADDR_AS_LONG		(SNMP_P_IPADDR<<4 | SNMP_LONG)
#define SNMP_COUNTER_AS_SHORT		(SNMP_P_COUNTER<<4 | SNMP_SHORT)
#define SNMP_COUNTER_AS_LONG		(SNMP_P_COUNTER<<4 | SNMP_LONG)
#define SNMP_COUNTER					SNMP_COUNTER_AS_LONG
#define SNMP_GAUGE_AS_SHORT		(SNMP_P_GAUGE<<4 | SNMP_SHORT)
#define SNMP_GAUGE_AS_LONG			(SNMP_P_GAUGE<<4 | SNMP_LONG)
#define SNMP_GAUGE					SNMP_GAUGE_AS_LONG
#define SNMP_TIMETICKS				(SNMP_P_TIMETICKS<<4 | SNMP_LONG)


/*
 * Callback function type
 */
typedef int (*snmp_callback)( /* snmp_parms * p, int wr, int commit,
											long * v, word * len, word maxlen */ );

/*
 * Structure of MIB tree nodes (internal).  Pointers within the tree are represented by
 * indices, not addresses, which allows the table to be relocated.  A null index is
 * represented by SNMP_NULL, not zero.  A maximum of 32767 entries is allowed.  Each entry
 * is 20 bytes, so the largest possible table is 640kB.
 *
 * We divide tree elements into two types: "node" and "leaf".  Nodes have children, leaves
 * do not, but contain object instance data.
 *
 * Each node and leaf in the tree points to its parent (which may be NULL for the topmost nodes).
 * Each node points to its lowest child in lexicographic order of OID.  Nodes and leaves
 * may have siblings: the sib pointer points to the next higher sibling in lex order.
 * No two siblings may have OIDs starting with the same level i.e. all siblings strictly
 * ascend in order of their first OID level.
 *
 * Nodes may contain one or more OID levels (called an OID fragment).  Leaves contain only
 * the least significant level of their complete OID.  Nodes and leaves may be siblings.
 * Nodes must have at least one child.  A node which loses all its children is deleted.
 *
 * Comparisons between OIDs are an important part of tree scanning.  Unfortunately, the standard
 * Basic Encoding Rule (BER) for OIDs is not suitable for simple memcmp() comparisons.  E.g.
 * 16383 is coded as 0xFF 0x7F whereas 65535 is coded as 0x83 0xFF 0x7F.  So that memcmp() can
 * be used, we use a slightly different encoding.  Numbers 0-253 are coded as-is (in a single
 * byte).  254 through 65535 are coded as 0xFE xx yy 0xFE where xx is the MSB of the number, yy is
 * the LSB.  Numbers >= 65536 are encoded as 0xFF ww xx yy zz 0xFF where ww is the MSB etc.
 * This preserves correct lexicographic order w.r.t. memcmp().  Since numbers > 253 are
 * rare, there should even be a slight space-saving with this encoding.  Numbers have tags at
 * both ends to simplify backwards scanning.
 *
 * This encoding scheme, known as RLER (Reversible Lexicographic Encoding Rule), is used
 * throughout the MIB/SNMP implementation.  Conversion to BER is done only when reading/sending
 * packets.
 */
typedef struct
{
	word			sib;			// Next higher sibling node index (must be first field)
	word			parent;		// Parent node index
	union {
		struct {
			word	child;		// First child node index
			word	len;			// Length of following OID fragment - not that this field overlaps
									// the flags field in the leaf variant, which is how the two variants
									// are distinguished.
#define MIB_FRAG_LEN	12
			char	oid[MIB_FRAG_LEN];	// OID fragment (encoded as described above, not BER)
		} node;
		struct {
			snmp_callback cb;	// Callback function (or null)
			word			flags;	// Flags as follows (plus the MIB_* flags of snmp_parms also used if leaf):
#define MIB_LEAF		0x8000	// Indicates this is leaf (else is node; should use node variant).
#define MIB_TYPEMASK	0x0007	// These bits contain snmp_type enum value if leaf node
#define MIB_SNMPMASK	0x0FF0	// These bits contain SNMP data type (see SNMP_P_* above).  This
										// is a refinement of the basic snmp_type storage format.
			oidlevel id;		// Last level of OID
			union {
				int * i;
				long * L;
				char * s;
				long x;
				snmp_oid * o;
			} v;
			word maxlen;		// Maximum length of string or octet buffer
			byte	rdmask;		// Read access mask
			byte	wrmask;		// Write access mask
		} leaf;
	} u;
} mib_tree;

#define MIB_TREE_SIZE	20		// sizeof(mib_tree) - this is necessary for assembler code

/*
 * Structure used for navigating the MIB tree.
 */
typedef struct {
	word		index;			// Current node index
	word		prevsib;			// Previous sibling index (or SNMP_NULL)
	word		nextsib;			// Sibling after prevsib, or 1st child if prevsib null.
	word		n_offs;			// OID offset in current node
	word		s_offs;			// OID offset in search OID
	snmp_oid s_oid;			// Search OID
	mib_tree	t;					// Cached copy of MIB tree element 'index'.
} mib_cursor;

// Return values from search functions, outlining the extent of match
#define MIB_MATCH		0x0001		// At least partial match in node and/or search OID
#define MIB_N_MATCH	0x0002		// Node fully matched
#define MIB_S_MATCH	0x0004		// Search OID fully matched
#define MIB_S_OFLO	0x0008		// Node fully matched was a leaf, but search OID not fully matched
#define MIB_NOT_LEAF	0x0010		// Search did not terminate at leaf node (_mib_find)
#define MIB_S_LOW		0x0020		// Search OID fragment lower than fragment in node (if not full match)

/*
 * Parameters passed to most mib functions
 */
typedef struct _snmp_parms
{
	snmp_oid		stem;			// Must be 1st parameter, so can cast snmp_parms to snmp_oid
	word			flags;		// Only allowed to have bits matching 0x7008:
#define MIB_SAVEABLE		0x1000	// This object is saveable/restorable
#define MIB_FAR			0x2000	// Object is in xmem (else root)
//#define MIB_				0x4000
//#define MIB_				0x0008
	byte			rdmask;		// Read mask - specifies which communities can read this object
	byte			wrmask;		// Write mask
	word			index;		// Index of last object added
	snmp_callback fn;			// Callback function for when object accessed
	snmp_type	type;			// Selector for the following
	union {
		int *	i;					// Short integer
		long * L;				// Long integer
		char * s;				// String (null term or binary)
		long	x;					// Address of xmem object (string or octet or OID)
		snmp_oid * o;			// Pointer to object ID
	} u;
	word			maxlen;		// Maximum length of string or octet object i.e. buffer size,
									// or length of fixed-length octet string.
	mib_tree		last;			// Last MIB tree entry retrieved (snmp_get() etc.)
} snmp_parms;

#define SNMP_NULL		0xFFFF	// Null value for index use


/*
 * Global structure.  One instance of this exists to collect all required global information.
 */
typedef struct {
	long			buf;			// Physical address of start of xmem buffer.  Length of buffer is SNMP_MIB_SIZE.
									// xalloc() guarantees an even address, so it is safe to use LDP on word fields.
									// This must be 1st field (asm usage).
	word			Root;			// Index of tree root.
	word			free;			// Index of first free node in linked list (chained by sib field)
	word			freecount;	// Number of free nodes
} mib_globals;

extern mib_globals _mib;

/*
 * Macros
 */

/*** EndHeader */

// Global variables
mib_globals _mib;

/*** BeginHeader _mib_parse_oid */
snmp_oid * _mib_parse_oid(snmp_oid * oid, char * name, int append);
/*** EndHeader */

_mib_nodebug snmp_oid * _mib_parse_oid(snmp_oid * oid, char * name, int append)
{
	// Parse dotted decimal OID into binary representation.  Replaces or appends to existing.
	// Returns NULL if error.
	auto char * p;
	auto word len;
	auto long n;

	if (!oid) return NULL;
	if (append) {
		len = SNMP_MAX_NAME - oid->len;
		p = oid->oid + oid->len;
	}
	else {
		len = SNMP_MAX_NAME;
		p = oid->oid;
	}
	for (;;) {
		n = 0;
		while (isdigit(*name))
			n = n*10 + (*name++ - '0');
		if (_mib_append_level(&p, &len, n))
			return NULL;
		if (!*name)
			break;
		if (*name++ != '.')
			return NULL;
	}
	oid->len = SNMP_MAX_NAME - len;
	return oid;
}



/*** BeginHeader _mib_binary_oid */
snmp_oid * _mib_binary_oid(snmp_oid * oid, word elen, char * bname, int append);
/*** EndHeader */

_mib_nodebug snmp_oid * _mib_binary_oid(snmp_oid * oid, word elen, char * bname, int append)
{
	// Parse byte sequence into binary representation.  Replaces or appends to existing.
	// Returns NULL if error.  bname points to a string of bytes (value 0..255), of length len,
	// with each byte considered to be an OID level.  Each byte will convert to 1 (if 0..253)
	// or 4 (if 245 or 255) bytes in the OID.
	auto char * p;
	auto word len;

	if (!oid) return NULL;
	if (append) {
		len = SNMP_MAX_NAME - oid->len;
		p = oid->oid + oid->len;
	}
	else {
		len = SNMP_MAX_NAME;
		p = oid->oid;
	}
	while (elen--)
		if (_mib_append_level(&p, &len, (oidlevel)*bname++))
			return NULL;
	oid->len = SNMP_MAX_NAME - len;
	return oid;
}



/*** BeginHeader _mib_append_oid */
snmp_oid * _mib_append_oid(snmp_oid * oid, oidlevel n);
/*** EndHeader */

_mib_nodebug snmp_oid * _mib_append_oid(snmp_oid * oid, oidlevel n)
{
	// Add one level (n) to the current OID.
	auto char * p;
	auto word len;

	if (!oid) return NULL;
	len = SNMP_MAX_NAME - oid->len;
	p = oid->oid + oid->len;
	if (_mib_append_level(&p, &len, n))
			return NULL;
	oid->len = SNMP_MAX_NAME - len;
	return oid;
}



/*** BeginHeader _mib_cat_oid */
snmp_oid * _mib_cat_oid(snmp_oid * oid, word elen, char * eos);
/*** EndHeader */

_mib_nodebug snmp_oid * _mib_cat_oid(snmp_oid * oid, word elen, char * eos)
{
	// Concatenate encoded OID string to the current OID.
	if (!oid) return NULL;
	if (elen > SNMP_MAX_NAME - oid->len)
		return NULL;
	memcpy(oid->oid + oid->len, eos, elen);
	oid->len += elen;
	return oid;
}



/*** BeginHeader _mib_up */
snmp_oid * _mib_up(snmp_oid * oid, word levels);
/*** EndHeader */

_mib_nodebug snmp_oid * _mib_up(snmp_oid * oid, word levels)
{
	// Truncate "levels" least-significant levels from the given OID.  Stops if
	// null OID is reached before tuncating all levels (but this is not an error).
	auto char * p;

	if (!oid) return NULL;
	p = oid->oid + oid->len - 1;
	while (levels && oid->len) {
		if (*p < 0xFE)
			p--, oid->len--;
		else if (*p == 0xFE)
			p -= 4, oid->len -= 4;
		else
			p -= 6, oid->len -= 6;
		levels--;
	}
	return oid;
}



/*** BeginHeader _mib_append_level */
int _mib_append_level(char ** p, word * len, oidlevel n);
/*** EndHeader */

_mib_nodebug int _mib_append_level(char ** p, word * len, oidlevel n)
{
	// Encode n (an OID level) and add to *p, with available length *len.
	// Updates *p, reduces *len.  Returns 0 if OK, 1 if could not fit.
	// This uses the RLER (see description under mib_tree typedef).
	auto char * q;
	auto word rlen;

	if (n < 254L)
		rlen = 1;
	else if (n < 65536L)
		rlen = 4;
	else
		rlen = 6;
	if (*len < rlen)
		return 1;
	*len -= rlen;
	q = *p;
	*p += rlen;
	if (rlen == 1)
		*q = (byte)n;
	else if (rlen == 4) {
		q[0] = 0xFE;
		q[1] = (byte)(n >> 8);
		q[2] = (byte)n;
		q[3] = 0xFE;
	}
	else {
		q[0] = 0xFF;
		q[1] = (byte)(n >> 24);
		q[2] = (byte)(n >> 16);
		q[3] = (byte)(n >> 8);
		q[4] = (byte)n;
		q[5] = 0xFF;
	}
	return 0;
}



/*** BeginHeader _mib_insert */
snmp_parms * _mib_insert(snmp_parms * p);
/*** EndHeader */

_mib_nodebug snmp_parms * _mib_insert(snmp_parms * parms)
{
	// Insert the object specified in p into the MIB tree.  If the object exists, or there
	// is insufficient space, return NULL.  Otherwise return p.
	// All objects are stored by reference, thus the object should not be an auto
	// variable.  Objects may exist in either xmem or root memory.
	auto mib_tree t, f, par;
	auto mib_cursor k;
	auto word rc;
	auto word ss_offs, lc, nn, tc, ln, sib, kt;
	auto char * p;

	if (!parms) return NULL;

	k.index = _mib.Root;
	k.s_offs = 0;
	memcpy(&k.s_oid, &parms->stem, sizeof(snmp_oid));
	rc = _mib_find(&k);
	if (rc & (MIB_S_MATCH | MIB_S_OFLO))
		// Already exists
		return NULL;
	// Cannot have MIB_N_MATCH, since _mib_find descends maximally.  If MIB_MATCH, then need
	// to split a node.  Otherwise, need to insert a sibling.  Determine upper bound of new
	// nodes needed: 1 for the new leaf, 1 node if we have to split, 1 or more for levels
	// between k.s_offs and the leaf level (may be zero if only leaf level left).
	ss_offs = k.s_offs;
	p = k.s_oid.oid + ss_offs;
	lc = 0;
	while (ss_offs < k.s_oid.len) {
		if (*p < 0xFE)
			lc = 1;
		else if (*p == 0xFE)
			lc = 4;
		else
			lc = 6;
		ss_offs += lc;
		p += lc;
	}
	ss_offs -= lc;
	p -= lc;
	nn = 1 + ((rc & MIB_MATCH) != 0);
	if (ss_offs) {
		if (ss_offs <= MIB_FRAG_LEN)
			nn++;
		else
			nn += 1 + ss_offs/(MIB_FRAG_LEN-5);
	}
	if (_mib.freecount < nn)
		// Not enough space
		return NULL;
	// Truncate leaf level from cursor OID, and put leaf level in f.
	k.s_oid.len = ss_offs;
	f.u.leaf.id = _mib_get_level(k.s_oid.oid, &ss_offs);
	ss_offs -= lc;		// Undo the above increment of the parm
	// Create new leaf plus possible new ancestor nodes
	f.u.leaf.flags = MIB_LEAF | parms->type | parms->flags;
	f.u.leaf.v.x = parms->u.x;		// Copy value
	f.u.leaf.maxlen = parms->maxlen;
	f.u.leaf.rdmask = parms->rdmask;
	f.u.leaf.wrmask = parms->wrmask;
	f.u.leaf.cb = parms->fn;
	// Work upward to construct new ancestors (if any)
	parms->index = ln = _mib_new();
	f.sib = SNMP_NULL;
	while (ss_offs > k.s_offs) {
		f.parent = _mib_new();
		_mib_put_node(&f, ln);
		f.u.node.child = ln;
		ln = f.parent;
		tc = 0;
		p--;
		for (;;) {
			if (tc >= ss_offs - k.s_offs)
				break;
			if (*p < 0xFE)
				lc = 1;
			else if (*p == 0xFE)
				lc = 4;
			else
				lc = 6;
			if (tc + lc > MIB_FRAG_LEN)
				break;
			p -= lc;
			tc += lc;
		}
		p++;
		f.u.node.len = tc;
		f.sib = SNMP_NULL;
		memcpy(f.u.node.oid, p, tc);
		ss_offs -= tc;
	}

	if (rc & MIB_MATCH) {
		// Split last node reached, since partial match of OID fragment.  t is the node created under k.index
		// to contain the existing part of the tree.  k.t is the node which is split.  All children of the
		// node being split must be reparented to t.
		t.parent = k.index;
		t.u.node.child = k.t.u.node.child;
		t.u.node.len = k.t.u.node.len - k.n_offs;
		memcpy(t.u.node.oid, k.t.u.node.oid + k.n_offs, t.u.node.len);
		k.t.u.node.len = k.n_offs;
		kt = k.t.u.node.child = _mib_new();
		if (rc & MIB_S_LOW) {
#ifdef MIB_VERBOSE
			printf("MIB: low split\n");
#endif
			f.sib = k.t.u.node.child;
			k.t.u.node.child = ln;
			t.sib = SNMP_NULL;
		}
		else {
#ifdef MIB_VERBOSE
			printf("MIB: high split\n");
#endif
			t.sib = ln;
		}
		_mib_put_node(&k.t, k.index);
		_mib_put_node(&t, kt);
		f.parent = k.index;	// Parent of inserted node is node which was split
		// Re-use t buffer now to iterate through original children of k.t, reparenting them.
		sib = t.u.node.child;
		while (sib != SNMP_NULL) {
			_mib_get_node(&t, sib);
			t.parent = kt;
			_mib_put_node(&t, sib);
			sib = t.sib;
		}
	}
	else if (_mib.Root != SNMP_NULL) {
		f.parent = k.t.parent;
		if (k.index != SNMP_NULL) {
			f.sib = k.t.sib;
			k.t.sib = ln;
			_mib_put_node(&k.t, k.index);	// Update prev sibling
		}
		else {
			if (k.t.parent != SNMP_NULL) {
				_mib_get_node(&par, k.t.parent);
				f.sib = par.u.node.child;
				par.u.node.child = ln;
				_mib_put_node(&par, k.t.parent);
			}
			else {
				f.sib = _mib.Root;
				_mib.Root = ln;
			}
		}
	}
	else {
		f.parent = SNMP_NULL;
		f.sib = SNMP_NULL;
		_mib.Root = ln;
	}
	_mib_put_node(&f, ln);
	return parms;
}



/*** BeginHeader _mib_find_sib */
word _mib_find_sib(mib_cursor * c);
/*** EndHeader */

_mib_nodebug word _mib_find_sib(mib_cursor * c)
{
	// Scanning right from c->index and its siblings, find the node/leaf whose oid fragment
	// has a non-null initial match with the specified oid fragment (c->s_offs into c->s_oid).
	// Updates c->index with the matching node index if found. c->s_offs and c->n_offs are updated
	// ready for deeper search.  Returns one of the MIB_* defines documented with mib_cursor,
	// or zero if no initial match.  If there is no match, then c->index will be set to point to
	// the sibling after which an insertion should be made, or may be SNMP_NULL if the insertion
	// would need to be before the first node specified.
	// On return, c->prevsib is the index of the sibling which points to c->index, or
	// SNMP_NULL if c->index is a first child.
	auto word prev_sib;
	auto char * p, * q;
	auto oidlevel s1;		// First level of search OID
	auto int sm;			// Search OID has more than 1 level
	auto word s1_len;		// Length of 1st search level
	auto word rc;			// Return value
	auto word ln, ls;		// Remaining length of fragments
	auto word lc;			// Length of matching comparison
	auto int cr;			// Comparison result

#ifdef MIB_DEBUG
	// Check preconditions.
	if (c->index == SNMP_NULL)
		printf("_mib_find_sib: null index\n"), exit(1);
	if (c->s_offs >= c->s_oid.len)
		printf("_mib_find_sib: null search frag\n"), exit(1);
#endif

	// s1 is expanded 1st level value from search OID, for matching against leaves.
	s1_len = c->s_offs;
	s1 = _mib_get_level(c->s_oid.oid, &s1_len);
#ifdef MIB_DEBUG
	if (s1_len > c->s_oid.len)
		printf("_mib_find_sib: bad s_oid\n"), exit(1);
#endif
	sm = s1_len < c->s_oid.len;
	p = c->s_oid.oid + c->s_offs;
	if (*p < 0xFE)
		lc = 1;
	else if (*p == 0xFE)
		lc = 4;
	else
		lc = 6;
	ls = c->s_oid.len - c->s_offs - lc;

	rc = 0;
	prev_sib = SNMP_NULL;
	c->n_offs = 0;
	do {
		c->nextsib = c->index;
		_mib_get_node(&c->t, c->index);
		if (_mib_is_leaf(c)) {
			if (s1 == c->t.u.leaf.id) {
				if (sm)
					rc = MIB_MATCH | MIB_S_OFLO | MIB_N_MATCH;
				else
					rc = MIB_MATCH | MIB_S_MATCH | MIB_N_MATCH;
				c->n_offs = lc;
				c->s_offs += lc;
				break;
			}
			if (s1 < c->t.u.leaf.id) {
				c->n_offs = 0;
				break;
			}
		}
		else {
			// Compare OID fragments
			q = c->t.u.node.oid;
			cr = memcmp(p, q, lc);
			if (cr < 0)
				break;
			if (!cr) {
				// We have found a definite partial match.  Extend the match to
				// maximum extent.
				ln = c->t.u.node.len - lc;
				for (;;) {
					p += lc;
					q += lc;
					if (*p < 0xFE)
						lc = 1;
					else if (*p == 0xFE)
						lc = 4;
					else
						lc = 6;
					if (lc > ln || lc > ls || (cr = memcmp(p, q, lc)))
						break;
					ln -= lc;
					ls -= lc;
				}
				c->n_offs = q - c->t.u.node.oid;
				c->s_offs = p - c->s_oid.oid;
				rc = MIB_MATCH;
				if (c->s_offs == c->s_oid.len)
					rc |= MIB_S_MATCH;
				if (c->n_offs == c->t.u.node.len)
					rc |= MIB_N_MATCH;
				if (cr < 0)
					rc |= MIB_S_LOW;
				break;
			}
		}
		prev_sib = c->index;
		c->index = c->t.sib;
	} while (c->index != SNMP_NULL);

	c->prevsib = prev_sib;
	if (!rc) {
		c->index = prev_sib;
		if (prev_sib != SNMP_NULL)
			_mib_get_node(&c->t, prev_sib);
	}

	return rc;
}



/*** BeginHeader _mib_find */
word _mib_find(mib_cursor * c);
/*** EndHeader */

_mib_nodebug word _mib_find(mib_cursor * c)
{
	// This extends _mib_find_sib to complete the search by descending the tree until there is a
	// complete match of the search OID, or it is determined that the search OID does not exist
	// in the tree.  The point of divergence is indicated in the cursor on return.  Return values
	// as per _mib_find_sib.  If the search OID is complete, but the node is not a leaf, then
	// sets MIB_NOT_LEAF in the return code.
	auto word rc;

	if (c->index == SNMP_NULL)
		return 0;
	for (;;) {
		rc = _mib_find_sib(c);
		if (rc & MIB_S_MATCH) {
			if (!_mib_is_leaf(c))
				rc |= MIB_NOT_LEAF;
			return rc;
		}
		if (!rc || !(rc & MIB_N_MATCH) || rc & MIB_S_OFLO)	// Not found, or node partially matched, or overflow on leaf
			return rc;
		// Fully matched node, but not completed search - keep descending
		c->index = c->t.u.node.child;
	}
}


/*** BeginHeader _mib_get_node */
void _mib_get_node(mib_tree * t, word index);
/*** EndHeader */

_mib_nodebug void _mib_get_node(mib_tree * t, word index)
{
	// Copy the node index to t
	xmem2root(t, _mib.buf + sizeof(mib_tree) * (long)index, sizeof(mib_tree));
}



/*** BeginHeader _mib_put_node */
void _mib_put_node(mib_tree * t, word index);
/*** EndHeader */

_mib_nodebug void _mib_put_node(mib_tree * t, word index)
{
	// Copy t to the node index
	root2xmem(_mib.buf + sizeof(mib_tree) * (long)index, t, sizeof(mib_tree));
}



/*** BeginHeader _mib_new */
word _mib_new(void);
/*** EndHeader */

_mib_nodebug word _mib_new(void)
{
	auto word rc;
	// Allocate and return next free node index, of SNMP_NULL if none.
	if (_mib.free == SNMP_NULL) {
#ifdef MIB_VERBOSE
		printf("MIB: table full\n");
#endif
		return SNMP_NULL;
	}
	rc = _mib.free;
	_mib.free = _mib_get_sib(_mib.free);
	_mib.freecount--;
#ifdef MIB_VERBOSE
	printf("MIB: allocated node %u\n", rc);
#endif
	return rc;
}



/*** BeginHeader _mib_freeup */
void _mib_freeup(word index);
/*** EndHeader */

_mib_nodebug void _mib_freeup(word index)
{
	auto word rc;
	// Return given node to free list
	_mib_set_sib(index, _mib.free);
	_mib.free = index;
	_mib.freecount++;
#ifdef MIB_VERBOSE
	printf("MIB: freed node %u\n", index);
#endif
}



/*** BeginHeader _mib_paddr */
void _mib_paddr(void);
/*** EndHeader */

#asm xmem
; Convert HL (mib table index 0..32767) into paddr of table entry in A/IY.  Trashes BC,DE,HL
_mib_paddr::
	ex		de,hl
	ld		bc,MIB_TREE_SIZE
	mul
	; offset now in HLBC
	ex		de,hl
	ld		hl,(_mib)		; LSBs of buffer addr
	add	hl,bc
	ld		iy,hl
	ld		hl,(_mib+2)		; MSBs
	adc	hl,de
	ld		a,L
	lret
#endasm

/*** BeginHeader _mib_set_sib */
void _mib_set_sib(word index, word sib);
/*** EndHeader */
// This must be nodebug since called in global init.
nodebug void _mib_set_sib(word index, word sib)
{
	// Set the sib index of the node at given index
#asm
	; HL contains index
	lcall	_mib_paddr	; Convert HL to physical address of node in A/IY
	ld		hl,(sp+@sp+sib)
	ldp	(iy),hl		; Depends on sib field being at offset 0
#endasm
}



/*** BeginHeader _mib_get_sib */
word _mib_get_sib(word index);
/*** EndHeader */

nodebug word _mib_get_sib(word index)
{
	// Get the sib index of the node at given index
#asm
	; HL contains index
	lcall	_mib_paddr	; Convert HL to physical address of node in A/IY
	ldp	hl,(iy)		; Depends on sib field being at offset 0
#endasm
}



/*** BeginHeader _mib_is_leaf */
word _mib_is_leaf(mib_cursor * c);
/*** EndHeader */

_mib_nodebug word _mib_is_leaf(mib_cursor * c)
{
	return c->t.u.leaf.flags & MIB_LEAF;
}



/*** BeginHeader _mib_get_level */
oidlevel _mib_get_level(char * eos, word * offs);
/*** EndHeader */

_mib_nodebug oidlevel _mib_get_level(char * eos, word * offs)
{
	eos += *offs;
	if (*eos < 0xFE) {
		(*offs)++;
		return *eos;
	}
	else if (*eos == 0xFE) {
		(*offs) += 4;
		return ((word)eos[1] << 8) + eos[2];
	}
	(*offs) += 6;
	return ((oidlevel)eos[1] << 24) + ((oidlevel)eos[2] << 16) + ((word)eos[3] << 8) + eos[4];
}


/*** BeginHeader _mib_reconstruct_stem */
void _mib_reconstruct_stem(snmp_parms * p);
/*** EndHeader */

_mib_nodebug void _mib_reconstruct_stem(snmp_parms * p)
{
	// Reconstruct the OID in p->stem, given p->index and p->last set to
	// valid leaf values.  Works upwards to root of MIB tree.
	auto snmp_oid oid;
	auto mib_tree t;
	auto char * s;
	auto oidlevel term;
	auto word len;

	term = p->last.u.leaf.id;	// Add this at end
	s = oid.oid + SNMP_MAX_NAME;
	t.parent = p->last.parent;
	len = 0;
	while (t.parent != SNMP_NULL) {
		_mib_get_node(&t, t.parent);
		len += t.u.node.len;
		s -= t.u.node.len;
		memcpy(s, t.u.node.oid, t.u.node.len);
	}
	memcpy(p->stem.oid, s, len);
	p->stem.len = len;
	_mib_append_oid(&p->stem, term);
}






/*** BeginHeader _mib_print_tree */
void _mib_print_tree(word Root, word indent);
/*** EndHeader */

_mib_nodebug void _mib_print_tree(word Root, word indent)
{
	// Recursive function to print part of MIB tree starting with 'root' index.
	// Indent is the current indentation (as number of tab stops).  root is
	// assumed to be non-null on entry.
	static mib_tree t;
	static word offs;
	static int ival;
	static long lval;

	do {
		_mib_get_node(&t, Root);
		for (offs = 0; offs < indent; offs++) printf("   ");
		printf("[%-3u p=%-5u] ", Root, t.parent);
		Root = t.sib;
		if (t.u.leaf.flags & MIB_LEAF) {
			printf("%lu r=%02X w=%02X ", t.u.leaf.id, (word)t.u.leaf.rdmask, (word)t.u.leaf.wrmask);
			if (t.u.leaf.flags & MIB_SAVEABLE)
				printf("saveable ");
			if (t.u.leaf.flags & MIB_FAR)
			switch ((snmp_type)(t.u.leaf.flags & MIB_TYPEMASK)) {
			case SNMP_SHORT:
				xmem2root(&ival, t.u.leaf.v.x, 2);
				printf("[xshort] %d\n", ival);
				break;
			case SNMP_LONG:
				xmem2root(&lval, t.u.leaf.v.x, 4);
				printf("[xlong] %ld\n", lval);
				break;
			case SNMP_STR:
				printf("[xstr <= %d]\n", t.u.leaf.maxlen);
				break;
			case SNMP_OCT:
				printf("[xoct <= %d]\n", t.u.leaf.maxlen);
				break;
			case SNMP_FOCT:
				printf("[xfoct == %d]\n", t.u.leaf.maxlen);
				break;
			case SNMP_OID:
				printf("[xoid]\n");
				break;
			default:
				printf("[unknown xmem type %u]\n", t.u.leaf.flags & MIB_TYPEMASK);
			}
			else
			switch ((snmp_type)(t.u.leaf.flags & MIB_TYPEMASK)) {
			case SNMP_SHORT:
				printf("[short] %d\n", *t.u.leaf.v.i);
				break;
			case SNMP_LONG:
				printf("[long] %ld\n", *t.u.leaf.v.L);
				break;
			case SNMP_STR:
				printf("[str <= %d] \"%s\"\n", t.u.leaf.maxlen, t.u.leaf.v.s);
				break;
			case SNMP_OCT:
				printf("[oct <= %d]\n", t.u.leaf.maxlen);
				break;
			case SNMP_FOCT:
				printf("[foct == %d]\n", t.u.leaf.maxlen);
				break;
			case SNMP_OID:
				printf("[oid] %s\n", snmp_format_oid(t.u.leaf.v.o));
				break;
			default:
				printf("[unknown type %u]\n", t.u.leaf.flags & MIB_TYPEMASK);
			}
		}
		else {
			for (offs = 0; offs < t.u.node.len; )
				printf("%lu.", _mib_get_level(t.u.node.oid, &offs));
			printf("\n");
			if (t.u.node.child != SNMP_NULL)
				// Tail recursion trashes current 't', but OK since we saved sibling in 'Root'
				_mib_print_tree(t.u.node.child, indent+1);
		}
	} while (Root != SNMP_NULL);
}



/*** BeginHeader snmp_init_parms */
snmp_parms * snmp_init_parms(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_init_parms									<MIB.LIB>

SYNTAX: snmp_parms * snmp_init_parms(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Initialize the parameter structure p.  This is used to
               set *p to a known state prior to calling other functions
               in the MIB group.  If p is not NULL, it is set to all
               binary zeros.  The initial OID stem is then set to
               "43.6.1.4.1" or, if SNMP_ENTERPRISE is defined, it is
               set to "43.6.1.4.1.SNMP_ENTERPRISE".  Note that the
               leading "43" is the standard compression of "1.3".
               The current read and write masks are set to SNMP_DEFAULT_
               READMASK and SNMP_DEFAULT_WRITEMASK respectively.  The
               current index is set to "null".

PARAMETER1:    Pointer to parameter structure to initialize.  If NULL,
               does nothing but return NULL.

RETURN VALUE:  Always returns p.
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_init_parms(snmp_parms * p)
{
	if (!p)
		return NULL;
	memset(p, 0, sizeof(snmp_parms));
	snmp_set_stem(p, 5, "\x2B\006\001\004\001");
#ifdef SNMP_ENTERPRISE
	_mib_append_oid((snmp_oid *)p, SNMP_ENTERPRISE);
#endif
	p->rdmask = SNMP_DFLT_READMASK;
	p->wrmask = SNMP_DFLT_WRITEMASK;
	p->index = SNMP_NULL;
	return p;
}



/*** BeginHeader snmp_set_stem */
snmp_parms * snmp_set_stem(snmp_parms * p, word len, char * eos);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_stem									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_stem(snmp_parms * p, word len, char * eos)

KEYWORDS:      snmp, mib

DESCRIPTION:   If p is not NULL, the OID stem is set to the encoded OID
               string specified by eos (with length len).  eos must be
               a fully qualified OID, encoded using the internal
               representation (RLER).  RLER encoding is performed as
               follows: each OID level is an unsigned number between 0
               and 2**32-1 inclusive.  Reading from left to right, each
               level is encoded and written left to right.  If the level
               is less than 254, it is written as a single byte with that
               value.  Otherwise, if it is less than 65536, it is written
               as 0xFE yy zz 0xFE where yy is the MSB of the 16-bit value
               and zz is the LSB.  Otherwise the number is >= 65536 and
               it is written as 6 bytes: 0xFF ww xx yy zz 0xFF where
               ww is the MSB of the 32-bit number and zz is the LSB.
               The total length of the constructed string is passed in
               len.

               Note that there are other functions which provide easier
               ways of setting the object ID in the parameter structure.

               This function, and related functions, serve the purpose of
               setting the "current object identifier" in the parameter
               structure.  This is necessary for other functions, such
               as snmp_add_int(), which need to know the applicable object
               identifier.

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Length of eos.
PARAMETER3:    Encoded OID string.

RETURN VALUE:  Returns p unless the OID string is too long to fit in the
               parameter structure in which case NULL is returned.  If
               p is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_append_stem, snmp_set_parse_stem,
               snmp_set_oid
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_stem(snmp_parms * p, word len, char * eos)
{
	if (!p)
		return NULL;
	p->stem.len = 0;
	return (snmp_parms *)_mib_cat_oid((snmp_oid *)p, len, eos);
}



/*** BeginHeader snmp_set_oid */
snmp_oid * snmp_set_oid(snmp_oid * oid, word len, char * eos);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_oid									<MIB.LIB>

SYNTAX: snmp_oid * snmp_set_oid(snmp_oid * oid, word len, char * eos)

KEYWORDS:      snmp, mib

DESCRIPTION:   This function is identical to snmp_set_stem, except that
               it uses an snmp_oid structure.  See documentation for
               snmp_set_stem().

PARAMETER1:    Pointer to snmp_oid structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Length of eos.
PARAMETER3:    Encoded OID string.

RETURN VALUE:  Returns oid unless the OID string is too long to fit in the
               snmp_oid structure in which case NULL is returned.  If
               oid is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_append_oid, snmp_set_parse_oid,
               snmp_set_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_oid * snmp_set_oid(snmp_oid * oid, word len, char * eos)
{
	if (!oid)
		return NULL;
	oid->len = 0;
	return _mib_cat_oid(oid, len, eos);
}



/*** BeginHeader snmp_append_stem */
snmp_parms * snmp_append_stem(snmp_parms * p, word len, char * eos);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_append_stem									<MIB.LIB>

SYNTAX: snmp_parms * snmp_append_stem(snmp_parms * p, word len,
                                      char * eos)

KEYWORDS:      snmp, mib

DESCRIPTION:   Appends the encoded object identifier string to the OID
               already set in *p.  See snmp_set_stem() for a description
               of OID encoding.  This function is identical except that
               it appends rather than replaces the OID.

PARAMETER1:    Pointer to parameter structure to append to.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Length of eos.
PARAMETER3:    Encoded OID string.

RETURN VALUE:  Returns p unless the OID string is too long to fit in the
               parameter structure in which case NULL is returned.  If
               p is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_parse_stem,
               snmp_append_oid
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_append_stem(snmp_parms * p, word len, char * eos)
{
	return (snmp_parms *)_mib_cat_oid((snmp_oid *)p, len, eos);
}



/*** BeginHeader snmp_append_oid */
snmp_oid * snmp_append_oid(snmp_oid * oid, word len, char * eos);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_append_oid									<MIB.LIB>

SYNTAX: snmp_oid * snmp_append_oid(snmp_oid * oid, word len, char * eos)

KEYWORDS:      snmp, mib

DESCRIPTION:   This function is identical to snmp_append_stem, except that
               it uses an snmp_oid structure.  See documentation for
               snmp_set_stem() for explanation of OID encoding.

PARAMETER1:    Pointer to snmp_oid structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Length of eos.
PARAMETER3:    Encoded OID string.

RETURN VALUE:  Returns oid unless the OID string is too long to fit in the
               snmp_oid structure in which case NULL is returned.  If
               oid is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_set_oid, snmp_append_parse_oid,
               snmp_append_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_oid * snmp_append_oid(snmp_oid * oid, word len, char * eos)
{
	return _mib_cat_oid(oid, len, eos);
}



/*** BeginHeader snmp_set_parse_stem */
snmp_parms * snmp_set_parse_stem(snmp_parms * p, char * name);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_parse_stem									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_parse_stem(snmp_parms * p, char * name)

KEYWORDS:      snmp, mib

DESCRIPTION:   If p is not NULL, set the OID stem in *p to the OID
               expressed in dotted decimal notation in name.  This
               function is easier to use than snmp_set_stem, but has the
               disadvantage of being less efficient.  Apart from the
               method of expressing the OID, the semantics are identical
               to snmp_set_stem().

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    OID string in dotted decimal notation e.g. "43.6.1".

RETURN VALUE:  Returns p unless the OID string is too long to fit in the
               parameter structure in which case NULL is returned.  If
               p is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_set_parse_oid
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_parse_stem(snmp_parms * p, char * name)
{
	return (snmp_parms *)_mib_parse_oid((snmp_oid *)p, name, 0);
}



/*** BeginHeader snmp_set_parse_oid */
snmp_oid * snmp_set_parse_oid(snmp_oid * oid, char * name);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_parse_oid									<MIB.LIB>

SYNTAX: snmp_oid * snmp_set_parse_oid(snmp_oid * oid, char * name)

KEYWORDS:      snmp, mib

DESCRIPTION:   This function is identical to snmp_set_parse_stem, except
               that it uses an snmp_oid structure.  See documentation for
               snmp_set_parse_stem().

PARAMETER1:    Pointer to snmp_oid structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    OID string in dotted decimal notation e.g. "43.6.1".

RETURN VALUE:  Returns oid unless the OID string is too long to fit in the
               snmp_oid structure in which case NULL is returned.  If
               oid is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_append_oid, snmp_set_parse_stem,
               snmp_set_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_oid * snmp_set_parse_oid(snmp_oid * oid, char * name)
{
	return _mib_parse_oid(oid, name, 0);
}



/*** BeginHeader snmp_append_parse_stem */
snmp_parms * snmp_append_parse_stem(snmp_parms * p, char * name);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_append_parse_stem									<MIB.LIB>

SYNTAX: snmp_parms * snmp_append_parse_stem(snmp_parms * p, char * name)

KEYWORDS:      snmp, mib

DESCRIPTION:   Appends the specified OID string, expressed in dotted
               decimal format, to the OID currently set in the parameter
               structure.

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    OID string in dotted decimal notation e.g. "7.5.99".

RETURN VALUE:  Returns p unless the OID string is too long to fit in the
               parameter structure in which case NULL is returned.  If
               p is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_set_parse_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_append_parse_stem(snmp_parms * p, char * name)
{
	return (snmp_parms *)_mib_parse_oid((snmp_oid *)p, name, 1);
}



/*** BeginHeader snmp_append_parse_oid */
snmp_oid * snmp_append_parse_oid(snmp_oid * oid, char * name);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_append_parse_oid									<MIB.LIB>

SYNTAX: snmp_oid * snmp_append_parse_oid(snmp_oid * oid, char * name)

KEYWORDS:      snmp, mib

DESCRIPTION:   This function is identical to snmp_append_parse_stem,
               except that it uses an snmp_oid structure.  See
               documentation for snmp_append_parse_stem().

PARAMETER1:    Pointer to snmp_oid structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    OID string in dotted decimal notation e.g. "7.5.99".

RETURN VALUE:  Returns oid unless the OID string is too long to fit in the
               snmp_oid structure in which case NULL is returned.  If
               oid is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_append_oid, snmp_append_parse_stem,
               snmp_set_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_oid * snmp_append_parse_oid(snmp_oid * oid, char * name)
{
	return _mib_parse_oid(oid, name, 1);
}



/*** BeginHeader snmp_append_binary_stem */
snmp_parms * snmp_append_binary_stem(snmp_parms * p, word len, char * bname);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_append_binary_stem									<MIB.LIB>

SYNTAX: snmp_parms * snmp_append_binary_stem(snmp_parms * p, word len,
                                             char * bname)

KEYWORDS:      snmp, mib

DESCRIPTION:   Append the object ID encoded as a string of bytes to the
               OID currently set in *p.  This function may be used when
               all levels in the OID string are numbers between 0 and
               255 inclusive.  Each OID level is simply the binary value
               of each byte pointed to by bname.  The number of levels
               (i.e. bytes) is specified by len.  For example, to append
               "255.6.0.1" call this function using
                 snmp_append_binary_stem(p, 4, "\xFF\x06\x00\x01");

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Number of bytes in bname.
PARAMETER3:    Pointer to first byte of OID.

RETURN VALUE:  Returns p unless the OID string is too long to fit in the
               parameter structure in which case NULL is returned.  If
               p is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_append_oid, snmp_append_parse_stem,
               snmp_set_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_append_binary_stem(snmp_parms * p, word len, char * bname)
{
	return (snmp_parms *)_mib_binary_oid((snmp_oid *)p, len, bname, 1);
}



/*** BeginHeader snmp_append_binary_oid */
snmp_oid * snmp_append_binary_oid(snmp_oid * oid, word len, char * bname);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_append_binary_oid									<MIB.LIB>

SYNTAX: snmp_oid * snmp_append_binary_oid(snmp_oid * oid, word len,
                                          char * bname)

KEYWORDS:      snmp, mib

DESCRIPTION:   This function is identical to snmp_append_binary_stem,
               except that it uses an snmp_oid structure.  See
               documentation for snmp_append_binary_stem().

PARAMETER1:    Pointer to snmp_oid structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Number of bytes in bname.
PARAMETER3:    Pointer to first byte of OID.

RETURN VALUE:  Returns oid unless the OID string is too long to fit in the
               snmp_oid structure in which case NULL is returned.  If
               oid is NULL on entry, then nothing is done except to return
               NULL.

SEE ALSO:      snmp_init_parms, snmp_append_oid, snmp_append_binary_stem,
               snmp_set_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_oid * snmp_append_binary_oid(snmp_oid * oid, word len, char * bname)
{
	return _mib_binary_oid(oid, len, bname, 1);
}



/*** BeginHeader snmp_up_stem */
snmp_parms * snmp_up_stem(snmp_parms * p, word levels);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_up_stem									<MIB.LIB>

SYNTAX: snmp_parms * snmp_up_stem(snmp_parms * p, word levels)

KEYWORDS:      snmp, mib

DESCRIPTION:   Truncate the last n levels in the OID currently set in *p.
               This move "up" towards the first level in the OID.

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Number of levels to truncate on right of current OID.  If
               this is greater than the current number of levels, the
               OID is set to empty.

RETURN VALUE:  Returns p unless p is NULL on entry, then nothing is done
               except to return NULL.

SEE ALSO:      snmp_init_parms, snmp_set_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_up_stem(snmp_parms * p, word levels)
{
	return (snmp_parms *)_mib_up((snmp_oid *)p, levels);
}



/*** BeginHeader snmp_up_oid */
snmp_oid * snmp_up_oid(snmp_oid * oid, word levels);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_up_oid									<MIB.LIB>

SYNTAX: snmp_oid * snmp_up_oid(snmp_oid * oid, word levels)

KEYWORDS:      snmp, mib

DESCRIPTION:   This function is identical to snmp_up_stem,
               except that it uses an snmp_oid structure.  See
               documentation for snmp_up_stem().

PARAMETER1:    Pointer to snmp_oid structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Number of levels to truncate on right of current OID.  If
               this is greater than the current number of levels, the
               OID is set to empty.

RETURN VALUE:  Returns oid unless NULL on entry, then nothing is done
               except to return NULL.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_up_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_oid * snmp_up_oid(snmp_oid * oid, word levels)
{
	return _mib_up(oid, levels);
}



/*** BeginHeader snmp_set_access */
snmp_parms * snmp_set_access(snmp_parms * p, byte rm, byte wm);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_access									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_access(snmp_parms * p, byte rm, byte wm)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the read and write masks for access control of the
               next object to be added.  Read/write masks are only
               applicable if SNMP is used.  The functions in this library
               for accessing objects do not apply the access masks.
               This remains in effect for all further additions until
               changed by a new call to snmp_set_access().

               The rm and wm are bit 8-bit bitmasks.  A bit "n" is set
               if the communities whose access mask have the "n"th bit
               set are is allowed to access the object in that mode (read
               or write).  By default, bit 0 is set for the PUBLIC
               community's access mask and bit 1 is set for the
               PRIVATE community.  Typically, objects are created with
               rm = 3 and wm = 2, giving both public and private read
               access, but only private has write access.

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Read access mask.
PARAMETER3:    Write access mask.

RETURN VALUE:  Returns p unless p is NULL on entry, then nothing is done
               except to return NULL.

SEE ALSO:      snmp_init_parms
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_access(snmp_parms * p, byte rm, byte wm)
{
	if (!p)
		return NULL;
	p->rdmask = rm;
	p->wrmask = wm;
	return p;
}



/*** BeginHeader snmp_set_callback */
snmp_parms * snmp_set_callback(snmp_parms * p, snmp_callback cb);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_callback									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_callback(snmp_parms * p, snmp_callback cb)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the callback function for the next object to be added.
               This remains in effect for all further additions until
               cancelled by passing NULL for the callback function.

               Use of the callback function is described in the
               printed documentation.  It is only applicable is SNMP
               is being used.  The functions in MIB.LIB do not invoke
               the callback.

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Pointer to callback function, or NULL to cancel.

RETURN VALUE:  Returns p unless p is NULL on entry, then nothing is done
               except to return NULL.

SEE ALSO:      snmp_init_parms
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_callback(snmp_parms * p, snmp_callback cb)
{
	if (!p)
		return NULL;
	p->fn = cb;
	return p;
}



/*** BeginHeader snmp_set_save */
snmp_parms * snmp_set_save(snmp_parms * p, int save);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_save									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_save(snmp_parms * p, int save)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the save flag for the next object to be added.
               This remains in effect for all further additions until
               cancelled by passing NULL for the callback function.

               Currently, this has no effect.  It is intended for
               future enhancements that will allow saving the current
               MIB tree to non-volatile storage.

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Boolean value: zero to cancel save-flag, non-zero to
               enable it.

RETURN VALUE:  Returns p unless p is NULL on entry, then nothing is done
               except to return NULL.

SEE ALSO:      snmp_init_parms
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_save(snmp_parms * p, int save)
{
	if (!p)
		return NULL;
	if (save)
		p->flags |= MIB_SAVEABLE;
	else
		p->flags &= ~MIB_SAVEABLE;
	return p;
}



/*** BeginHeader snmp_add */
snmp_parms * snmp_add(snmp_parms * p, char * n, word type, void * v, word maxlen);

#define snmp_add_int(p,n,i) snmp_add(p, n, SNMP_INTEGER_AS_SHORT, i, 2)
#define snmp_add_uint(p,n,i) snmp_add(p, n, SNMP_GAUGE_AS_SHORT, i, 2)
#define snmp_add_long(p,n,i) snmp_add(p, n, SNMP_INTEGER_AS_LONG, i, 4)
#define snmp_add_ipaddr(p,n,i) snmp_add(p, n, SNMP_IPADDR_AS_LONG, i, 4)
#define snmp_add_timeticks(p,n,i) snmp_add(p, n, SNMP_TIMETICKS, i, 4)
#define snmp_add_ulong(p,n,i) snmp_add(p, n, SNMP_GAUGE_AS_LONG, i, 4)
#define snmp_add_str(p,n,s,m) snmp_add(p, n, SNMP_ASCIISTR, s, m)
#define snmp_add_oct(p,n,s,m) snmp_add(p, n, SNMP_OCTETSTR_VARIABLE, s, m)
#define snmp_add_foct(p,n,s,m) snmp_add(p, n, SNMP_OCTETSTR_FIXED, s, m)
#define snmp_add_objectID(p,n,s) snmp_add(p, n, SNMP_OBJECT_ID, s, sizeof(snmp_oid))

/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_add									<MIB.LIB>

SYNTAX: snmp_parms * snmp_add(snmp_parms * p, char * n, word type,
                              void * v, word maxlen)

KEYWORDS:      snmp, mib

DESCRIPTION:   Add an object into the MIB tree.  The parameter structure
               *p must be set up using snmp_init_parms() and other
               functions such as snmp_set_stem() to indicate the object
               ID of the object to be added.

               This function is used to add objects which reside in root
               data storage.  The object must persist at the specified
               location (v) at least until the object is deleted using
               snmp_delete().

               Typically, the object may already exist in some pre-
               existing application (e.g. as a field in some structure).
               The object may be used exactly as an ordinary variable
               or field, except that its value may change whenever
               tcp_tick() is called and there happens to have been an
               SNMP SET request on that object.  If SNMP is not being
               used, the object will not be modified by any of the
               MIB.LIB functions.

               snmp_add() and snmp_xadd() are the most general functions.
               Cleaner code can result from using the equivalent macro
               invocations.  There are 10 macro invocations of snmp_add
               and snmp_xadd.  The macros ensure that the correct type
               and length parameters are passed.  The macros are:
                  snmp_add_int(p,n,i)
                  snmp_add_uint(p,n,i)
                  snmp_add_long(p,n,i)
                  snmp_add_ipaddr(p,n,i)
                  snmp_add_timeticks(p,n,i)
                  snmp_add_ulong(p,n,i)
                  snmp_add_str(p,n,s,m)
                  snmp_add_oct(p,n,s,m)
                  snmp_add_foct(p,n,s,m)
                  snmp_add_objectID(p,n,s)
               where parameters p and n are as for this function; i is
               an integer or long integer address; s is a char *; and
               m is a maximum length.

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Optional extra OID level(s) to temporarily append to the
               OID in *p.  If NULL, this is not done.  Otherwise, the
               levels are appended; the value added; then the extra
               levels removed.
PARAMETER3:    Type of value to add.  This is a composite of the internal
               type (indicating the memory layout) and the type visible
               to SNMP agents.  The possible composite types are selected
               from the following list:
                 SNMP_INTEGER_AS_SHORT   (SNMP_P_INTEGER<<4 | SNMP_SHORT)
                 SNMP_INTEGER_AS_LONG    (SNMP_P_INTEGER<<4 | SNMP_LONG)
                 SNMP_INTEGER             = SNMP_INTEGER_AS_LONG
                 SNMP_OCTETSTR_VARIABLE  (SNMP_P_OCTETSTR<<4 | SNMP_OCT)
                 SNMP_OCTETSTR_NULLTERM  (SNMP_P_OCTETSTR<<4 | SNMP_STR)
                 SNMP_ASCIISTR            = SNMP_OCTETSTR_NULLTERM
                 SNMP_OCTETSTR_FIXED     (SNMP_P_OCTETSTR<<4 | SNMP_FOCT)
                 SNMP_OBJECT_ID          (SNMP_P_OID<<4 | SNMP_OID)
                 SNMP_IPADDR_AS_OCT      (SNMP_P_IPADDR<<4 | SNMP_FOCT)
                 SNMP_IPADDR_AS_LONG     (SNMP_P_IPADDR<<4 | SNMP_LONG)
                 SNMP_COUNTER_AS_SHORT   (SNMP_P_COUNTER<<4 | SNMP_SHORT)
                 SNMP_COUNTER_AS_LONG    (SNMP_P_COUNTER<<4 | SNMP_LONG)
                 SNMP_COUNTER             = SNMP_COUNTER_AS_LONG
                 SNMP_GAUGE_AS_SHORT     (SNMP_P_GAUGE<<4 | SNMP_SHORT)
                 SNMP_GAUGE_AS_LONG      (SNMP_P_GAUGE<<4 | SNMP_LONG)
                 SNMP_GAUGE               = SNMP_GAUGE_AS_LONG
                 SNMP_TIMETICKS          (SNMP_P_TIMETICKS<<4 | SNMP_LONG)
PARAMETER4:    Pointer to the actual object in root data storage.  This
               storage becomes managed by SNMP/MIB, which is why it must
               be static.  To alter the value of the object, it is
               permissible (in fact recommended) to simply update the
               object directly.  Note that it is this pointer value
               which is stored in the MIB tree, not a copy of the
               object.  Note that variable-length octet strings are
               stored in a special format: the 1st two bytes of the
               location are used to store the current length.  The
               specified maximum length includes the length of this
               2-byte prefix.  The actual length of the object can
               thus be no more than the max length - 2.
PARAMETER5:    Maximum permissible length of the object.  This is
               applicable to variable length objects, since SNMP needs
               to know the allowable size bounds for the object to avoid
               overwriting past the end of the allocated space for the
               object.

RETURN VALUE:  Returns p unless p is NULL on entry, then nothing is done
               except to return NULL.  May also return NULL if the
               additional OID name level(s), if any, could not be
               appended to the current stem in p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_set_parse_stem,
               snmp_append_stem, snmp_append_parse_stem, snmp_set_access,
               snmp_set_callback, snmp_up_stem, snmp_xadd, snmp_delete,
               snmp_get, snmp_last_index
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_add(snmp_parms * p, char * n, word type, void * v, word maxlen)
{
	auto snmp_parms * _p;
	auto word oidlen;

	if (!p)
		return NULL;
	if (n) {
		oidlen = p->stem.len;
		if (!snmp_append_parse_stem(p, n))
			return NULL;
	}
	p->type = type & (MIB_TYPEMASK | MIB_SNMPMASK);
	p->flags &= ~MIB_FAR;
	p->u.s = (char *)v;
	p->maxlen = maxlen;
	_p = _mib_insert(p);
	if (n)
		p->stem.len = oidlen;
	return _p;
}



/*** BeginHeader snmp_xadd */
snmp_parms * snmp_xadd(snmp_parms * p, char * n, word type, long xs, word maxlen);

#define snmp_add_xint(p,n,i) snmp_xadd(p, n, SNMP_INTEGER_AS_SHORT, i, 2)
#define snmp_add_xuint(p,n,i) snmp_xadd(p, n, SNMP_GAUGE_AS_SHORT, i, 2)
#define snmp_add_xlong(p,n,i) snmp_xadd(p, n, SNMP_INTEGER_AS_LONG, i, 4)
#define snmp_add_xipaddr(p,n,i) snmp_xadd(p, n, SNMP_IPADDR_AS_LONG, i, 4)
#define snmp_add_xtimeticks(p,n,i) snmp_xadd(p, n, SNMP_TIMETICKS, i, 4)
#define snmp_add_xulong(p,n,i) snmp_xadd(p, n, SNMP_GAUGE_AS_LONG, i, 4)
#define snmp_add_xstr(p,n,s,m) snmp_xadd(p, n, SNMP_ASCIISTR, s, m)
#define snmp_add_xoct(p,n,s,m) snmp_xadd(p, n, SNMP_OCTETSTR_VARIABLE, s, m)
#define snmp_add_xfoct(p,n,s,m) snmp_xadd(p, n, SNMP_OCTETSTR_FIXED, s, m)
#define snmp_add_xobjectID(p,n,s) snmp_xadd(p, n, SNMP_OBJECT_ID, s, sizeof(snmp_oid))

/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_xadd									<MIB.LIB>

SYNTAX: snmp_parms * snmp_xadd(snmp_parms * p, char * n, word type,
                               long xs, word maxlen)

KEYWORDS:      snmp, mib

DESCRIPTION:   This function is identical to snmp_add(), except that the
               object resides in xmem storage.  Instead of a void *
               address, an xmem (20-bit linear) address is stored.

               In common with snmp_add(), there is also a set of
               macros, the use of which may result in cleaner code.
               The macro names are identical to those for snmp_add,
               except that the names all start with "snmp_add_x"
               e.g. snmp_add_xint, snmp_add_xulong etc.

PARAMETER1:    Pointer to parameter structure to set.  If NULL,
               does nothing but return NULL.
PARAMETER2:    Optional extra OID level(s) to temporarily append to the
               OID in *p.  If NULL, this is not done.  Otherwise, the
               levels are appended; the value added; then the extra
               levels removed.
PARAMETER3:    Type of value to add.  See description in snmp_add().
PARAMETER4:    xmem address of the actual object in xmem data storage.
               The same considerations apply to this address as they do
               for the near pointers used by snmp_add().
PARAMETER5:    Maximum permissible length of the object.

RETURN VALUE:  Returns p unless p is NULL on entry, then nothing is done
               except to return NULL.  May also return NULL if the
               additional OID name level(s), if any, could not be
               appended to the current stem in p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_set_parse_stem,
               snmp_append_stem, snmp_append_parse_stem, snmp_set_access,
               snmp_set_callback, snmp_up_stem, snmp_add, snmp_delete,
               snmp_get, snmp_last_index
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_xadd(snmp_parms * p, char * n, word type, long xs, word maxlen)
{
	auto snmp_parms * _p;
	auto word oidlen;

	if (!p)
		return NULL;
	if (n) {
		oidlen = p->stem.len;
		if (!snmp_append_parse_stem(p, n))
			return NULL;
	}
	p->type = type & (MIB_TYPEMASK | MIB_SNMPMASK);
	p->flags |= MIB_FAR;
	p->u.x = xs;
	p->maxlen = maxlen;
	_p = _mib_insert(p);
	if (n)
		p->stem.len = oidlen;
	return _p;
}



/*** BeginHeader snmp_delete */
snmp_parms * snmp_delete(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_delete									<MIB.LIB>

SYNTAX: snmp_parms * snmp_delete(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Delete a node, or a subtree, of the MIB tree.  The
               object ID to delete is specified in *p.  All objects whose
               OID has a complete initial match with the specified OID
               will be deleted.

               Note that the indices which may have been retrieved for
               a deleted object will no longer be valid.

PARAMETER1:    Pointer to parameter structure whose stem is set up with
               the OID to delete.  If NULL, does nothing but return NULL.

RETURN VALUE:  Returns p unless p is NULL on entry, then nothing is done
               except to return NULL.  If no objects were deleted, then
               also returns NULL.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_set_parse_stem,
               snmp_append_stem, snmp_append_parse_stem, snmp_up_stem,
               snmp_add, snmp_xadd, snmp_last_index
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_delete(snmp_parms * p)
{
	// Delete the subtree starting at parms->oid.  If this happens to leave the
	// parent node with no children, the parent node is deleted.  This is repeated
	// up the tree towards the root.  A partial match in a non-leaf node is treated
	// as matching the entire node.
	auto mib_cursor k;
	auto mib_tree t;
	auto word d, rc;

	if (!p) return NULL;

	k.index = _mib.Root;
	k.s_offs = 0;
	memcpy(&k.s_oid, &p->stem, sizeof(snmp_oid));
	rc = _mib_find(&k);
	if (!(rc & MIB_S_MATCH) || rc & MIB_S_OFLO)
		return NULL;

	// Delete the children of node which was located.  We use iterative, not recursive,
	// algo.
	if (!_mib_is_leaf(&k) && (d = k.t.u.node.child) != SNMP_NULL) {
		// Loop until we return to the deleted subtree root...
		while (d != k.index) {
			_mib_get_node(&t, d);
			if (!(t.u.leaf.flags & MIB_LEAF) && t.u.node.child != SNMP_NULL)
				// Descend to children first
				d = t.u.node.child;
			else {
				_mib_freeup(d);
				d = t.sib;
				while (d == SNMP_NULL && d != k.index) {
					// Finished all children at this level.  Delete the parent and
					// move to parent's next sibling.
					d = t.parent;
					if (d != k.index) {
						_mib_get_node(&t, d);
						_mib_freeup(d);
						d = t.sib;
					}
				}
			}
		}
	}

	// While current node is an only-child, delete it then consider the parent similarly.
	while (k.t.sib == SNMP_NULL && k.prevsib == SNMP_NULL && k.t.parent != SNMP_NULL) {
		_mib_freeup(k.index);
		d = k.t.parent;
		_mib_get_node(&k.t, d);
		k.index = d;
		if (k.t.parent != SNMP_NULL) {
			_mib_get_node(&t, k.t.parent);
			d = t.u.node.child;
		}
		else
			d = _mib.Root;
		k.prevsib = SNMP_NULL;
		while (d != k.index) {
			k.prevsib = d;
			d = _mib_get_sib(d);
		}
	}

	// Now delete node, and fix up pointers.
	_mib_freeup(k.index);
	if (k.prevsib != SNMP_NULL) {
		_mib_get_node(&t, k.prevsib);
		t.sib = k.t.sib;
		_mib_put_node(&t, k.prevsib);
	}
	else {
		if (k.t.parent != SNMP_NULL) {
			_mib_get_node(&t, k.t.parent);
			t.u.node.child = k.t.sib;
			_mib_put_node(&t, k.t.parent);
		}
		else
			_mib.Root = k.t.sib;
	}
	return p;
}



/*** BeginHeader snmp_get */
snmp_parms * snmp_get(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_get									<MIB.LIB>

SYNTAX: snmp_parms * snmp_get(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Retrieves the object whose OID is set in *p.  The retrieved
               object information is stored back in *p, and can
               be examined using the snmp_last_*() series of functions.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.

RETURN VALUE:  NULL if p was NULL, or if there is no object with the
               given OID.  Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_get_indexed, snmp_get_next,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_xmem, snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_get(snmp_parms * p)
{
	auto mib_cursor k;
	auto word rc;

	if (!p) return NULL;

	k.index = _mib.Root;
	k.s_offs = 0;
	memcpy(&k.s_oid, &p->stem, sizeof(snmp_oid));
	rc = _mib_find(&k);
	if (!(rc & MIB_S_MATCH) || rc & (MIB_S_OFLO|MIB_NOT_LEAF))
		return NULL;
	memcpy(&p->last, &k.t, sizeof(mib_tree));
	p->index = k.index;
	return p;
}



/*** BeginHeader snmp_set_int */
snmp_parms * snmp_set_int(snmp_parms * p, int i);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_int									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_int(snmp_parms * p, int i)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the value of a short integer object.  The OID of the
               object must be set in *p.  If the object is not in fact
               a short integer, then NULL will be returned and there
               will be no alteration of the value.  The object may reside
               in either root or xmem data space.

               This function only needs to be called when the address of
               the object itself is not known.  Typically, this would
               be in functions which perform general processing of MIB
               objects.  If the address of the object is known, it is
               far more efficient to update the object directly.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.
PARAMETER2:    New value for the object.

RETURN VALUE:  NULL if p was NULL, or if there is no object with the
               given OID, or if the object was not stored with short
               integer internal type.  Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_get_indexed, snmp_get, snmp_add, snmp_xadd,
               snmp_set_long, snmp_set_str, snmp_set_oct, snmp_set_foct,
               snmp_set_objectID
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_int(snmp_parms * p, int i)
{
	if (!snmp_get(p)) return NULL;
	if ((snmp_type)(p->last.u.leaf.flags & MIB_TYPEMASK) != SNMP_SHORT)
		return NULL;
	if (p->last.u.leaf.flags & MIB_FAR)
		root2xmem(p->last.u.leaf.v.x, &i, 2);
	else
		*p->last.u.leaf.v.i = i;
	return p;
}



/*** BeginHeader snmp_set_long */
snmp_parms * snmp_set_long(snmp_parms * p, long L);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_long									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_long(snmp_parms * p, long L)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the value of a long integer object.  The OID of the
               object must be set in *p.  If the object is not in fact
               a long integer, then NULL will be returned and there
               will be no alteration of the value.

               See snmp_set_int() for other general considerations.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.
PARAMETER2:    New value for the object.

RETURN VALUE:  NULL if p was NULL, or if there is no object with the
               given OID, or if the object was not stored with long
               integer internal type.  Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_get_indexed, snmp_get, snmp_add, snmp_xadd,
               snmp_set_int, snmp_set_str, snmp_set_oct, snmp_set_foct,
               snmp_set_objectID
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_long(snmp_parms * p, long L)
{
	if (!snmp_get(p)) return NULL;
	if ((snmp_type)(p->last.u.leaf.flags & MIB_TYPEMASK) != SNMP_LONG)
		return NULL;
	if (p->last.u.leaf.flags & MIB_FAR)
		root2xmem(p->last.u.leaf.v.x, &L, 4);
	else
		*p->last.u.leaf.v.L = L;
	return p;
}



/*** BeginHeader snmp_set_str */
snmp_parms * snmp_set_str(snmp_parms * p, char * s);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_str									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_str(snmp_parms * p, char * s)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the value of an ascii string object.  The OID of the
               object must be set in *p.  If the object is not in fact
               a string, then NULL will be returned and there
               will be no alteration of the value.  If the string is
               too long for the specified maximum storage length for
               this object, then the string is truncated to fit.
               This may result in the object having no null terminator.

               See snmp_set_int() for other general considerations.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.
PARAMETER2:    New value for the object.

RETURN VALUE:  NULL if p was NULL, or if there is no object with the
               given OID, or if the object was not stored with string
               internal type.  Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_get_indexed, snmp_get, snmp_add, snmp_xadd,
               snmp_set_int, snmp_set_long, snmp_set_oct, snmp_set_foct,
               snmp_set_objectID
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_str(snmp_parms * p, char * s)
{
	auto int len;

	if (!snmp_get(p)) return NULL;
	if ((snmp_type)(p->last.u.leaf.flags & MIB_TYPEMASK) != SNMP_STR)
		return NULL;
	len = strlen(s)+1;
	if (len > p->last.u.leaf.maxlen)
		len = p->last.u.leaf.maxlen;
	if (p->last.u.leaf.flags & MIB_FAR)
		root2xmem(p->last.u.leaf.v.x, s, len);
	else
		memcpy(p->last.u.leaf.v.s, s, len);
	return p;
}



/*** BeginHeader snmp_set_foct */
snmp_parms * snmp_set_foct(snmp_parms * p, char * s);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_foct									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_foct(snmp_parms * p, char * s)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the value of a fixed-length object.  The OID of the
               object must be set in *p.  If the object is not in fact
               a fixed-length binary object, then NULL will be returned
               and there will be no alteration of the value.  s is
               always assumed to point to an area of storage of the
               required length.

               See snmp_set_int() for other general considerations.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.
PARAMETER2:    New value for the object.

RETURN VALUE:  NULL if p was NULL, or if there is no object with the
               given OID, or if the object was not stored with "foct"
               internal type.  Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_get_indexed, snmp_get, snmp_add, snmp_xadd,
               snmp_set_int, snmp_set_long, snmp_set_oct, snmp_set_str,
               snmp_set_objectID
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_foct(snmp_parms * p, char * s)
{
	if (!snmp_get(p)) return NULL;
	if ((snmp_type)(p->last.u.leaf.flags & MIB_TYPEMASK) != SNMP_FOCT)
		return NULL;
	if (p->last.u.leaf.flags & MIB_FAR)
		root2xmem(p->last.u.leaf.v.x, s, p->last.u.leaf.maxlen);
	else
		memcpy(p->last.u.leaf.v.s, s, p->last.u.leaf.maxlen);
	return p;
}



/*** BeginHeader snmp_set_oct */
snmp_parms * snmp_set_oct(snmp_parms * p, word len, char * s);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_oct									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_oct(snmp_parms * p, word len, char * s)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the value of a variable-length object.  The OID of the
               object must be set in *p.  If the object is not in fact
               an ovtet string, then NULL will be returned and there
               will be no alteration of the value.  If "len" is
               too long for the specified maximum storage length for
               this object, then the data is truncated to fit.

               See snmp_set_int() for other general considerations.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.
PARAMETER2:    New length for the object.
PARAMETER3:    New value for the object.  This points to the actual
               object data, not the 2-byte length prefix.

RETURN VALUE:  NULL if p was NULL, or if there is no object with the
               given OID, or if the object was not stored with variable
               length octet string type.  Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_get_indexed, snmp_get, snmp_add, snmp_xadd,
               snmp_set_int, snmp_set_long, snmp_set_str, snmp_set_foct,
               snmp_set_objectID
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_oct(snmp_parms * p, word len, char * s)
{
	if (!snmp_get(p)) return NULL;
	if ((snmp_type)(p->last.u.leaf.flags & MIB_TYPEMASK) != SNMP_OCT)
		return NULL;
	if (len + 2 > p->last.u.leaf.maxlen || len >= 0xFFFE)
		len = p->last.u.leaf.maxlen - 2;
	if (p->last.u.leaf.flags & MIB_FAR) {
		root2xmem(p->last.u.leaf.v.x, &len, 2);
		root2xmem(p->last.u.leaf.v.x + 2, s, len);
	}
	else {
		*p->last.u.leaf.v.i = len;
		memcpy(p->last.u.leaf.v.s + 2, s, len);
	}
	return p;
}



/*** BeginHeader snmp_set_objectID */
snmp_parms * snmp_set_objectID(snmp_parms * p, snmp_oid * oid);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_set_objectID									<MIB.LIB>

SYNTAX: snmp_parms * snmp_set_objectID(snmp_parms * p, snmp_oid * oid)

KEYWORDS:      snmp, mib

DESCRIPTION:   Set the value of an object-ID object.  The OID of the
               object must be set in *p.  If the object is not in fact
               an OID, then NULL will be returned and there
               will be no alteration of the value.

               See snmp_set_int() for other general considerations.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.
PARAMETER2:    New value for the object.

RETURN VALUE:  NULL if p was NULL, or if there is no object with the
               given OID, or if the object was not stored with object-ID
               internal type.  Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_get_indexed, snmp_get, snmp_add, snmp_xadd,
               snmp_set_int, snmp_set_str, snmp_set_oct, snmp_set_foct,
               snmp_set_long
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_set_objectID(snmp_parms * p, snmp_oid * oid)
{
	if (!snmp_get(p)) return NULL;
	if ((snmp_type)(p->last.u.leaf.flags & MIB_TYPEMASK) != SNMP_OID)
		return NULL;
	if (p->last.u.leaf.flags & MIB_FAR)
		root2xmem(p->last.u.leaf.v.x, oid, sizeof(snmp_oid));
	else
		memcpy(p->last.u.leaf.v.o, oid, sizeof(snmp_oid));
	return p;
}



/*** BeginHeader snmp_get_indexed */
snmp_parms * snmp_get_indexed(snmp_parms * p, word i);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_get_indexed									<MIB.LIB>

SYNTAX: snmp_parms * snmp_get_indexed(snmp_parms * p, word i)

KEYWORDS:      snmp, mib

DESCRIPTION:   Retrieves the object whose MIB tree index is given by i.
               The object information is stored in *p, and can
               be examined using the snmp_last_*() series of functions.
               The object ID of the retrieved object may be obtained
               by calling snmp_copy_oid().  The object ID is automatically
               set in *p, so snmp_get_next() can be called repeatedly to
               retrieve higher objects in ascending sequence of object ID.

               See documentation for snmp_last_index() for information on
               MIB tree indices.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.
PARAMETER2:    Index of object, e.g. from snmp_last_index().

RETURN VALUE:  NULL if p was NULL, or if there is no next object.
               Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_copy_oid, snmp_get, snmp_get_next, snmp_last_index,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_xmem, snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_get_indexed(snmp_parms * p, word i)
{
	if (!p) return NULL;
	_mib_get_node(&p->last, i);
	p->index = i;
	_mib_reconstruct_stem(p);
	return p;
}



/*** BeginHeader snmp_last_index */
word snmp_last_index(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_index									<MIB.LIB>

SYNTAX: word snmp_last_index(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the MIB tree index for the last object added or
               retrieved.  Indices are the most efficient way to access
               objects in the MIB tree, however the efficiency comes at
               a price: it is possible for indices to become invalid
               if the snmp_delete() function is ever used.

               Once an object is created using snmp_add_*(), its index
               is guaranteed to remain valid until the same object is
               deleted using snmp_delete().  After such time, the index
               may refer to an unused tree entry (and thus be garbage)
               or another object may be created which will re-use the
               same index.

               It is safe to store indices of objects which are never
               deleted.  Otherwise, the programmer must exercise
               caution.

               An index value of SNMP_NULL (which is not the same as
               zero!) indicates a null index e.g. "not found" or
               "unknown".

PARAMETER1:    Parameter structure that was previously set by a call to
               snmp_add_*() or snmp_get() or snmp_get_next().

RETURN VALUE:  SNMP_NULL if p was NULL, otherwise returns the index.
               The returned index may be garbage if no object was
               added or retrieved by previous calls.

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_add, snmp_xadd, snmp_delete
END DESCRIPTION **********************************************************/


_mib_nodebug word snmp_last_index(snmp_parms * p)
{
	if (!p)
		return SNMP_NULL;
	return p->index;
}



/*** BeginHeader snmp_get_next */
snmp_parms * snmp_get_next(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_get_next									<MIB.LIB>

SYNTAX: snmp_parms * snmp_get_next(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Retrieves the next object in lexicographically ascending
               sequence.  The object information is stored in *p, and can
               be examined using the snmp_last_*() series of functions.
               The object ID of the retrieved object may be obtained
               by calling snmp_copy_oid().  The object ID is automatically
               set in *p, so this function can be called repeatedly to
               retrieve all objects in ascending sequence of object ID.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.

RETURN VALUE:  NULL if p was NULL, or if there is no next object.
               Otherwise, returns p.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem,
               snmp_copy_oid, snmp_get, snmp_get_indexed,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_xmem, snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_get_next(snmp_parms * p)
{
	auto mib_cursor k;
	auto word rc, slen;
	auto word a;

	if (!p) return NULL;

	k.index = _mib.Root;
	k.s_offs = 0;
	memcpy(&k.s_oid, &p->stem, sizeof(snmp_oid));
	rc = _mib_find(&k);
	if (k.index == SNMP_NULL) {
#ifdef MIB_VERBOSE
		printf("MIB: get_next: found null, nextsib=%u\n", k.nextsib);
#endif
		a = k.nextsib;
		_mib_get_node(&p->last, a);
		slen = k.s_offs;
		goto descend;
	}

	slen = k.s_offs - k.n_offs;
	if (!(rc & MIB_N_MATCH) && rc & (MIB_S_MATCH | MIB_S_LOW)
	    || rc & MIB_N_MATCH && rc & MIB_NOT_LEAF) {
		// Part or full match in node, but not leaf; descend to 1st existing child
		memcpy(&p->last, &k.t, sizeof(mib_tree));
		a = k.index;
		goto descend;
	}
	// k.index is exact matching node, or one immediately before in lex sequence.
	// Scan to find next higher node - first child of sibling if exists, or first
	// child of closest ancestor.
	while (k.t.sib == SNMP_NULL) {
		// Scan up ancestors
		a = k.t.parent;
		if (a == SNMP_NULL)
			return NULL;
		_mib_get_node(&k.t, a);
		slen -= k.t.u.node.len;
		k.index = a;
	}
	_mib_get_node(&p->last, a = k.t.sib);
descend:
	p->stem.len = slen;
	while (!(p->last.u.leaf.flags & MIB_LEAF)) {
		_mib_cat_oid(&p->stem, p->last.u.node.len, p->last.u.node.oid);
		_mib_get_node(&p->last, a = p->last.u.node.child);
	}

	_mib_append_oid(&p->stem, p->last.u.leaf.id);
	p->index = a;
	return p;
}



/*** BeginHeader snmp_copy_oid */
snmp_oid * snmp_copy_oid(snmp_parms * p, snmp_oid * n);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_copy_oid									<MIB.LIB>

SYNTAX: snmp_oid * snmp_copy_oid(snmp_parms * p, snmp_oid * n)

KEYWORDS:      snmp, mib

DESCRIPTION:   Copy the current object ID "stem" from *p into *n.

PARAMETER1:    Parameter structure that was previously initialized by
               calls to snmp_init_parms(), snmp_set_stem() etc.
PARAMETER2:    Object ID structure to be filled in with current stem
               from *p.  Must not be NULL.

RETURN VALUE:  If p was NULL returns NULL, otherwise returns n.

SEE ALSO:      snmp_init_parms, snmp_set_stem, snmp_append_stem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_oid * snmp_copy_oid(snmp_parms * p, snmp_oid * n)
{
	if (!p)
		return NULL;
	memcpy(n, &p->stem, sizeof(snmp_oid));
	return n;
}



/*** BeginHeader snmp_last_type */
snmp_type snmp_last_type(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_type									<MIB.LIB>

SYNTAX: snmp_type snmp_last_type(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the internal type of the last object retrieved
               from the MIB tree.  Each object has two "types".  The
               SNMP type (see snmp_last_snmp_type()) indicates the type
               of object to external entities using SNMP to examine
               objects on this agent. The internal type indicates the
               memory layout for the object in the MIB tree.  The same
               memory layout may be used for different SNMP types, and
               vice versa.

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().

RETURN VALUE:  Internal type of the object.  The currently supported types
               are
                 SNMP_SHORT 0  - 16-bit integer
                 SNMP_LONG  1  - 32-bit integer
                 SNMP_STR   2  - null-terminated string
                 SNMP_OCT   3  - variable length binary (octet) string
                 SNMP_FOCT  4  - fixed length binary string
                 SNMP_OID   5  - Object ID

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_xmem, snmp_last_snmp_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_type snmp_last_type(snmp_parms * p)
{
	return (snmp_type)(p->last.u.leaf.flags & MIB_TYPEMASK);
}



/*** BeginHeader snmp_last_snmp_type */
word snmp_last_snmp_type(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_snmp_type									<MIB.LIB>

SYNTAX: word snmp_last_snmp_type(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the SNMP type of the last object retrieved
               from the MIB tree.  Each object has two "types".  The
               SNMP type indicates the type of object to external
               entities using SNMP to examine objects on this agent.
               The internal type (see snmp_last_type()) indicates the
               memory layout for the object in the MIB tree.  The same
               memory layout may be used for different SNMP types, and
               vice versa.

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().

RETURN VALUE:  SNMP type of the object.  The currently supported types are
                  SNMP_P_INTEGER   0x02
                  SNMP_P_OCTETSTR  0x04
                  SNMP_P_OID       0x06
                  SNMP_P_IPADDR    0x40
                  SNMP_P_COUNTER   0x41
                  SNMP_P_GAUGE     0x42
                  SNMP_P_TIMETICKS 0x43

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_xmem, snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug word snmp_last_snmp_type(snmp_parms * p)
{
	return (p->last.u.leaf.flags & MIB_SNMPMASK) >> 4;
}



/*** BeginHeader snmp_last_maxlen */
word snmp_last_maxlen(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_maxlen									<MIB.LIB>

SYNTAX: word snmp_last_maxlen(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the maximum length of the last object retrieved
               from the MIB tree.  The object may be of any type, and
               may be in either xmem or root storage.  The current
               length (from snmp_last_len()) may be less than or equal to
               the result from this function.

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().

RETURN VALUE:  Returns the maximum permissible object length.  Result
               will be garbage if p was NULL.

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_xmem, snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug word snmp_last_maxlen(snmp_parms * p)
{
	return p->last.u.leaf.maxlen;
}



/*** BeginHeader snmp_last_len */
word snmp_last_len(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_len									<MIB.LIB>

SYNTAX: word snmp_last_len(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the current length of the last object retrieved
               from the MIB tree.  The object may be of any type, and
               may be in either xmem or root storage.  The current
               length may be less than or equal to the result from
               snmp_last_maxlen().

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().

RETURN VALUE:  Returns the object length.  Result will be garbage if
               p was NULL.

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_xmem, snmp_last_type, snmp_last_maxlen
END DESCRIPTION **********************************************************/


_mib_nodebug word snmp_last_len(snmp_parms * p)
{
	auto word len;

	switch (p->last.u.leaf.flags & MIB_TYPEMASK) {
		default:
			return p->last.u.leaf.maxlen;
		case SNMP_STR:
			if (p->last.u.leaf.flags & MIB_FAR)
				len = xstrlen(p->last.u.leaf.v.x);
			else
				len = strlen(p->last.u.leaf.v.s);
			if (len > p->last.u.leaf.maxlen)
				return p->last.u.leaf.maxlen;
			return len;
		case SNMP_OCT:
			if (p->last.u.leaf.flags & MIB_FAR) {
				xmem2root(&len, p->last.u.leaf.v.x, 2);
				return len;
			}
			else
				return *(word *)p->last.u.leaf.v.s;
		case SNMP_OID:
			if (p->last.u.leaf.flags & MIB_FAR) {
				xmem2root(&len, p->last.u.leaf.v.x, 2);
				return len;
			}
			else
				return p->last.u.leaf.v.o->len;
	}
}



/*** BeginHeader snmp_last_int */
int snmp_last_int(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_int									<MIB.LIB>

SYNTAX: int snmp_last_int(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the short integer value of the last object retrieved
               from the MIB tree.  The object must be of a short integer
               type, and may be in either xmem or root storage.  If the
               object is in fact a long integer, then the return value
               will reflect only the low 16 bits of the value.  If the
               object is of any other type the returned value will be
               garbage.

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().

RETURN VALUE:  Returns the object value.  Result will be garbage if the
               object is not a short integer type, or is p was NULL.

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_long, snmp_last_mem, snmp_last_xmem,
               snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug int snmp_last_int(snmp_parms * p)
{
	auto int i;

	if (p->last.u.leaf.flags & MIB_FAR) {
		xmem2root(&i, p->last.u.leaf.v.x, 2);
		return i;
	}
	return *p->last.u.leaf.v.i;
}



/*** BeginHeader snmp_last_long */
long snmp_last_long(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_long									<MIB.LIB>

SYNTAX: long snmp_last_long(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the long integer value of the last object retrieved
               from the MIB tree.  The object must be of a long integer
               type, and may be in either xmem or root storage.  If the
               object is of any other type (including short integer) the
               returned value will be garbage.

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().

RETURN VALUE:  Returns the object value.  Result will be garbage if the
               object is not a long integer type, or is p was NULL.

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_int, snmp_last_mem, snmp_last_xmem,
               snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug long snmp_last_long(snmp_parms * p)
{
	auto long L;

	if (p->last.u.leaf.flags & MIB_FAR) {
		xmem2root(&L, p->last.u.leaf.v.x, 4);
		return L;
	}
	return *p->last.u.leaf.v.L;
}



/*** BeginHeader snmp_last_mem */
char * snmp_last_mem(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_mem									<MIB.LIB>

SYNTAX: char * snmp_last_mem(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the logical address of the last object retrieved
               from the MIB tree.  The object may be of any type,
               however it must NOT have been defined as an xmem object.

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().

RETURN VALUE:  If p was NULL, or the object is in xmem storage, returns
               NULL.  Otherwise, the logical (near) address of the object
               is returned.

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_int, snmp_last_long, snmp_last_xmem,
               snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug char * snmp_last_mem(snmp_parms * p)
{
	if (!p || p->last.u.leaf.flags & MIB_FAR)
		return NULL;

	return p->last.u.leaf.v.s;
}



/*** BeginHeader snmp_last_xmem */
long snmp_last_xmem(snmp_parms * p);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_xmem									<MIB.LIB>

SYNTAX: long snmp_last_xmem(snmp_parms * p)

KEYWORDS:      snmp, mib

DESCRIPTION:   Return the physical address of the last object retrieved
               from the MIB tree.  The object may have been defined to
               reside in either xmem or root data space, and may be of
               any type.

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().

RETURN VALUE:  If p was NULL, returns 0.  Otherwise, returns the physical
               (20-bit linear) address of the object.

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_type, snmp_last_len
END DESCRIPTION **********************************************************/


_mib_nodebug long snmp_last_xmem(snmp_parms * p)
{
	if (!p)
		return 0L;
	if (p->last.u.leaf.flags & MIB_FAR)
		return p->last.u.leaf.v.x;
	else
		return paddr(p->last.u.leaf.v.s);
}



/*** BeginHeader snmp_last_objectID */
snmp_parms * snmp_last_objectID(snmp_parms * p, snmp_oid * oid);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_last_objectID									<MIB.LIB>

SYNTAX: snmp_parms * snmp_last_objectID(snmp_parms * p, snmp_oid * oid)

KEYWORDS:      snmp, mib

DESCRIPTION:   Copy the last OID object which was retrieved from
               the MIB tree into *oid.

PARAMETER1:    Parameter structure that was used previously in a call to
               a retrieval function such as snmp_get_indexed(),
               snmp_get() or snmp_get_next().
PARAMETER2:    Pointer to an snmp_oid structure, to which the result
               is copied.

RETURN VALUE:  p, or NULL if p was NULL or the last object retrieved was
               not in fact an object-ID object.

SEE ALSO:      snmp_init_parms, snmp_get, snmp_get_next, snmp_get_indexed,
               snmp_last_int, snmp_last_long, snmp_last_mem,
               snmp_last_xmem
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_last_objectID(snmp_parms * p, snmp_oid * oid)
{
	if (!p || (snmp_type)(p->last.u.leaf.flags & MIB_TYPEMASK) != SNMP_OID)
		return NULL;
	if (p->last.u.leaf.flags & MIB_FAR)
		xmem2root(oid, p->last.u.leaf.v.x, sizeof(snmp_oid));
	else
		memcpy(oid, p->last.u.leaf.v.o, sizeof(snmp_oid));
	return p;
}



/*** BeginHeader snmp_used */
long snmp_used(void);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_used									<MIB.LIB>

SYNTAX: long snmp_used(void)

KEYWORDS:      snmp, mib

DESCRIPTION:   Obtain information about the amount of memory used by the
               MIB tree.  The value returned may be used as the setting
               for SNMP_MIB_SIZE if the application does not dynamically
               add objects during normal execution.

RETURN VALUE:  Number of bytes of xmem currently used by the MIB tree.
END DESCRIPTION **********************************************************/


_mib_nodebug long snmp_used(void)
{
	return SNMP_MIB_SIZE - _mib.freecount * (long)sizeof(mib_tree);
}


/*** BeginHeader snmp_create */
snmp_parms * snmp_create(snmp_parms * p, char * til, long xaddbase);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_create									<MIB.LIB>

SYNTAX: snmp_parms * snmp_create(snmp_parms * p, char * til,
                                 long xaddbase)

KEYWORDS:      snmp, mib

DESCRIPTION:   This function may be used to create an arbitrary number of
               objects in the MIB tree.  The til parameter specifies a
               tree initialization list.  It is intended to allow a more
               compact way of initializing the MIB tree at the beginning
               of an application, as opposed to the use of function calls.

               At this time, this function is NOT TESTED and should not
               be used in this release.  The main reason for this is that
               the TIL is complex to set up manually.  Dynamic C requires
               some enhancements to allow arithmetic on constant
               address expressions in initializers.

PARAMETER1:    Pre-initialized parameter structure.
PARAMETER2:    MIB Tree Initialization List.
PARAMETER3:    Physical address of xmem base address for xmem objects.

RETURN VALUE:  p, or NULL if error.
END DESCRIPTION **********************************************************/


_mib_nodebug snmp_parms * snmp_create(snmp_parms * _p, char * til, long xaddbase)
{
	auto snmp_parms pstack[SNMP_MAX_PSTACK];
	auto word psp;
	auto snmp_parms * p;
	auto char cmd;
	auto word maxlen;
	auto void * addr;
	auto word stype;
	auto oidlevel L;

	if (!p || *til++ != SNMP_I_MAGIC)
		return NULL;

	psp = 0;
	p = _p;

	for (;;) switch (cmd = *til++) {
		default:
			return _p;		// Assume end of list
		case SNMP_I_NOP:
			break;
		case SNMP_I_APP1:
			if (!_mib_append_oid((snmp_oid *)p, *til++))
				return NULL;
			break;
		case SNMP_I_APP2:
			if (!_mib_append_oid((snmp_oid *)p, *(word *)til))
				return NULL;
			til += 2;
			break;
		case SNMP_I_APP4:
			if (!_mib_append_oid((snmp_oid *)p, *(oidlevel *)til))
				return NULL;
			til += 4;
			break;
		case SNMP_I_UP:
			if (!snmp_up_stem(p, 1))
				return NULL;
			break;
		case SNMP_I_PUSH:
			if (psp >= SNMP_MAX_PSTACK)
				return NULL;
			memcpy(pstack+psp, p, sizeof(snmp_parms));
			p = pstack + psp++;
			break;
		case SNMP_I_POP:
			if (!psp)
				return NULL;
			p--;
			psp--;
			if (!psp)
				p = _p;
			break;
		case SNMP_I_RD:
			p->rdmask = *til++;
			break;
		case SNMP_I_WR:
			p->wrmask = *til++;
			break;
		case SNMP_I_CB:
			p->fn = *(snmp_callback **)til;
			til += 2;
			break;
		case SNMP_I_NCB:
			p->fn = NULL;
			break;
		case SNMP_I_ADD:
		case SNMP_I_ADDI:
		case SNMP_I_XADD:
		case SNMP_I_XADDI:
			stype = *til++;
			addr = *(void **)til;
			til += 2;
			switch (stype) {
				case SNMP_INTEGER_AS_SHORT:
				case SNMP_COUNTER_AS_SHORT:
				case SNMP_GAUGE_AS_SHORT:
					maxlen = 2;
					break;
				case SNMP_INTEGER_AS_LONG:
				case SNMP_IPADDR_AS_LONG:
				case SNMP_IPADDR_AS_OCT:
				case SNMP_COUNTER_AS_LONG:
				case SNMP_GAUGE_AS_LONG:
				case SNMP_TIMETICKS:
					maxlen = 4;
					break;
				case SNMP_OBJECT_ID:
					maxlen = sizeof(snmp_oid);
					break;
				default:
					maxlen = *(word *)til;
					til += 2;
					break;
			}
			if (cmd == SNMP_I_XADD || cmd == SNMP_I_XADDI)
				p = snmp_xadd(p, -1, stype, xaddbase + (word)addr, maxlen);
			else
				p = snmp_add(p, -1, stype, addr, maxlen);
			if (!p)
				return NULL;
			if (cmd == SNMP_I_ADDI || cmd == SNMP_I_XADDI) {
				// Autoincrement last level
				snmp_up(p, 1);
				maxlen = p->stem.len;
				L = _mib_get_level(p->stem.oid, &maxlen);
				if (!_mib_append_oid((snmp_oid *)p, L+1))
					return NULL;
			}
			break;
		case SNMP_I_STIX:
			**(word **)til = snmp_last_index(p);
			til += 2;
			break;
		case SNMP_I_SAV:
			p->flags |= MIB_SAVEABLE;
			break;
		case SNMP_I_NSAV:
			p->flags &= ~MIB_SAVEABLE;
			break;
	}
}


/*** BeginHeader snmp_format_oid */
char * snmp_format_oid(snmp_oid * oid);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_format_oid									<MIB.LIB>

SYNTAX: char * snmp_format_oid(snmp_oid * oid)

KEYWORDS:      snmp, mib

DESCRIPTION:   Debugging only: format OID in dotted decimal and return
               static buffer.

PARAMETER1:    oid to format.

RETURN VALUE:  Address of string in static storage.
END DESCRIPTION **********************************************************/


_mib_nodebug char * snmp_format_oid(snmp_oid * oid)
{
	static char buf[80];
	auto word i;

	if (!oid)
		return "<NULL OID>";
	buf[0] = 0;
	for (i = 0; i < oid->len; )
		sprintf(buf + strlen(buf), "%lu.", _mib_get_level(oid->oid, &i));
	return buf;
}



/*** BeginHeader snmp_print_tree */
void snmp_print_tree(void);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
snmp_print_tree									<MIB.LIB>

SYNTAX: void snmp_print_tree(void)

KEYWORDS:      snmp, mib

DESCRIPTION:   Debugging function only.  Prints entire MIB tree.  Leaf
               nodes are printed with their OID number and value.
               Non-leaf nodes are printed with their OID fragment
               suffixed with '.'.  For simplicity, this function
               recurses.

END DESCRIPTION **********************************************************/


_mib_nodebug void snmp_print_tree(void)
{
	if (_mib.Root == SNMP_NULL)
		printf("<MIB tree is empty>\n");
	else
		_mib_print_tree(_mib.Root, 0);
}



/*** BeginHeader _mib_init */
void _mib_init();
#funcchain _GLOBAL_INIT _mib_init
/*** EndHeader */

nodebug
void _mib_init()
{
	static word findex;

	_mib.buf = xalloc(SNMP_MIB_SIZE);
	_mib.Root = SNMP_NULL;

	// Add all nodes to free list
	for (findex = 0; findex < SNMP_MIB_SIZE/sizeof(mib_tree); findex++)
		_mib_set_sib(findex, findex - 1);	// First one will be SNMP_NULL (-1)
	_mib.free = findex - 1;
	_mib.freecount = findex;
}


/*** BeginHeader */
#endif
/*** EndHeader */
inet_addr