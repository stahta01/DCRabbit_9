/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/*
 * The FLASH or RAM filesystem
 */
/*
 * The flash file system organizes the equal sized sectors on your flash into
 * the default of 4096 byte blocks. Every block has a block number.  Blocks differ
 * in their sequence numbers, version numbers and checksums.  When bytes are
 * added to a file, a new version of the last block of the file is written. The
 * previous version of that block is now considered to be a free block.
 *
 * All blocks in a file have contiguious sequence numbers.  The block numbers are
 * allowed to wrap around the maximum value of the sequence number.  This makes it
 * possible to have the sequence number of the first block greater than the sequence
 * number of the last block.
 *
 * On system initialization all of the blocks are checked for bad checksums and if
 * there is more than a 1-bit error and a previous version of the block is present,
 * this indicates that a write operation was interrupted by a system reset or crash.
 * In this case the bad block is marked as free and the previous version of the block
 * is used in the file.  Any corrupted blocks are repaired on system initialization.
 *
 * Each block has an eighteen byte header that is organized as follows:
 * typedef struct {
 *		byte flag;
 *		byte file;
 *		word first_byte;
 *		word last_byte;
 *		unsigned long seq;
 *		byte ver;
 *		unsigned long wear;
 *		byte reserved;
 *		word crc;
 * } FSHeader;
 * flag - In a block that has been erased, all bits are set to one.  But, erased blocks
 * have a transitory lifetime and usually are not present when a search for a free block
 * is being done.  A value of 0xff in flag indicates a system crash during or after a
 * block erase.  Calling fs_init will cause flag to be set to FS_FREE for that block,
 * making it free for allocation.  When a block has been allocated, the flag is set to
 * FS_USED.
 *
 * file - This number is an identifier for the file.  File number 0, and numbers 128-255
 * are reserved for Rabbit Semiconductor’s future use.
 *
 * first_byte and last_byte - This is the offset from the start of the block where data
 * begins and ends.  The first_byte will allow developers to add functions that allow
 * deletion of data from the beginning of a file.  This is currently not implemented.
 * The last_byte is a pointer to the last valid byte in a sector.  If last_byte is set
 * beyond the end of a block the block is completely full.
 *
 * seq - Each successive block has a sequence number one higher than the previous block.
 * However, the first block of the file can have any sequence number.  Wrapping the
 * sequence number is valid.
 *
 * ver - Blocks with obsolete version numbers and the sequence and file number are
 * considered free blocks.  Only two versions of a block are ever present at one time
 * in normal operation.  When a new version is written the old version is marked free.
 *
 * wear - For the purpose of wear leveling, wear holds the number of times a block has
 * been written to.  Every time the bock is erased,  wear plus one is written to the block.
 *
 * crc - This is a sixteen byte ones complement checksum.
 *
 *
 * There are two tables kept in RAM for impoving file access efficiency.
 * these are stored in xmem as fs_filelist and fs_blocklist
 * fs_filelist - this is an array of integers indexed by file number
 * 	that stores the first block of a file.
 * fs_blocklist - an array of FSBlockLink structures indexed by block number.
 *		This table holds key information about blocks for easy lookup and acts as
 *		a linked list of blocks in a file.
 *	These tables are generated by iterating through all of the blocks
 *	during initialization.
 */

/*** BeginHeader */
#if _USER
	#error "Filesystem.lib is not supported by RabbitSys."
#endif

#ifndef DISABLE_FS_WARNING
	#warnt "Large-sector flash and FILESYSTEM.LIB with many short writes will"
	#warnt "result in poor performance!  Consider using FS2.LIB instead."
	#warnt "You can #define DISABLE_FS_WARNING to disable this warning."
#endif

/*
 * TYPES
 */
typedef byte FileNumber; /* filename (number, 0->255) */
typedef unsigned long FSSeq; /* sequence number */

typedef struct {
	FileNumber name;
	int mode;

	FSSeq first_sequence;
	int first_block;

	FSSeq current_sequence;	/* current sequence number */
	int current_block;	/* block current_sequence refrences */
	long position;		/* current position in file */
	int current_offset;	/* offset into current_block that position points to */

	int num_blocks;		/* number of blocks in file */
} File;		/* file handler */

/* used by the flash writer */
typedef struct {
	long	address;
	int	length;
} FSWriteBlock;

//for block table
typedef struct {
	FileNumber name;
	byte used;
	int next_block;
} FSBlockLink;
#define FS_BLOCKLINK sizeof(FSBlockLink)

/* Load the low-level drivers */
#ifdef FS_FLASH
	#use "fs_flash.lib"
#else
	#ifdef FS_RAM
		#use "fs_ram.lib"
	#else
		#ifdef FS_FLASH_SINGLE
			#use "fs_flash_single.lib"
		#else
			#error "fs: must define FS_FLASH or FS_RAM to load a driver!"
		#endif
	#endif
#endif

/* 'whence' values for fseek() */
#define SEEK_SET	0
#define SEEK_CUR	1
#define SEEK_END	2

/* block flags */
#define FS_ERASED	0xff
#define FS_FREE		1
#define FS_USED		2
#define FS_BAD			3

/* read/write modes */
#define FS_NOTOPEN	0
#define FS_READ		1
#define FS_WRITE	2

/* reserved block number */
#define FS_NOBLOCK	-1

/* current file system version */
#define FS_VERSION 0xfe

/* fsck options */
#define FSCK_HEADERS		0x0001
#define FSCK_CHECKSUMS	0x0002
#define FSCK_VERSION		0x0004

/* where the fs is */
long fs_offset;
int fs_num_blocks;
//tables in xmem
unsigned long fs_blocklist;
unsigned long fs_filelist;
//track blocks used
int fs_blocks_used;
int fs_nonpriv_blocks_used;
int fs_blocks_reserved;	//blocks kept free for priveleged files
//sector buffer in xmem
unsigned long fs_sectorbuf;

typedef struct {
	byte fs_version;
	byte flag;
	byte file;
	word first_byte;
	word last_byte;
	unsigned long seq;
	byte ver;
	unsigned long wear;
	word crc;
} FSHeader;
#define FS_HEADER sizeof(FSHeader)

/* temporary buffer for building sectors (created w/ xalloc() ) */
long	fs_temp_buf;

/*** EndHeader */
#if(_BOARD_TYPE_ == 0x1300)
	#error "OLD FILESYSTEM will not work with RCM 3200 Boards."
#endif
/********************
 * Helper functions *
 ********************/

/*** BeginHeader fs_checksum */
unsigned int fs_checksum(char *buf,
								 unsigned int cnt,
								 unsigned int seed,
								 unsigned int old_size);
/*** EndHeader */

#asm
;
;  unsigned inchksum(char* buf, unsigned cnt, unsigned seed);
;	returns internet compatable ones complement checksum
;  for the buffer buf of size cnt, starting with the given seed
;
fs_checksum::
	push	ix							; save frame pointer

	ld		hl,(sp+8)				; de=seed
	ex		de, hl
	ld		ix,(sp+4)				; ix=buf
	ld		hl,(sp+6)
	ld		a, h
	ld		b, a
	ld		a, L
	ld		c, a						; bc=byte count

	or		a							; clear carry
	ld		a,b						; anything to checksum???
	or		c
	jr		nz,fs_chk__setcount
	ex		de, hl					;no new data, return seed
	jr 	fs_chk__done

fs_chk__setcount:
	ld		hl, (sp+10)				;check old length
	ld		a, L
	and	0x01						;check if odd
	jr		z, fs_chk__loopstart
	ex		de, hl					;old sum into hl
	ld		e, 0x00					;add first byte to high byte of checksum
	ld		d, (ix)
	add	hl, de
	ld		de,0x0000				; make sure carry gets into sum
	adc	hl,de
	adc	hl, de
	ex		de, hl					; put sum back into de
	dec	bc
	inc	ix
	or		a
	ld		a, b
	or		c
	jr		nz, fs_chk__loopstart		;more data
	ex		de, hl
	jr		fs_chk__done
fs_chk__loopstart:
	or		a
	rr		b
	rr		c
	ex		af, af'					;divide bc by 2, store LSB in carry flag(af')
	or		a
	ld		a, b
	or		c
	jr		z, fs_chk__last		;only one byte to add
	inc	b							;b is decremented before checking
	or		a							;clear carry
fs_chk__loop:
	ld		hl,(ix+0)					; get word
	adc	hl,de						; add it to checksum
	ex		de,hl
	inc	ix
	inc	ix							; move pointer to next word
	dec	c
	jr		nz, fs_chk__loop
	dec	b
	jr		nz, fs_chk__loop
	ld		hl,0x0000
	ex		de, hl					; hl das sum
	adc	hl,de
	adc	hl, de					; make sure carry gets into sum
	ex		de, hl					; put sum back into de

fs_chk__last:						; put in last odd byte
	ex		af, af'
	ex		de, hl					; put sum into hl
	jr		nc, fs_chk__done
	ld		d, 0x00
	ld		e, (ix)
	add	hl, de
	ld		de, 0x0000
	adc	hl, de
	adc	hl, de

fs_chk__done:
	pop	ix							; return checksum
	ret
#endasm

/*** BeginHeader fs_checksum_far */
unsigned int fs_checksum_far(int block,
	int offset, int length, unsigned int seed, unsigned int old_size);
/*** EndHeader */

/* checksum a block actually in the filesystem */
nodebug root unsigned int fs_checksum_far(int block,
	int offset, int length, unsigned int seed, unsigned int old_size)
{
	auto int savexpc;
	auto int checksum;
	auto char *data_offset;

#asm
	ld		a,xpc
	bool	hl
	ld		l,a
	ld		(SP+@SP+savexpc),hl
#endasm

	data_offset = fs_block_pushxpc(block);
	checksum = fs_checksum(data_offset + offset, length, seed, old_size);

#asm
	ld		hl,(sp+@SP+savexpc)
	ld		a,l
	ld		xpc,a
#endasm

	return checksum;
}

/*** BeginHeader fs_get_header */
int fs_get_header(int block, FSHeader *header);
/*** EndHeader */

/* get a block header, and store it in fs_header */
nodebug int fs_get_header(int block, FSHeader *header)
{
	fs_block_read(block, 0, (char *)header, FS_HEADER);
	return 0;
}

/*** BeginHeader fs_filelist_get*/
int fs_filelist_get(FileNumber file);
/*** EndHeader */

//methods for blocklist and filelist
nodebug int fs_filelist_get(FileNumber file)
{
	auto int first_block;
	xmem2root(&first_block, fs_filelist + (sizeof(int)*file), sizeof(int));
	return first_block;
}

/*** BeginHeader fs_filelist_set */
void fs_filelist_set(FileNumber file, int first_block);
/*** EndHeader */

nodebug void fs_filelist_set(FileNumber file, int first_block)
{
	root2xmem(fs_filelist + (sizeof(int)*file), &first_block, sizeof(int));
}

/*** BeginHeader fs_blocklist_get */
void fs_blocklist_get(int block, FSBlockLink *link);
/*** EndHeader */

nodebug void fs_blocklist_get(int block, FSBlockLink *link)
{
	xmem2root(link, fs_blocklist + (FS_BLOCKLINK*block), FS_BLOCKLINK);
}

/*** BeginHeader fs_blocklist_set */
void fs_blocklist_set(int block, FSBlockLink *link);
/*** EndHeader */

nodebug void fs_blocklist_set(int block, FSBlockLink *link)
{
	root2xmem(fs_blocklist + (FS_BLOCKLINK*block), link, FS_BLOCKLINK);
}

/*** BeginHeader fs_get_next_block */
int fs_get_next_block(int block);
/*** EndHeader */

nodebug int fs_get_next_block(int block)
{
	auto FSBlockLink link;
	fs_blocklist_get(block, &link);
	return link.next_block;
}

/*** BeginHeader fs_table_alloc */
void fs_table_alloc(int num_blocks);
/*** EndHeader */

//allocate and fill tables with blanks
nodebug void fs_table_alloc(int num_blocks)
{
	auto int i;
	auto FSBlockLink blank_link;
	fs_blocklist = xalloc(num_blocks * sizeof(FSBlockLink));
	fs_filelist = xalloc(256 * sizeof(int));
	blank_link.used = 0;
	for(i = 0; i < num_blocks;i++)
	{
		fs_blocklist_set(i, &blank_link);
	}
	for(i = 0;i < 256;i++)
	{
		fs_filelist_set(i, -1);
	}
}

/*** BeginHeader fs_build_tables */
void fs_build_tables();
/*** EndHeader */

nodebug void fs_build_tables()
{
	auto int i, j;
	auto FSBlockLink block_link;
	auto FSHeader header;
	auto unsigned long sequence;
	auto byte filename;
	auto int block, next;

	fs_blocks_used = 0;
	fs_nonpriv_blocks_used = 0;
	//scan through the block list;
	for(i = 0; i < fs_num_blocks;i++)
	{
		fs_get_header(i, &header);
		if(header.flag == FS_USED)
		{
			fs_blocks_used++;
			if(header.file < 128 || header.file > 143)
				fs_nonpriv_blocks_used++;
			fs_blocklist_get(i, &block_link);
			if(block_link.used == 0)
			{
				//block for a new file
				filename = header.file;
				block = i;
				sequence = header.seq;
				//look for first block for file
				for(j = i+1;j != i;j = (j+1)%fs_num_blocks)
				{
					fs_get_header(j, &header);
					if((header.file == filename) && (header.seq < sequence))
					{
						sequence = header.seq;
						block = j;
					}
				}
				//make file list entry
				fs_filelist_set(filename, block);
				//make block list entries for file
				next = 1;
				while(next)
				{
					next = 0;
					sequence++;
					for(j = 0;j < fs_num_blocks;j++)
					{
						fs_get_header(j, &header);
						if(header.file == filename && header.seq == sequence)
						{
							block_link.name = filename;
							block_link.used = 1;
							block_link.next_block = j;
							fs_blocklist_set(block, &block_link);
							block = j; //new block
							next = 1;
							break; //start loop over
						}
					}
				}
				//last block
				block_link.name = filename;
				block_link.used = 1;
				block_link.next_block = -1;
				fs_blocklist_set(block, &block_link);
			} //end of if
		} //end of if
	} //end of block search loop
}

/*** BeginHeader fs_find_average_wear */
unsigned long fs_find_average_wear(void);
/*** EndHeader */

nodebug unsigned long fs_find_average_wear(void)
{
	auto int i;
	auto unsigned long totalwear;
	auto FSHeader header;

	totalwear = 0;
	for(i=0; i<fs_num_blocks; i++) {
		/* get wear of this block */
		/* this is very slow - should just go directly to the memory location */
		fs_get_header(i, &header);
		totalwear += header.wear;
	}

	return (totalwear / fs_num_blocks);
}

/*** BeginHeader fs_erase_block */
int fs_erase_block(int block, unsigned long wear);
/*** EndHeader */

/* erase a block to given wear level - if 0, use current */
nodebug int fs_erase_block(int block, unsigned long wear)
{
	auto unsigned long w;
	auto FSBlockLink blank;
	auto FSHeader header;

	w = wear;
	/* get the old wear level? */
	if(wear == 0) {
		fs_get_header(block, &header);
		w = header.wear + 1;
	}

	memset(&header, 0xfe, FS_HEADER);

#ifdef FS_DEBUG
	printf("--> Erasing block <%d> to wearlevel <%ld>...\n", block, w);
#endif

	header.flag = FS_FREE;
	header.wear = w;
	header.fs_version = FS_VERSION;

	/* write the new header back out */
	fs_block_write(block, (char *)&header, FS_HEADER);
	blank.name = 0;
	blank.used = 0;
	blank.next_block = -1;
	fs_blocklist_set(block, &blank);
}

/*** BeginHeader fs_verify_block */
int fs_verify_block(int block);
/*** EndHeader */

/* if a block isn't marked correctly, re-format it */
nodebug int fs_verify_block(int block)
{
	auto FSHeader header;

	/* retrive the header */
	fs_get_header(block, &header); /* this is too slow? */

	switch(header.flag) {
	case FS_USED:
	case FS_FREE:
		/* add more fsck type stuff here?
		   (sanity check the values of the block?) */
		return 0;
	default:
		fs_erase_block(block, fs_find_average_wear());
		return 1;
	}
}

/*** Beginheader fs_open_common */
int fs_open_common(File *f, FileNumber name);
/*** EndHeader */

nodebug int fs_open_common(File *f, FileNumber name)
{
	auto int block, next, num_blocks;
	auto FSHeader header;

	block = fs_filelist_get(name);
	if(block >= 0)
	{
		/* file exists */
		f->name = name;
		f->first_block = block;
		fs_get_header(block, &header);
		f->first_sequence = header.seq;
		//find last block
		next = fs_get_next_block(block);
		num_blocks = 1;
		while(next >= 0)
		{
			block = next;
			next = fs_get_next_block(block);
			num_blocks++;
		}
		f->current_block = block;
		fs_get_header(block, &header);
		f->current_sequence = header.seq;
		f->num_blocks = num_blocks;

#ifdef FS_DEBUG
	printf("--> open_common: first_block = %d, current_block = %d, num_blocks = %d\n",
		f->first_block,f->current_block,num_blocks);
#endif
		return 0;
	}
	else
	{
		return 1; //file not found
	}
}

/*** BeginHeader fs_find_free */
int fs_find_free(void);
/*** EndHeader */

nodebug int fs_find_free(void)
{
	auto int i;
	auto FSSeq lowest;
	auto int block;
	auto FSHeader header;

	lowest = 0xffffffff;
	for(i=0;i<fs_num_blocks;i++) {
		fs_get_header(i, &header);
#ifdef FS_DEBUG
		//printf("-->\tScanning: block=%d, flag=%x, wear=%lx\n",i,fs_header.flag,fs_header.wear);
#endif
		if(header.flag == FS_FREE) {
			if(header.wear < lowest) {
				lowest = header.wear;
				block = i;
			}
		}
	}

	if(0xffffffff == lowest)
		return FS_NOBLOCK;

#ifdef FS_DEBUG
	//printf("--> Found free block <%d>, lowest wearlevel==%d\n",block, lowest);
#endif
	return block;
}

/*** BeginHeader fs_find_block */
int fs_find_block(FileNumber name, FSSeq sequence);
/*** EndHeader */

nodebug int fs_find_block(FileNumber name, FSSeq sequence)
{
	auto int i, block;
	auto FSHeader header;

#ifdef FS_DEBUG
	printf("--> Searching for file=%d, seq=%ld\n",name, sequence);
#endif
	for(i=0; i<fs_num_blocks; i++) {
		fs_get_header(i, &header);
#ifdef FS_DEBUG
		//printf("-->\t Searching: block=%d, flag=%d, name=%d, seq=%ld\n",
		//	i, fs_header.flag, fs_header.file, fs_header.seq);
#endif
		if((header.file == name)
		&& (header.seq == sequence)
		&& (header.flag == FS_USED) ) {
			return i;
		}
	}

	return FS_NOBLOCK;
}

/*** BeginHeader fs_verify_version */
int fs_verify_version(int block);
/*** EndHeader */

nodebug int fs_verify_version(int block)
{
	static int j;
	static unsigned long seq;
	static byte ver;
	static byte file;
	auto int retval;
	auto FSHeader header;

	retval = 0;

	/* look for duplicate blocks */
	fs_get_header(block, &header);
	if(header.flag != FS_USED)
		return retval;
	file = header.file;
	seq = header.seq;
	ver = header.ver;

	for(j=(block+1); j<fs_num_blocks; j++) {
		fs_get_header(j, &header);
		if((file == header.file) && (seq == header.seq)) {
			/* matching file and sequence numbers; duplicate block, kill the larger version */
			retval = 1;
#ifdef FS_DEBUG
			printf("--> Duplicate blocks (%d <-> %d) found (file = %d, seq = %ld)\n",
				block, j, file, seq);
#endif
			if(ver > header.ver) {
				if((ver - header.ver) > 5) { /* arbitrary - 1 would probably do */
#ifdef FS_DEBUG
					printf("-->\t\tErasing block %d\n", j);
#endif
					fs_erase_block(j, 0);
				} else {
#ifdef FS_DEBUG
					printf("-->\t\tErasing block %d\n", block);
#endif
					fs_erase_block(block, 0);
				}
			} else {
				if((header.ver - ver) > 5) { /* arbitrary - 1 would probably do */
#ifdef FS_DEBUG
					printf("-->\t\tErasing block %d\n", block);
#endif
					fs_erase_block(block, 0);
				} else {
#ifdef FS_DEBUG
					printf("-->\t\tErasing block %d\n", j);
#endif
					fs_erase_block(j, 0);
				}
			}
		}
	}

	return retval;
}

/*** BeginHeader fs_block_append */
int fs_block_append(int block, char *data, int len);
/*** EndHeader */

//adds data to a block, returns new block number
nodebug int fs_block_append(int block, char *data, int len)
{
	auto int new_block, old_last, start, end;
	auto int first_sector, i;
	auto FSHeader header, new_block_header;
	auto char write_flag;

	fs_get_header(block, &header);
	if(len > FS_BLOCK_SIZE - header.last_byte)
		return -1; //data won't fit
	new_block = fs_find_free();
	if(new_block == FS_NOBLOCK)
		return -1;
	//need to get wear level
	fs_get_header(new_block, &new_block_header);
	old_last = header.last_byte;
	header.last_byte += len;
	header.ver++;
	header.wear = new_block_header.wear + 1;
	header.crc = fs_checksum(data, len, header.crc,
		old_last - header.first_byte);
	first_sector = new_block*((int)FS_BLOCK_SIZE/FS_SECTOR_SIZE);
	//write out the sectors
	for(i = 0;i < (int)FS_BLOCK_SIZE/FS_SECTOR_SIZE;i++)
	{
		write_flag = 0;
		if(i == 0)
		{
			//write out header
			root2xmem(fs_sectorbuf, &header, FS_HEADER);
			write_flag = 1;
		}
		if(header.first_byte < (i+1)*FS_SECTOR_SIZE &&
			old_last > i*FS_SECTOR_SIZE)
		{
			//copy data from old block
			if(header.first_byte > i*FS_SECTOR_SIZE)
				start = header.first_byte;
			else
				start = i*FS_SECTOR_SIZE;
			if(old_last < (i+1)*FS_SECTOR_SIZE)
				end = old_last;
			else
				end = (i+1)*FS_SECTOR_SIZE;

			fs_block_move(fs_sectorbuf + start - i*FS_SECTOR_SIZE,
				block, start, end - start);
			write_flag = 1;
		}
		if(header.last_byte >= i*FS_SECTOR_SIZE &&
			old_last < (i+1)*FS_SECTOR_SIZE)
		{
			//add new data
			if(old_last > i*FS_SECTOR_SIZE)
				start = old_last;
			else
				start = i*FS_SECTOR_SIZE;
			if(header.last_byte < (i+1)*FS_SECTOR_SIZE)
				end = header.last_byte;
			else
				end = (i+1)*FS_SECTOR_SIZE;
			root2xmem(fs_sectorbuf + start - i*FS_SECTOR_SIZE,
					 data + start - old_last, end - start );
			write_flag = 1;
		}
		if(header.last_byte < i*FS_SECTOR_SIZE)
		{
			fs_erase_block(block, 0);
			return new_block; //nothing more to write
		}
		if(write_flag)
			fs_writesector(first_sector + i, fs_sectorbuf, FS_SECTOR_SIZE);
	}
	fs_erase_block(block, 0);
	return new_block;
}

/*** BeginHeader fs_block_new */
int fs_block_new(FSHeader *header_ptr, char *buf, int len);
/*** EndHeader */

//puts data into a new block
nodebug int fs_block_new(FSHeader *header_ptr, char *buf, int len)
{
	auto FSHeader old_header;
	auto int first_sector, i, new_block, write_length;

	new_block = fs_find_free();
	if(new_block == FS_NOBLOCK)
		return -1;
	first_sector = new_block*((int)FS_BLOCK_SIZE/FS_SECTOR_SIZE);
	fs_get_header(new_block, &old_header);
	//update wear level
	header_ptr->wear = old_header.wear + 1;
	header_ptr->crc = fs_checksum(buf, len, 0, 0);
	i = 0;
	while(len > 0)
	{
		if(i == 0)
		{
			//write out header
			root2xmem(fs_sectorbuf, header_ptr, FS_HEADER);
			len -= FS_SECTOR_SIZE - FS_HEADER;
			root2xmem(fs_sectorbuf + FS_HEADER, buf, FS_SECTOR_SIZE - FS_HEADER);
			buf += FS_SECTOR_SIZE - FS_HEADER;
		}
		else
		{
			len -= FS_SECTOR_SIZE;
			root2xmem(fs_sectorbuf, buf, FS_SECTOR_SIZE);
			buf += FS_SECTOR_SIZE;
		}
		fs_writesector(first_sector + i, fs_sectorbuf, FS_SECTOR_SIZE);
		i++; //next sector
	}
	return new_block;
}

/*** BeginHeader fs_block_update */
int fs_block_update(int block, FSHeader *header_ptr);
/*** EndHeader */

//allows a block header to be changed, returns new block number
nodebug int fs_block_update(int block, FSHeader *header_ptr)
{
	auto FSHeader old_header;
	auto int i, first_sector, new_block, block_pos;

	new_block = fs_find_free();
	if(new_block == FS_NOBLOCK)
		return -1;
	first_sector = new_block*((int)FS_BLOCK_SIZE/FS_SECTOR_SIZE);
	fs_get_header(new_block, &old_header);
	//update wear level
	header_ptr->wear = old_header.wear + 1;
	for(i = 0; i < (int)FS_BLOCK_SIZE/FS_SECTOR_SIZE;i++)
	{
		if(i == 0)
		{
			//write new header into first sector
			root2xmem(fs_sectorbuf, header_ptr, FS_HEADER);
			fs_block_move(fs_sectorbuf + FS_HEADER,
				block, FS_HEADER, FS_SECTOR_SIZE - FS_HEADER);
			fs_writesector(first_sector, fs_sectorbuf, FS_SECTOR_SIZE);
		}
		else if(header_ptr->first_byte < (i+1)*FS_SECTOR_SIZE)
		{
			fs_block_move(fs_sectorbuf, block, i*FS_SECTOR_SIZE, FS_SECTOR_SIZE);
			fs_writesector(first_sector+i, fs_sectorbuf, FS_SECTOR_SIZE);
			if(header_ptr->last_byte < i*FS_SECTOR_SIZE)
				break; //stop iterating through sectors, were done
		}
	}
	fs_erase_block(block, 0);
	return new_block;
}


/*****************
 * API functions *
 *****************/

/*** BeginHeader fs_format */
int fs_format(long reserveblocks, int num_blocks, unsigned long wearlevel);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fs_format                      <filesystem.lib>

SYNTAX: int fs_format(long baseaddress, int num_blocks, unsigned wearlevel)

KEYWORDS:      file system

DESCRIPTION:   Initalize internal data structures and file system.

PARAMETER1:    The number of blocks to reserve at the start of the flash
               This parameter is ignored if you have FS_RAM defined.
PARAMETER2:    number of 4096 byte blocks
PARAMETER3:    initial wearlevel value.  This should be 1 if you have a
               new flash, and some larger number if the flash is used.
               If you are reformatting a flash, you can use 0 to use
               the old flash wear levels.

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

/*
 * should this just format, not open? for now it's just like fs_init,
 * but blanks the FS as it opens.
 */
nodebug int fs_format(long reserveblocks,
	int num_blocks, unsigned long wearlevel)
{
	auto int i;

#GLOBAL_INIT {
	fs_temp_buf = xalloc(FS_TEMPBUF_SIZE);
}

#ifdef FS_RAM
	fs_offset = 0;
#else
	fs_offset = reserveblocks*FS_BLOCK_SIZE;
#endif

	fs_num_blocks = num_blocks;

	/* Initilize the underlying medium */
	if(fs_block_init(fs_offset, num_blocks))
		return 1;

	/* format all the blocks */
	for(i=0;i<num_blocks;i++) {
		fs_erase_block(i, wearlevel);
	}
	// setup tables
	fs_table_alloc(num_blocks);
	//set up sector buffer
	fs_sectorbuf = xalloc(FS_SECTOR_SIZE);
	fs_blocks_used = 0;
	fs_nonpriv_blocks_used = 0;
	fs_blocks_reserved = 0;
	return 0;
}

/*** BeginHeader fs_init */
int fs_init(long reserveblocks, int num_blocks);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fs_init                        <filesystem.lib>

SYNTAX: int fs_init(long reserveblocks, int num_blocks)

KEYWORDS:      file system

DESCRIPTION:   Initalize internal data structures for an existing file
               system.

PARAMETER1:    The number of blocks to reserve at the start of the flash
               This parameter is ignored if you have FS_RAM defined.
PARAMETER2:    number of 4096 byte blocks

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fs_init(long reserveblocks, int num_blocks)
{
	auto int i, bad_fs;

#ifdef FS_RAM
	/* format only if we are in ram */
	return 1;
#endif

	fs_offset = reserveblocks*FS_BLOCK_SIZE;

	fs_num_blocks = num_blocks;

	/* Initilize the underlying medium */
	if(fs_block_init(fs_offset, num_blocks))
		return 1;

	/* verify all existing blocks */
	bad_fs = 0;
	for(i=0; i<num_blocks; i++) {
		if(fs_verify_block(i)) {
			bad_fs = 1;
		}
	}

	/* verify version numbers */
	for(i=0; i<num_blocks; i++) {
		if(fs_verify_version(i)) {
			bad_fs = 1;
		}
	}

	//build tables
	fs_table_alloc(num_blocks);
	fs_build_tables();
	fs_blocks_reserved = 0;
	//set up sector buffer
	fs_sectorbuf = xalloc(FS_SECTOR_SIZE);
	return bad_fs;
}

/*** BeginHeader fcreate_unused */
FileNumber fcreate_unused(File *f);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fcreate_unused                 <filesystem.lib>

SYNTAX: FileNumber fcreate_unused(File *f)

KEYWORDS:      file system

DESCRIPTION:   create a file selecting an unused file number

PARAMETER1:    file pointer

RETURN VALUE:  !=0 - file pointer
               0   - error

SEE ALSO:

END DESCRIPTION **********************************************************/

/* this will search for an unused file number, and fcreate it.
	This is much slower than just fcreate() */
/* returnes 0 on error (none free) */
nodebug FileNumber fcreate_unused(File *f)
{
	auto FileNumber i, j, used;
	auto FSHeader header;

	/* find an unused FileNumber */
	for(i=1; i<127; i++) {
		used = 0;
		for(j=0; j<fs_num_blocks; j++) {
			fs_get_header(j, &header);
			if(header.flag == FS_USED)
				if(header.file == i) {
					used = 1;
					break;
				}
		}
		if(!used) {
			if(fcreate(f, i) == 0)
			{
				//fcreate succeeded
				return i;
			}
			else
			{
				return 0;
			}
		}
	}

	return 0;
}

/*** BeginHeader fcreate */
int fcreate(File *f, FileNumber name);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fcreate                        <filesystem.lib>

SYNTAX: int fcreate(File *f, FileNumber name)

KEYWORDS:      file system

DESCRIPTION:   create a file.

PARAMETER1:    file pointer
PARAMETER2:    name of file

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fcreate(File *f, FileNumber name)
{
	auto int block;
	auto FSBlockLink block_link;
	auto FSHeader header;

#ifdef FS_DEBUG
	printf("--> Creating file <%d>\n",name);
#endif

	/* verify that it doesnt exist? */
	if(fs_open_common(f,name)==0)
		return 1;

	//do we have room?
	if(fs_blocks_used > fs_num_blocks - 2)
		return 1; //no blocks left
	if((name < 128 || name > 143) &&
		(fs_nonpriv_blocks_used > fs_num_blocks-fs_blocks_reserved-2))
		return 1;		//no non-priveleged blocks available

	/* allocate the first block */
	block = fs_find_free();
	if(block == FS_NOBLOCK)
		return 1; /* no free blocks */

	/* get the old header for the free block */
	fs_get_header(block, &header);

	header.flag = FS_USED;
	header.file = name;
	header.first_byte = FS_HEADER;
	header.last_byte = FS_HEADER;
	header.seq = 1;
	header.ver = 0;
	header.wear++;
	header.fs_version=FS_VERSION;
	header.crc = 0;

	/* update the block */
	fs_block_write(block, (char *)&header, FS_HEADER);

	//update the block list
	block_link.name = name;
	block_link.used = 1;
	block_link.next_block = -1;
	fs_blocklist_set(block, &block_link);
	//update file list
	fs_filelist_set(name, block);

	f->name = name;
	f->current_sequence = f->first_sequence = header.seq;
	f->current_block = f->first_block = block;
	f->current_offset = FS_HEADER; /* init to just past the header */
	f->position = 0;
	f->num_blocks = 1;
	fs_blocks_used++;
	if(name < 128 || name > 143)
		fs_nonpriv_blocks_used++;

	f->mode = FS_WRITE;
	return 0;
}

/*** BeginHeader fdelete */
int fdelete(FileNumber name);
/*** EndHeader */
/* START FUNCTION DESCRIPTION ********************************************
fdelete                        <filesystem.lib>

SYNTAX: int fdelete(FileNumber name)

KEYWORDS:      file system

DESCRIPTION:   delete a file

PARAMETER1:    file number of file to delete

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fdelete(FileNumber name)
{
	auto int block, next;

	block = fs_filelist_get(name);
	if(-1 == block)
		return 1;	// file not found

	fs_filelist_set(name, -1); //remove from filelist
	while(block >= 0)
	{
		next = fs_get_next_block(block);
		fs_erase_block(block, 0);
		block = next;
		fs_blocks_used--;
		if(name < 128 || name > 143)
			fs_nonpriv_blocks_used--;
	}
	return 0; // return success
}

/*** BeginHeader fopen_rd */
int fopen_rd(File *f, FileNumber name);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fopen_rd                       <filesystem.lib>

SYNTAX: int fopen_rd(File *f, FileNumber name)

KEYWORDS:      file system

DESCRIPTION:   open a file for reading.

PARAMETER1:    file pointer
PARAMETER2:    name of file

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fopen_rd(File *f, FileNumber name)
{
	auto FSHeader header;

	if(fs_open_common(f, name))
		return 1;

	fs_get_header(f->first_block, &header);

	f->mode = FS_READ;

	/* init the current pointer to the first block */
	f->current_sequence = f->first_sequence;
	f->current_block = f->first_block;
	f->position = 0;
	f->current_offset = header.first_byte;

#ifdef FS_DEBUG
	printf("--> open_rd: cur_seq = %d, cur_block = %d, position = %d, cur_offset = %d\n",
		f->current_sequence, f->current_block, f->position, f->current_offset);
#endif
	return 0;
}

/*** BeginHeader fopen_wr */
int fopen_wr(File *f, FileNumber name);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fopen_wr                       <filesystem.lib>

SYNTAX: int fopen_wr(File *f, FileNumber name)

KEYWORDS:      file system

DESCRIPTION:   open a file for writing.

PARAMETER1:    file pointer
PARAMETER2:    name of file

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fopen_wr(File *f, FileNumber name)
{
	auto FSHeader header;

	if(fs_open_common(f, name))
		return 1;

	f->mode = FS_WRITE;

	/* find the last block */
	fs_get_header(f->current_block, &header);

	f->position = ((f->num_blocks - 1)*((int)FS_BLOCK_SIZE - FS_HEADER))
		+ (header.last_byte - header.first_byte);
	f->current_offset = header.first_byte;

	return 0;
}

/*** BeginHeader fclose */
void fclose(File *f);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fclose                         <filesystem.lib>

SYNTAX: void fclose(File *f)

KEYWORDS:      file system

DESCRIPTION:   close the file pointed to by f.

PARAMETER1:    file pointer

RETURN VALUE:  none

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug void fclose(File *f)
{
	/* just mark it as invalid */
	f->mode = FS_NOTOPEN;
}

/*** BeginHeader fwrite */
int fwrite(File *f, char *buf, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fwrite                         <filesystem.lib>

SYNTAX: int fwrite(File *f, char *buf, int len)

KEYWORDS:      file system

DESCRIPTION:   write len bytes to the file starting at the current
               offset in the file from buf.

PARAMETER1:    file pointer
PARAMETER2:    source buffer
PARAMETER3:    number of bytes to write

RETURN VALUE:  number of bytes written
               0 - error

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fwrite(File *f, char *buf, int len)
{
	auto int block, new_block, previous_block;
	auto FSBlockLink link;
	auto FSHeader header, old_header;
	auto int written;
	auto int write_size;
	auto long last_sequence;

	written = 0;
	while(len > 0)
	{
		//get previous and current blocks
		previous_block = -1;
		block = fs_filelist_get(f->name);
		if(block == -1)
			return 0; //file does not exist
		while(1)
		{
			if(fs_get_next_block(block) == -1)
			{
				break;
			}
			else
			{
				previous_block = block;
				block = fs_get_next_block(block);
			}
		}
		fs_get_header(block, &header);
		last_sequence = header.seq;
		if( header.last_byte == (int)FS_BLOCK_SIZE)
		{
			//start writing to new block
			//do we have room?
			if(fs_blocks_used > fs_num_blocks - 2)
				return written; //no blocks left
			if((f->name < 128 || f->name > 143) &&
				(fs_nonpriv_blocks_used > fs_num_blocks-fs_blocks_reserved-2))
				return written;	//no non-priveleged blocks available

			//setup new header
			if(len > FS_BLOCK_SIZE - FS_HEADER)
			{
				write_size = FS_BLOCK_SIZE - FS_HEADER;
			}
			else
			{
				write_size = len;
			}
			header.crc = fs_checksum(buf, write_size, 0, 0);
			header.first_byte = FS_HEADER;
			header.last_byte = write_size + FS_HEADER;
			header.seq = last_sequence + 1;
			header.ver = 0;
			header.fs_version = FS_VERSION;
			header.flag = FS_USED;
			header.file = f->name;
			new_block = fs_block_new(&header, buf, write_size);
			//update table
			fs_blocklist_get(block, &link);
			link.next_block = new_block;
			fs_blocklist_set(block, &link);
			link.name = f->name;
			link.used = 1;
			link.next_block = -1;
			fs_blocklist_set(new_block, &link);
			fs_blocks_used++;
			if(f->name < 128 || f->name > 143)
				fs_nonpriv_blocks_used++;

		}
		else
		{
			//add to existing block
			if(len > (int)FS_BLOCK_SIZE - header.last_byte)
			{
				write_size = (int)FS_BLOCK_SIZE - header.last_byte;
			}
			else
			{
				write_size = len;
			}
			new_block = fs_block_append(block, buf, write_size);
			if(f->current_block == block)
			{
				f->current_block = new_block;
			}
			if(previous_block == -1)
			{
				f->first_block = new_block;
				fs_filelist_set(f->name, new_block);
			}
			else
			{
				//update next pointer for previous block
				fs_blocklist_get(previous_block, &link);
				link.next_block = new_block;
				fs_blocklist_set(previous_block, &link);
			}
			//unset old block in table
			link.used = 0;
			link.next_block = -1;
			fs_blocklist_set(block, &link);
			//update new block in table
			link.name = f->name;
			link.used = 1;
			link.next_block = -1;
			fs_blocklist_set(new_block, &link);
		}
		len -= write_size;
		buf += write_size;
		written += write_size;
	}	//end of while(len)
	return written;
}

/*** BeginHeader fshift */
int fshift(File *f, int count, char *buf);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fshift                         <filesystem.lib>

SYNTAX: int fshift(File *f, int count, char *buffer)

KEYWORDS:      file system

DESCRIPTION:   removes 'count' number of bytes from the beginning of a file.
					These bytes will be copied into the buffer if it is not null

PARAMETER1:    file pointer
PARAMETER2:    number of bytes to shift out
PARAMETER3:    buffer to store shifted bytes. If this is NULL, it will not
					be used.

RETURN VALUE:  number of bytes shifted out
               0 - error

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fshift(File *f, int count, char *buf)
{
	auto int shifted, shift_size, block, new_block;
	auto FSHeader header;
	auto FSBlockLink link;

	shifted = 0;
	while(count > 0)
	{
		block = fs_filelist_get(f->name);
		if(block < 0)
			return 0; //no starting block listed
		fs_get_header(block, &header);
		if(count >= header.last_byte - header.first_byte)
		{
			//shift out all of the block
			shift_size = header.last_byte - header.first_byte;
			if(buf)
			{
				fs_block_read(block, header.first_byte, buf, shift_size);
				buf += shift_size;
			}
			fs_blocklist_get(block, &link);
			new_block = link.next_block;
			if(new_block == FS_NOBLOCK)
			{
				count = 0; //stop shifting, file is empty
				header.first_byte = header.last_byte;
				header.crc = 0;
				header.ver++;
				new_block = fs_block_update(block, &header);
				fs_blocklist_set(new_block, &link);
			}
			else
			{
				fs_get_header(new_block, &header);
				f->num_blocks--;
				f->first_sequence = header.seq;
				fs_erase_block(block, 0);
				fs_blocks_used--;
				if(f->name < 128 || f->name > 143)
					fs_nonpriv_blocks_used--;
			}
			if(f->current_block == block)
			{
				f->current_block = new_block;
				f->current_offset = header.first_byte;
			}
		}
		else
		{
			//just shift out some of the block
			shift_size = count;
			if(buf)
			{
				fs_block_read(block, header.first_byte, buf, shift_size);
			}
			header.first_byte += shift_size;
			header.crc = fs_checksum_far(block, header.first_byte,
										header.last_byte - header.first_byte, 0, 0);
			header.ver++;
			fs_blocklist_get(block, &link);
			new_block = fs_block_update(block, &header);
			fs_blocklist_set(new_block, &link);
			if(f->current_block = block)
			{
				f->current_block = new_block;
				if(header.first_byte > f->current_offset)
					f->current_offset = header.first_byte;
			}
		}

		link.next_block = -1;
		link.used = 0;
		link.name = 0;
		fs_blocklist_set(block, &link);
		fs_filelist_set(f->name, new_block);
		f->first_block = new_block;
		f->position -= shift_size;
		if(f->position < 0)
			f->position == 0;
		count -= shift_size;
		shifted += shift_size;
	}
	return shifted;
}

/*** BeginHeader fread */
int fread(File *f, char *buf, int len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fread                          <filesystem.lib>

SYNTAX: int fread(File *f, char *buf, int len)

KEYWORDS:      file system

DESCRIPTION:   read len bytes from the file starting at the current
               offset in the file into buf.

PARAMETER1:    file pointer
PARAMETER2:    destination buffer
PARAMETER3:    number of bytes to copy

RETURN VALUE:  number of bytes read
               0 - error

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fread(File *f, char *buf, int len)
{
	auto int remaining, read_len, bytes_read;
	auto int block;
	auto FSHeader header;

	if(f->mode!=FS_WRITE && f->mode!=FS_READ) return 0;

	bytes_read = 0;
	while(len) {
		/* loop through blocks until we read all they requested */

		fs_get_header(f->current_block, &header);

		if(len > header.last_byte - f->current_offset) {
			read_len = header.last_byte - f->current_offset;
		} else {
			read_len = len;
		}

#ifdef FS_CHECKSUM_READS
		/* verify the checksum */
		if(header.crc != fs_checksum_far(f->current_block, header.first_byte,
								  			header.last_byte - header.first_byte, 0, 0)) {
			/* ERROR IN CHECKSUM! */
#ifdef FS_DEBUG
			printf("--> Block #%d has a bad checksum!\n",f->current_block);
#endif
			return 0;
		}
#endif

#ifdef FS_DEBUG
		printf("--> reading <%d> bytes from block <%d>, seq = %d\n",read_len,f->current_block, header.seq);
#endif
		fs_block_read(f->current_block, f->current_offset, buf, read_len);
		buf += read_len;
		bytes_read += read_len;
		len -= read_len;
		f->current_offset += read_len;
		f->position += read_len;

		if(f->current_offset == header.last_byte)
		{
			/* move to the next block */
			block = fs_get_next_block(f->current_block);
			if(block == FS_NOBLOCK) {
				/* block not found - we hit the end of the file */
				return bytes_read;
			}
			else
			{
				f->current_sequence++;
				f->current_block = block;
				fs_get_header(f->current_block, &header);
				f->current_offset = header.first_byte;
			}
		}
	}
	return bytes_read;
}

/*** BeginHeader ftell */
long ftell(File *f);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
ftell                          <filesystem.lib>

SYNTAX: long ftell(File *f)

KEYWORDS:      file system

DESCRIPTION:   This function returns the current pointer.

PARAMETER1:    file pointer
PARAMETER2:    offset in file

RETURN VALUE:  offset in file
               -1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug long ftell(File *f)
{
	auto int block;
	auto FSSeq i;
	auto long len;
	auto FSHeader header;

	if(f->mode!=FS_WRITE && f->mode!=FS_READ) return -1;

	block = fs_filelist_get(f->name);
	if(block == FS_NOBLOCK) return -1;
	len = 0;
	while(block >= 0)
	{
		fs_get_header(block, &header);
		if(header.seq == f->current_sequence)
		{
			//current block
			len += f->current_offset - header.first_byte;
			break;
		}
		else
		{
			len += header.last_byte - header.first_byte;
		}
		block = fs_get_next_block(block);
	}
	return len;
}

/*** BeginHeader fseek */
int fseek(File *f, long to, char whence);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fseek                          <filesystem.lib>

SYNTAX: int fseek(File *f, long where, char whence)

KEYWORDS:      file system

DESCRIPTION:   This function places the current read pointer at
               where in the file.

               SEEK_SET - offset is measured from the beginning
               SEEK_CUR - offset is measured from the current offset
               SEEK_END - offset is measured backwards from end.

PARAMETER1:    file pointer
PARAMETER2:    offset in file
PARAMETER3:    where to measure the offset.

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fseek(File *f, long to, char whence)
{
	auto long prev, filelength, currentpos, seekpos;
	auto int block, current_mark;
	auto FSSeq i;
	auto FSHeader header;

	if(f->mode!=FS_WRITE && f->mode!=FS_READ) return 1;

	prev = 0;

	//calculate file length
	filelength = 0;
	currentpos = 0;
	current_mark = 0; //flag set when current position is hit
	block = fs_filelist_get(f->name);
	if(block == FS_NOBLOCK) return 1;
	while(block >= 0)
	{
		fs_get_header(block, &header);
		filelength += header.last_byte - header.first_byte;
		if(header.seq == f->current_sequence)
		{
			currentpos += f->current_offset - header.first_byte;
			current_mark = 1;
		}
		else if(current_mark == 0)
		{
			currentpos += header.last_byte - header.first_byte;
		}
		block = fs_get_next_block(block);
	}

	switch(whence)
	{
		case SEEK_SET:
			seekpos = to;
			break;
		case SEEK_CUR:
			seekpos = currentpos + to;
			break;
		case SEEK_END:
			seekpos = filelength + to;
			break;
		default:
		/* ERROR - unknown 'whence' value! */
		return 1;
	}
	//check limits
	if(seekpos < 0 || seekpos > filelength)
		return 1;
	f->position = seekpos;
	//set file pointer
	block = fs_filelist_get(f->name);
	while(block >= 0)
	{
		fs_get_header(block, &header);
		if(seekpos > header.last_byte - header.first_byte)
		{
			seekpos -= header.last_byte - header.first_byte;
		}
		else
		{
			//this is our block
			f->current_block = block;
			f->current_sequence = header.seq;
			f->current_offset = header.first_byte + (int)seekpos;
			return 0;
		}
		block = fs_get_next_block(block);
	}
	return 1;	//end of file, this shouldn't happen
}

/*** BeginHeader fs_level_wear */
int fs_level_wear(int seconds);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fs_level_wear                  <filesystem.lib>

SYNTAX: int fs_level_wear(int seconds)

KEYWORDS:      file system

DESCRIPTION:   Wear level flash - Unimplemented.

PARAMETER1:    number of seconds to wearlevel

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fs_level_wear(int seconds)
{
	/* not implemented yet */
}

/*** Beginheader fs_reserve_blocks */
int fs_reserve_blocks(int blocks);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fs_reserve_blocks                  <filesystem.lib>

SYNTAX: int fs_reserve_blocks(int blocks)

KEYWORDS:      file system

DESCRIPTION:   Sets up a number of blocks that will be guarenteed to be
					available for priveleged files (128-143)

PARAMETER1:    number of blocks to reserve

RETURN VALUE:  0 - success
               1 - failure

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fs_reserve_blocks(int blocks)
{
	if(blocks >= 0 && blocks < fs_num_blocks - fs_nonpriv_blocks_used)
	{
		fs_blocks_reserved = blocks;
		return 0;
	}
	else
	{
		return 1; //failed
	}
}

/*** BeginHeader fsck */
int fsck(int flags);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
fsck		                  <filesystem.lib>

SYNTAX: int fsck(int flags)

KEYWORDS:      file system

DESCRIPTION:   Check the filesystem for errors.

PARAMETER1:    A bitmask indicating which checks to NOT perform.
					The following checks are avaliable:
						FSCK_HEADERS	- Block headers
						FSCK_CHECKSUMS - Data checksums
						FSCK_VERSION	- Block versions, from a failed write.

RETURN VALUE:  0 - success
					non 0 - A bitmask indicating which checks failed.

SEE ALSO:

END DESCRIPTION **********************************************************/

nodebug int fsck(int flags)
{
	auto int i;
	auto int retval;
	FSHeader header;

	retval = 0;
	if(!(FSCK_HEADERS&flags)) {
#ifdef FS_DEBUG
		printf("Checking filesystem block headers...\n");
#endif

		for(i=0; i<fs_num_blocks; i++) {
			if(fs_verify_block(i)) {
				/* ERROR IN HEADER */
#ifdef FS_DEBUG
				printf("Error in header for block #%d\n",i);
#endif
				retval |= FSCK_HEADERS;
			}
		}
	}

	if(!(FSCK_CHECKSUMS&flags)) {
#ifdef FS_DEBUG
		printf("Checking filesystem checksums...\n");
#endif

		for(i=0; i<fs_num_blocks; i++) {
			fs_get_header(i, &header);
			if(header.flag == FS_USED)
				if(header.crc != fs_checksum_far(i, header.first_byte,
					header.last_byte - header.first_byte, 0, 0)) {

					/* ERROR IN BLOCK! */
#ifdef FS_DEBUG
					printf("Error in checksum on block #%d!\n",i);
#endif
					retval |= FSCK_CHECKSUMS;
			}
		}
	}

	if(!(FSCK_VERSION&flags)) {
#ifdef FS_DEBUG
		printf("Checking for duplicate blocks...\n");
#endif

		for(i=0; i<fs_num_blocks; i++) {
			if(fs_verify_version(i)) {
				retval |= FSCK_VERSION;
			}
		}
	}

	return retval;
}